(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{

/***/ "./node_modules/@download/blockies/src/blockies.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@download/blockies/src/blockies.mjs ***!
  \**********************************************************/
/*! exports provided: renderIcon, createIcon */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renderIcon\", function() { return renderIcon; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createIcon\", function() { return createIcon; });\n// The random number is a js implementation of the Xorshift PRNG\nconst randseed = new Array(4); // Xorshift: [x, y, z, w] 32 bit values\n\nfunction seedrand(seed) {\n\trandseed.fill(0);\n\n\tfor(let i = 0; i < seed.length; i++) {\n\t\trandseed[i%4] = ((randseed[i%4] << 5) - randseed[i%4]) + seed.charCodeAt(i);\n\t}\n}\n\nfunction rand() {\n\t// based on Java's String.hashCode(), expanded to 4 32bit values\n\tconst t = randseed[0] ^ (randseed[0] << 11);\n\n\trandseed[0] = randseed[1];\n\trandseed[1] = randseed[2];\n\trandseed[2] = randseed[3];\n\trandseed[3] = (randseed[3] ^ (randseed[3] >> 19) ^ t ^ (t >> 8));\n\n\treturn (randseed[3] >>> 0) / ((1 << 31) >>> 0);\n}\n\nfunction createColor() {\n\t//saturation is the whole color spectrum\n\tconst h = Math.floor(rand() * 360);\n\t//saturation goes from 40 to 100, it avoids greyish colors\n\tconst s = ((rand() * 60) + 40) + '%';\n\t//lightness can be anything from 0 to 100, but probabilities are a bell curve around 50%\n\tconst l = ((rand() + rand() + rand() + rand()) * 25) + '%';\n\n\treturn 'hsl(' + h + ',' + s + ',' + l + ')';\n}\n\nfunction createImageData(size) {\n\tconst width = size; // Only support square icons for now\n\tconst height = size;\n\n\tconst dataWidth = Math.ceil(width / 2);\n\tconst mirrorWidth = width - dataWidth;\n\n\tconst data = [];\n\tfor(let y = 0; y < height; y++) {\n\t\tlet row = [];\n\t\tfor(let x = 0; x < dataWidth; x++) {\n\t\t\t// this makes foreground and background color to have a 43% (1/2.3) probability\n\t\t\t// spot color has 13% chance\n\t\t\trow[x] = Math.floor(rand()*2.3);\n\t\t}\n\t\tconst r = row.slice(0, mirrorWidth);\n\t\tr.reverse();\n\t\trow = row.concat(r);\n\n\t\tfor(let i = 0; i < row.length; i++) {\n\t\t\tdata.push(row[i]);\n\t\t}\n\t}\n\n\treturn data;\n}\n\nfunction buildOpts(opts) {\n\tconst newOpts = {};\n\n\tnewOpts.seed = opts.seed || Math.floor((Math.random()*Math.pow(10,16))).toString(16);\n\n\tseedrand(newOpts.seed);\n\n\tnewOpts.size = opts.size || 8;\n\tnewOpts.scale = opts.scale || 4;\n\tnewOpts.color = opts.color || createColor();\n\tnewOpts.bgcolor = opts.bgcolor || createColor();\n\tnewOpts.spotcolor = opts.spotcolor || createColor();\n\n\treturn newOpts;\n}\n\nfunction renderIcon(opts, canvas) {\n\topts = buildOpts(opts || {});\n\tconst imageData = createImageData(opts.size);\n\tconst width = Math.sqrt(imageData.length);\n\n\tcanvas.width = canvas.height = opts.size * opts.scale;\n\n\tconst cc = canvas.getContext('2d');\n\tcc.fillStyle = opts.bgcolor;\n\tcc.fillRect(0, 0, canvas.width, canvas.height);\n\tcc.fillStyle = opts.color;\n\n\tfor(let i = 0; i < imageData.length; i++) {\n\n\t\t// if data is 0, leave the background\n\t\tif(imageData[i]) {\n\t\t\tconst row = Math.floor(i / width);\n\t\t\tconst col = i % width;\n\n\t\t\t// if data is 2, choose spot color, if 1 choose foreground\n\t\t\tcc.fillStyle = (imageData[i] == 1) ? opts.color : opts.spotcolor;\n\n\t\t\tcc.fillRect(col * opts.scale, row * opts.scale, opts.scale, opts.scale);\n\t\t}\n\t}\n\n\treturn canvas;\n}\n\nfunction createIcon(opts) {\n\tvar canvas = document.createElement('canvas');\n\n\trenderIcon(opts, canvas);\n\n\treturn canvas;\n}\n\n\n//# sourceURL=webpack:///./node_modules/@download/blockies/src/blockies.mjs?");

/***/ }),

/***/ "./node_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib.js ***!
  \*********************************************************************************************/
/*! exports provided: __wbg_set_wasm, create_send_all, min_fee, calculate_ex_units_ceil_cost, min_script_fee, encrypt_with_password, decrypt_with_password, make_daedalus_bootstrap_witness, make_icarus_bootstrap_witness, make_vkey_witness, hash_auxiliary_data, hash_transaction, hash_plutus_data, hash_script_data, get_implicit_input, get_deposit, min_ada_for_output, min_ada_required, encode_json_str_to_native_script, encode_json_str_to_plutus_datum, decode_plutus_datum_to_json_str, encode_arbitrary_bytes_as_metadatum, decode_arbitrary_bytes_from_metadatum, encode_json_str_to_metadatum, decode_metadatum_to_json_str, VoterKind, CborContainerType, CredKind, DRepKind, ScriptSchema, RelayKind, NativeScriptKind, ScriptHashNamespace, NetworkIdKind, VoteKind, CertificateKind, VotingProposalKind, LanguageKind, PlutusDataKind, RedeemerTagKind, PlutusDatumSchema, TransactionMetadatumKind, MetadataJsonSchema, CoinSelectionStrategyCIP2, MIRPot, MIRKind, Address, Anchor, AnchorDataHash, AssetName, AssetNames, Assets, AuxiliaryData, AuxiliaryDataHash, AuxiliaryDataSet, BaseAddress, BigInt, BigNum, Bip32PrivateKey, Bip32PublicKey, Block, BlockHash, BootstrapWitness, BootstrapWitnesses, ByronAddress, Certificate, Certificates, CertificatesBuilder, Committee, CommitteeColdResign, CommitteeHotAuth, Constitution, ConstrPlutusData, CostModel, Costmdls, Credential, Credentials, DNSRecordAorAAAA, DNSRecordSRV, DRep, DataCost, DataHash, DatumSource, DrepDeregistration, DrepRegistration, DrepUpdate, DrepVotingThresholds, Ed25519KeyHash, Ed25519KeyHashes, Ed25519Signature, EnterpriseAddress, ExUnitPrices, ExUnits, FixedTransaction, GeneralTransactionMetadata, GenesisDelegateHash, GenesisHash, GenesisHashes, GenesisKeyDelegation, GovernanceActionId, GovernanceActionIds, HardForkInitiationProposal, Header, HeaderBody, InfoProposal, InputWithScriptWitness, InputsWithScriptWitness, Int, Ipv4, Ipv6, KESSignature, KESVKey, Language, Languages, LegacyDaedalusPrivateKey, LinearFee, MIRToStakeCredentials, MetadataList, MetadataMap, Mint, MintAssets, MintBuilder, MintWitness, MintsAssets, MoveInstantaneousReward, MoveInstantaneousRewardsCert, MultiAsset, MultiHostName, NativeScript, NativeScriptSource, NativeScripts, NetworkId, NetworkInfo, NewConstitutionProposal, NoConfidenceProposal, Nonce, OperationalCert, OutputDatum, ParameterChangeProposal, PlutusData, PlutusList, PlutusMap, PlutusScript, PlutusScriptSource, PlutusScripts, PlutusWitness, PlutusWitnesses, Pointer, PointerAddress, PoolMetadata, PoolMetadataHash, PoolParams, PoolRegistration, PoolRetirement, PoolVotingThresholds, PrivateKey, ProposedProtocolParameterUpdates, ProtocolParamUpdate, ProtocolVersion, PublicKey, PublicKeys, Redeemer, RedeemerTag, Redeemers, Relay, Relays, RewardAddress, RewardAddresses, ScriptAll, ScriptAny, ScriptDataHash, ScriptHash, ScriptHashes, ScriptNOfK, ScriptPubkey, ScriptRef, SingleHostAddr, SingleHostName, StakeAndVoteDelegation, StakeDelegation, StakeDeregistration, StakeRegistration, StakeRegistrationAndDelegation, StakeVoteRegistrationAndDelegation, Strings, TimelockExpiry, TimelockStart, Transaction, TransactionBatch, TransactionBatchList, TransactionBodies, TransactionBody, TransactionBuilder, TransactionBuilderConfig, TransactionBuilderConfigBuilder, TransactionHash, TransactionInput, TransactionInputs, TransactionMetadatum, TransactionMetadatumLabels, TransactionOutput, TransactionOutputAmountBuilder, TransactionOutputBuilder, TransactionOutputs, TransactionUnspentOutput, TransactionUnspentOutputs, TransactionWitnessSet, TransactionWitnessSets, TreasuryWithdrawals, TreasuryWithdrawalsProposal, TxBuilderConstants, TxInputsBuilder, URL, UnitInterval, Update, UpdateCommitteeProposal, VRFCert, VRFKeyHash, VRFVKey, Value, Vkey, Vkeys, Vkeywitness, Vkeywitnesses, VoteDelegation, VoteRegistrationAndDelegation, Voter, Voters, VotingBuilder, VotingProcedure, VotingProcedures, VotingProposal, VotingProposalBuilder, VotingProposals, Withdrawals, WithdrawalsBuilder, __wbindgen_string_new, __wbindgen_object_drop_ref, __wbindgen_string_get, __wbindgen_error_new, __wbindgen_number_new, __wbindgen_object_clone_ref, __wbindgen_is_object, __wbg_set_20cbc34131e76824, __wbg_String_91fba7ded13ba54c, __wbg_randomFillSync_dc1e9a60c158336d, __wbg_getRandomValues_37fa2ca9e4e07fab, __wbg_crypto_c48a774b022d20ac, __wbg_process_298734cf255a885d, __wbg_versions_e2e78e134e3e5d01, __wbg_node_1cd7a5d853dbea79, __wbindgen_is_string, __wbg_require_8f08ceecec0f4fee, __wbg_msCrypto_bcb970640f50a1e8, __wbg_new_1d9a920c6bfc44a8, __wbindgen_is_function, __wbg_newnoargs_b5b063fc6c2f0376, __wbg_new_268f7b7dd3430798, __wbg_call_97ae9d8645dc388b, __wbg_new_0b9bfdd97583284e, __wbg_self_6d479506f72c6a71, __wbg_window_f2557cc78490aceb, __wbg_globalThis_7f206bda628d5286, __wbg_global_ba75c50d1cf384f4, __wbindgen_is_undefined, __wbg_set_a68214f35c417fa9, __wbg_call_168da88779e35f61, __wbg_set_933729cf5b66ac11, __wbg_buffer_3f3d764d4747d564, __wbg_newwithbyteoffsetandlength_d9aa266703cb98be, __wbg_new_8c3f0052272a457a, __wbg_set_83db9690f9353e79, __wbg_newwithlength_f5933855e4f48a19, __wbg_subarray_58ad4efbb5bcb886, __wbg_new_d87f272aec784ec0, __wbg_call_eae29933372a39be, __wbindgen_jsval_eq, __wbg_self_e0b3266d2d9eba1a, __wbg_crypto_e95a6e54c5c2e37f, __wbg_getRandomValues_dc67302a7bd1aec5, __wbg_require_0993fe224bf8e202, __wbg_randomFillSync_dd2297de5917c74e, __wbg_getRandomValues_02639197c8166a96, __wbindgen_debug_string, __wbindgen_throw, __wbindgen_memory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardano_serialization_lib_bg.wasm */ \"./node_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib_bg.wasm\");\n/* harmony import */ var _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardano_serialization_lib_bg.js */ \"./node_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib_bg.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_set_wasm\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_set_wasm\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"create_send_all\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"create_send_all\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"min_fee\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"min_fee\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"calculate_ex_units_ceil_cost\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"calculate_ex_units_ceil_cost\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"min_script_fee\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"min_script_fee\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"encrypt_with_password\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"encrypt_with_password\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"decrypt_with_password\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"decrypt_with_password\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"make_daedalus_bootstrap_witness\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"make_daedalus_bootstrap_witness\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"make_icarus_bootstrap_witness\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"make_icarus_bootstrap_witness\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"make_vkey_witness\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"make_vkey_witness\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"hash_auxiliary_data\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"hash_auxiliary_data\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"hash_transaction\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"hash_transaction\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"hash_plutus_data\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"hash_plutus_data\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"hash_script_data\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"hash_script_data\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"get_implicit_input\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"get_implicit_input\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"get_deposit\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"get_deposit\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"min_ada_for_output\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"min_ada_for_output\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"min_ada_required\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"min_ada_required\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"encode_json_str_to_native_script\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"encode_json_str_to_native_script\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"encode_json_str_to_plutus_datum\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"encode_json_str_to_plutus_datum\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"decode_plutus_datum_to_json_str\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"decode_plutus_datum_to_json_str\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"encode_arbitrary_bytes_as_metadatum\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"encode_arbitrary_bytes_as_metadatum\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"decode_arbitrary_bytes_from_metadatum\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"decode_arbitrary_bytes_from_metadatum\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"encode_json_str_to_metadatum\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"encode_json_str_to_metadatum\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"decode_metadatum_to_json_str\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"decode_metadatum_to_json_str\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VoterKind\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"VoterKind\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CborContainerType\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"CborContainerType\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CredKind\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"CredKind\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DRepKind\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"DRepKind\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ScriptSchema\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"ScriptSchema\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RelayKind\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"RelayKind\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NativeScriptKind\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"NativeScriptKind\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ScriptHashNamespace\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"ScriptHashNamespace\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NetworkIdKind\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"NetworkIdKind\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VoteKind\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"VoteKind\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CertificateKind\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"CertificateKind\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VotingProposalKind\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"VotingProposalKind\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LanguageKind\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"LanguageKind\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PlutusDataKind\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"PlutusDataKind\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RedeemerTagKind\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"RedeemerTagKind\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PlutusDatumSchema\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"PlutusDatumSchema\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransactionMetadatumKind\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TransactionMetadatumKind\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MetadataJsonSchema\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"MetadataJsonSchema\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CoinSelectionStrategyCIP2\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"CoinSelectionStrategyCIP2\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MIRPot\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"MIRPot\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MIRKind\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"MIRKind\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Address\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Address\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Anchor\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Anchor\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AnchorDataHash\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"AnchorDataHash\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AssetName\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"AssetName\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AssetNames\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"AssetNames\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Assets\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Assets\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AuxiliaryData\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"AuxiliaryData\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AuxiliaryDataHash\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"AuxiliaryDataHash\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AuxiliaryDataSet\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"AuxiliaryDataSet\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BaseAddress\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"BaseAddress\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BigInt\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"BigInt\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BigNum\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"BigNum\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Bip32PrivateKey\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Bip32PrivateKey\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Bip32PublicKey\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Bip32PublicKey\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Block\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Block\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BlockHash\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"BlockHash\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BootstrapWitness\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"BootstrapWitness\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BootstrapWitnesses\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"BootstrapWitnesses\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ByronAddress\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"ByronAddress\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Certificate\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Certificate\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Certificates\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Certificates\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CertificatesBuilder\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"CertificatesBuilder\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Committee\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Committee\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CommitteeColdResign\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"CommitteeColdResign\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CommitteeHotAuth\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"CommitteeHotAuth\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Constitution\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Constitution\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ConstrPlutusData\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"ConstrPlutusData\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CostModel\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"CostModel\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Costmdls\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Costmdls\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Credential\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Credential\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Credentials\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Credentials\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DNSRecordAorAAAA\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"DNSRecordAorAAAA\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DNSRecordSRV\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"DNSRecordSRV\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DRep\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"DRep\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DataCost\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"DataCost\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DataHash\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"DataHash\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DatumSource\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"DatumSource\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DrepDeregistration\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"DrepDeregistration\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DrepRegistration\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"DrepRegistration\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DrepUpdate\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"DrepUpdate\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DrepVotingThresholds\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"DrepVotingThresholds\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Ed25519KeyHash\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Ed25519KeyHash\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Ed25519KeyHashes\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Ed25519KeyHashes\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Ed25519Signature\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Ed25519Signature\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EnterpriseAddress\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"EnterpriseAddress\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ExUnitPrices\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"ExUnitPrices\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ExUnits\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"ExUnits\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"FixedTransaction\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"FixedTransaction\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"GeneralTransactionMetadata\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"GeneralTransactionMetadata\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"GenesisDelegateHash\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"GenesisDelegateHash\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"GenesisHash\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"GenesisHash\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"GenesisHashes\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"GenesisHashes\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"GenesisKeyDelegation\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"GenesisKeyDelegation\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"GovernanceActionId\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"GovernanceActionId\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"GovernanceActionIds\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"GovernanceActionIds\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"HardForkInitiationProposal\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"HardForkInitiationProposal\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Header\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Header\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"HeaderBody\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"HeaderBody\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"InfoProposal\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"InfoProposal\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"InputWithScriptWitness\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"InputWithScriptWitness\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"InputsWithScriptWitness\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"InputsWithScriptWitness\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Int\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Int\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Ipv4\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Ipv4\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Ipv6\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Ipv6\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"KESSignature\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"KESSignature\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"KESVKey\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"KESVKey\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Language\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Language\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Languages\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Languages\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LegacyDaedalusPrivateKey\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"LegacyDaedalusPrivateKey\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LinearFee\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"LinearFee\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MIRToStakeCredentials\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"MIRToStakeCredentials\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MetadataList\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"MetadataList\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MetadataMap\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"MetadataMap\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Mint\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Mint\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MintAssets\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"MintAssets\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MintBuilder\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"MintBuilder\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MintWitness\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"MintWitness\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MintsAssets\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"MintsAssets\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MoveInstantaneousReward\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"MoveInstantaneousReward\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MoveInstantaneousRewardsCert\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"MoveInstantaneousRewardsCert\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MultiAsset\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"MultiAsset\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MultiHostName\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"MultiHostName\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NativeScript\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"NativeScript\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NativeScriptSource\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"NativeScriptSource\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NativeScripts\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"NativeScripts\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NetworkId\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"NetworkId\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NetworkInfo\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"NetworkInfo\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NewConstitutionProposal\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"NewConstitutionProposal\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NoConfidenceProposal\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"NoConfidenceProposal\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Nonce\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Nonce\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"OperationalCert\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"OperationalCert\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"OutputDatum\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"OutputDatum\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ParameterChangeProposal\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"ParameterChangeProposal\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PlutusData\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"PlutusData\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PlutusList\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"PlutusList\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PlutusMap\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"PlutusMap\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PlutusScript\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"PlutusScript\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PlutusScriptSource\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"PlutusScriptSource\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PlutusScripts\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"PlutusScripts\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PlutusWitness\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"PlutusWitness\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PlutusWitnesses\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"PlutusWitnesses\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Pointer\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Pointer\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PointerAddress\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"PointerAddress\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PoolMetadata\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"PoolMetadata\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PoolMetadataHash\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"PoolMetadataHash\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PoolParams\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"PoolParams\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PoolRegistration\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"PoolRegistration\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PoolRetirement\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"PoolRetirement\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PoolVotingThresholds\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"PoolVotingThresholds\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PrivateKey\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"PrivateKey\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ProposedProtocolParameterUpdates\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"ProposedProtocolParameterUpdates\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ProtocolParamUpdate\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"ProtocolParamUpdate\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ProtocolVersion\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"ProtocolVersion\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PublicKey\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"PublicKey\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PublicKeys\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"PublicKeys\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Redeemer\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Redeemer\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RedeemerTag\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"RedeemerTag\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Redeemers\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Redeemers\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Relay\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Relay\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Relays\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Relays\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RewardAddress\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"RewardAddress\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RewardAddresses\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"RewardAddresses\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ScriptAll\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"ScriptAll\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ScriptAny\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"ScriptAny\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ScriptDataHash\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"ScriptDataHash\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ScriptHash\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"ScriptHash\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ScriptHashes\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"ScriptHashes\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ScriptNOfK\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"ScriptNOfK\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ScriptPubkey\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"ScriptPubkey\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ScriptRef\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"ScriptRef\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SingleHostAddr\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"SingleHostAddr\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SingleHostName\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"SingleHostName\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"StakeAndVoteDelegation\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"StakeAndVoteDelegation\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"StakeDelegation\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"StakeDelegation\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"StakeDeregistration\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"StakeDeregistration\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"StakeRegistration\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"StakeRegistration\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"StakeRegistrationAndDelegation\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"StakeRegistrationAndDelegation\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"StakeVoteRegistrationAndDelegation\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"StakeVoteRegistrationAndDelegation\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Strings\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Strings\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TimelockExpiry\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TimelockExpiry\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TimelockStart\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TimelockStart\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Transaction\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Transaction\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransactionBatch\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TransactionBatch\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransactionBatchList\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TransactionBatchList\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransactionBodies\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TransactionBodies\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransactionBody\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TransactionBody\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransactionBuilder\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TransactionBuilder\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransactionBuilderConfig\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TransactionBuilderConfig\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransactionBuilderConfigBuilder\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TransactionBuilderConfigBuilder\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransactionHash\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TransactionHash\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransactionInput\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TransactionInput\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransactionInputs\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TransactionInputs\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransactionMetadatum\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TransactionMetadatum\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransactionMetadatumLabels\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TransactionMetadatumLabels\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransactionOutput\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TransactionOutput\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransactionOutputAmountBuilder\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TransactionOutputAmountBuilder\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransactionOutputBuilder\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TransactionOutputBuilder\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransactionOutputs\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TransactionOutputs\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransactionUnspentOutput\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TransactionUnspentOutput\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransactionUnspentOutputs\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TransactionUnspentOutputs\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransactionWitnessSet\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TransactionWitnessSet\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransactionWitnessSets\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TransactionWitnessSets\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TreasuryWithdrawals\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TreasuryWithdrawals\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TreasuryWithdrawalsProposal\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TreasuryWithdrawalsProposal\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TxBuilderConstants\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TxBuilderConstants\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TxInputsBuilder\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TxInputsBuilder\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"URL\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"URL\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"UnitInterval\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"UnitInterval\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Update\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Update\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"UpdateCommitteeProposal\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"UpdateCommitteeProposal\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VRFCert\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"VRFCert\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VRFKeyHash\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"VRFKeyHash\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VRFVKey\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"VRFVKey\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Value\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Value\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Vkey\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Vkey\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Vkeys\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Vkeys\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Vkeywitness\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Vkeywitness\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Vkeywitnesses\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Vkeywitnesses\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VoteDelegation\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"VoteDelegation\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VoteRegistrationAndDelegation\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"VoteRegistrationAndDelegation\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Voter\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Voter\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Voters\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Voters\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VotingBuilder\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"VotingBuilder\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VotingProcedure\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"VotingProcedure\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VotingProcedures\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"VotingProcedures\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VotingProposal\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"VotingProposal\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VotingProposalBuilder\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"VotingProposalBuilder\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VotingProposals\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"VotingProposals\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Withdrawals\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Withdrawals\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"WithdrawalsBuilder\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"WithdrawalsBuilder\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_string_new\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_string_new\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_object_drop_ref\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_object_drop_ref\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_string_get\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_string_get\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_error_new\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_error_new\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_number_new\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_number_new\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_object_clone_ref\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_object_clone_ref\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_is_object\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_is_object\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_set_20cbc34131e76824\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_set_20cbc34131e76824\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_String_91fba7ded13ba54c\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_String_91fba7ded13ba54c\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_randomFillSync_dc1e9a60c158336d\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_randomFillSync_dc1e9a60c158336d\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getRandomValues_37fa2ca9e4e07fab\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_getRandomValues_37fa2ca9e4e07fab\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_crypto_c48a774b022d20ac\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_crypto_c48a774b022d20ac\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_process_298734cf255a885d\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_process_298734cf255a885d\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_versions_e2e78e134e3e5d01\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_versions_e2e78e134e3e5d01\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_node_1cd7a5d853dbea79\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_node_1cd7a5d853dbea79\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_is_string\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_is_string\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_require_8f08ceecec0f4fee\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_require_8f08ceecec0f4fee\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_msCrypto_bcb970640f50a1e8\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_msCrypto_bcb970640f50a1e8\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_new_1d9a920c6bfc44a8\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_new_1d9a920c6bfc44a8\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_is_function\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_is_function\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_newnoargs_b5b063fc6c2f0376\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_newnoargs_b5b063fc6c2f0376\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_new_268f7b7dd3430798\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_new_268f7b7dd3430798\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_call_97ae9d8645dc388b\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_call_97ae9d8645dc388b\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_new_0b9bfdd97583284e\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_new_0b9bfdd97583284e\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_self_6d479506f72c6a71\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_self_6d479506f72c6a71\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_window_f2557cc78490aceb\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_window_f2557cc78490aceb\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_globalThis_7f206bda628d5286\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_globalThis_7f206bda628d5286\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_global_ba75c50d1cf384f4\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_global_ba75c50d1cf384f4\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_is_undefined\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_is_undefined\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_set_a68214f35c417fa9\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_set_a68214f35c417fa9\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_call_168da88779e35f61\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_call_168da88779e35f61\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_set_933729cf5b66ac11\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_set_933729cf5b66ac11\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_buffer_3f3d764d4747d564\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_buffer_3f3d764d4747d564\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_newwithbyteoffsetandlength_d9aa266703cb98be\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_newwithbyteoffsetandlength_d9aa266703cb98be\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_new_8c3f0052272a457a\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_new_8c3f0052272a457a\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_set_83db9690f9353e79\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_set_83db9690f9353e79\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_newwithlength_f5933855e4f48a19\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_newwithlength_f5933855e4f48a19\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_subarray_58ad4efbb5bcb886\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_subarray_58ad4efbb5bcb886\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_new_d87f272aec784ec0\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_new_d87f272aec784ec0\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_call_eae29933372a39be\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_call_eae29933372a39be\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_jsval_eq\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_jsval_eq\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_self_e0b3266d2d9eba1a\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_self_e0b3266d2d9eba1a\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_crypto_e95a6e54c5c2e37f\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_crypto_e95a6e54c5c2e37f\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getRandomValues_dc67302a7bd1aec5\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_getRandomValues_dc67302a7bd1aec5\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_require_0993fe224bf8e202\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_require_0993fe224bf8e202\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_randomFillSync_dd2297de5917c74e\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_randomFillSync_dd2297de5917c74e\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getRandomValues_02639197c8166a96\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_getRandomValues_02639197c8166a96\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_debug_string\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_debug_string\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_throw\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_throw\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_memory\", function() { return _cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_memory\"]; });\n\n\n\nObject(_cardano_serialization_lib_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_set_wasm\"])(_cardano_serialization_lib_bg_wasm__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n//# sourceURL=webpack:///./node_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib.js?");

/***/ }),

/***/ "./node_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib_bg.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib_bg.js ***!
  \************************************************************************************************/
/*! exports provided: __wbg_set_wasm, create_send_all, min_fee, calculate_ex_units_ceil_cost, min_script_fee, encrypt_with_password, decrypt_with_password, make_daedalus_bootstrap_witness, make_icarus_bootstrap_witness, make_vkey_witness, hash_auxiliary_data, hash_transaction, hash_plutus_data, hash_script_data, get_implicit_input, get_deposit, min_ada_for_output, min_ada_required, encode_json_str_to_native_script, encode_json_str_to_plutus_datum, decode_plutus_datum_to_json_str, encode_arbitrary_bytes_as_metadatum, decode_arbitrary_bytes_from_metadatum, encode_json_str_to_metadatum, decode_metadatum_to_json_str, VoterKind, CborContainerType, CredKind, DRepKind, ScriptSchema, RelayKind, NativeScriptKind, ScriptHashNamespace, NetworkIdKind, VoteKind, CertificateKind, VotingProposalKind, LanguageKind, PlutusDataKind, RedeemerTagKind, PlutusDatumSchema, TransactionMetadatumKind, MetadataJsonSchema, CoinSelectionStrategyCIP2, MIRPot, MIRKind, Address, Anchor, AnchorDataHash, AssetName, AssetNames, Assets, AuxiliaryData, AuxiliaryDataHash, AuxiliaryDataSet, BaseAddress, BigInt, BigNum, Bip32PrivateKey, Bip32PublicKey, Block, BlockHash, BootstrapWitness, BootstrapWitnesses, ByronAddress, Certificate, Certificates, CertificatesBuilder, Committee, CommitteeColdResign, CommitteeHotAuth, Constitution, ConstrPlutusData, CostModel, Costmdls, Credential, Credentials, DNSRecordAorAAAA, DNSRecordSRV, DRep, DataCost, DataHash, DatumSource, DrepDeregistration, DrepRegistration, DrepUpdate, DrepVotingThresholds, Ed25519KeyHash, Ed25519KeyHashes, Ed25519Signature, EnterpriseAddress, ExUnitPrices, ExUnits, FixedTransaction, GeneralTransactionMetadata, GenesisDelegateHash, GenesisHash, GenesisHashes, GenesisKeyDelegation, GovernanceActionId, GovernanceActionIds, HardForkInitiationProposal, Header, HeaderBody, InfoProposal, InputWithScriptWitness, InputsWithScriptWitness, Int, Ipv4, Ipv6, KESSignature, KESVKey, Language, Languages, LegacyDaedalusPrivateKey, LinearFee, MIRToStakeCredentials, MetadataList, MetadataMap, Mint, MintAssets, MintBuilder, MintWitness, MintsAssets, MoveInstantaneousReward, MoveInstantaneousRewardsCert, MultiAsset, MultiHostName, NativeScript, NativeScriptSource, NativeScripts, NetworkId, NetworkInfo, NewConstitutionProposal, NoConfidenceProposal, Nonce, OperationalCert, OutputDatum, ParameterChangeProposal, PlutusData, PlutusList, PlutusMap, PlutusScript, PlutusScriptSource, PlutusScripts, PlutusWitness, PlutusWitnesses, Pointer, PointerAddress, PoolMetadata, PoolMetadataHash, PoolParams, PoolRegistration, PoolRetirement, PoolVotingThresholds, PrivateKey, ProposedProtocolParameterUpdates, ProtocolParamUpdate, ProtocolVersion, PublicKey, PublicKeys, Redeemer, RedeemerTag, Redeemers, Relay, Relays, RewardAddress, RewardAddresses, ScriptAll, ScriptAny, ScriptDataHash, ScriptHash, ScriptHashes, ScriptNOfK, ScriptPubkey, ScriptRef, SingleHostAddr, SingleHostName, StakeAndVoteDelegation, StakeDelegation, StakeDeregistration, StakeRegistration, StakeRegistrationAndDelegation, StakeVoteRegistrationAndDelegation, Strings, TimelockExpiry, TimelockStart, Transaction, TransactionBatch, TransactionBatchList, TransactionBodies, TransactionBody, TransactionBuilder, TransactionBuilderConfig, TransactionBuilderConfigBuilder, TransactionHash, TransactionInput, TransactionInputs, TransactionMetadatum, TransactionMetadatumLabels, TransactionOutput, TransactionOutputAmountBuilder, TransactionOutputBuilder, TransactionOutputs, TransactionUnspentOutput, TransactionUnspentOutputs, TransactionWitnessSet, TransactionWitnessSets, TreasuryWithdrawals, TreasuryWithdrawalsProposal, TxBuilderConstants, TxInputsBuilder, URL, UnitInterval, Update, UpdateCommitteeProposal, VRFCert, VRFKeyHash, VRFVKey, Value, Vkey, Vkeys, Vkeywitness, Vkeywitnesses, VoteDelegation, VoteRegistrationAndDelegation, Voter, Voters, VotingBuilder, VotingProcedure, VotingProcedures, VotingProposal, VotingProposalBuilder, VotingProposals, Withdrawals, WithdrawalsBuilder, __wbindgen_string_new, __wbindgen_object_drop_ref, __wbindgen_string_get, __wbindgen_error_new, __wbindgen_number_new, __wbindgen_object_clone_ref, __wbindgen_is_object, __wbg_set_20cbc34131e76824, __wbg_String_91fba7ded13ba54c, __wbg_randomFillSync_dc1e9a60c158336d, __wbg_getRandomValues_37fa2ca9e4e07fab, __wbg_crypto_c48a774b022d20ac, __wbg_process_298734cf255a885d, __wbg_versions_e2e78e134e3e5d01, __wbg_node_1cd7a5d853dbea79, __wbindgen_is_string, __wbg_require_8f08ceecec0f4fee, __wbg_msCrypto_bcb970640f50a1e8, __wbg_new_1d9a920c6bfc44a8, __wbindgen_is_function, __wbg_newnoargs_b5b063fc6c2f0376, __wbg_new_268f7b7dd3430798, __wbg_call_97ae9d8645dc388b, __wbg_new_0b9bfdd97583284e, __wbg_self_6d479506f72c6a71, __wbg_window_f2557cc78490aceb, __wbg_globalThis_7f206bda628d5286, __wbg_global_ba75c50d1cf384f4, __wbindgen_is_undefined, __wbg_set_a68214f35c417fa9, __wbg_call_168da88779e35f61, __wbg_set_933729cf5b66ac11, __wbg_buffer_3f3d764d4747d564, __wbg_newwithbyteoffsetandlength_d9aa266703cb98be, __wbg_new_8c3f0052272a457a, __wbg_set_83db9690f9353e79, __wbg_newwithlength_f5933855e4f48a19, __wbg_subarray_58ad4efbb5bcb886, __wbg_new_d87f272aec784ec0, __wbg_call_eae29933372a39be, __wbindgen_jsval_eq, __wbg_self_e0b3266d2d9eba1a, __wbg_crypto_e95a6e54c5c2e37f, __wbg_getRandomValues_dc67302a7bd1aec5, __wbg_require_0993fe224bf8e202, __wbg_randomFillSync_dd2297de5917c74e, __wbg_getRandomValues_02639197c8166a96, __wbindgen_debug_string, __wbindgen_throw, __wbindgen_memory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module, global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_set_wasm\", function() { return __wbg_set_wasm; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create_send_all\", function() { return create_send_all; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"min_fee\", function() { return min_fee; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"calculate_ex_units_ceil_cost\", function() { return calculate_ex_units_ceil_cost; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"min_script_fee\", function() { return min_script_fee; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"encrypt_with_password\", function() { return encrypt_with_password; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"decrypt_with_password\", function() { return decrypt_with_password; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"make_daedalus_bootstrap_witness\", function() { return make_daedalus_bootstrap_witness; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"make_icarus_bootstrap_witness\", function() { return make_icarus_bootstrap_witness; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"make_vkey_witness\", function() { return make_vkey_witness; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hash_auxiliary_data\", function() { return hash_auxiliary_data; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hash_transaction\", function() { return hash_transaction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hash_plutus_data\", function() { return hash_plutus_data; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hash_script_data\", function() { return hash_script_data; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"get_implicit_input\", function() { return get_implicit_input; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"get_deposit\", function() { return get_deposit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"min_ada_for_output\", function() { return min_ada_for_output; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"min_ada_required\", function() { return min_ada_required; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"encode_json_str_to_native_script\", function() { return encode_json_str_to_native_script; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"encode_json_str_to_plutus_datum\", function() { return encode_json_str_to_plutus_datum; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"decode_plutus_datum_to_json_str\", function() { return decode_plutus_datum_to_json_str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"encode_arbitrary_bytes_as_metadatum\", function() { return encode_arbitrary_bytes_as_metadatum; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"decode_arbitrary_bytes_from_metadatum\", function() { return decode_arbitrary_bytes_from_metadatum; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"encode_json_str_to_metadatum\", function() { return encode_json_str_to_metadatum; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"decode_metadatum_to_json_str\", function() { return decode_metadatum_to_json_str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VoterKind\", function() { return VoterKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CborContainerType\", function() { return CborContainerType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CredKind\", function() { return CredKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DRepKind\", function() { return DRepKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScriptSchema\", function() { return ScriptSchema; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RelayKind\", function() { return RelayKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NativeScriptKind\", function() { return NativeScriptKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScriptHashNamespace\", function() { return ScriptHashNamespace; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NetworkIdKind\", function() { return NetworkIdKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VoteKind\", function() { return VoteKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CertificateKind\", function() { return CertificateKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VotingProposalKind\", function() { return VotingProposalKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LanguageKind\", function() { return LanguageKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlutusDataKind\", function() { return PlutusDataKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RedeemerTagKind\", function() { return RedeemerTagKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlutusDatumSchema\", function() { return PlutusDatumSchema; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransactionMetadatumKind\", function() { return TransactionMetadatumKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MetadataJsonSchema\", function() { return MetadataJsonSchema; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CoinSelectionStrategyCIP2\", function() { return CoinSelectionStrategyCIP2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MIRPot\", function() { return MIRPot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MIRKind\", function() { return MIRKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Address\", function() { return Address; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Anchor\", function() { return Anchor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnchorDataHash\", function() { return AnchorDataHash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AssetName\", function() { return AssetName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AssetNames\", function() { return AssetNames; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Assets\", function() { return Assets; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AuxiliaryData\", function() { return AuxiliaryData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AuxiliaryDataHash\", function() { return AuxiliaryDataHash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AuxiliaryDataSet\", function() { return AuxiliaryDataSet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BaseAddress\", function() { return BaseAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BigInt\", function() { return BigInt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BigNum\", function() { return BigNum; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Bip32PrivateKey\", function() { return Bip32PrivateKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Bip32PublicKey\", function() { return Bip32PublicKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Block\", function() { return Block; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BlockHash\", function() { return BlockHash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BootstrapWitness\", function() { return BootstrapWitness; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BootstrapWitnesses\", function() { return BootstrapWitnesses; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ByronAddress\", function() { return ByronAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Certificate\", function() { return Certificate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Certificates\", function() { return Certificates; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CertificatesBuilder\", function() { return CertificatesBuilder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Committee\", function() { return Committee; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CommitteeColdResign\", function() { return CommitteeColdResign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CommitteeHotAuth\", function() { return CommitteeHotAuth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Constitution\", function() { return Constitution; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConstrPlutusData\", function() { return ConstrPlutusData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CostModel\", function() { return CostModel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Costmdls\", function() { return Costmdls; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Credential\", function() { return Credential; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Credentials\", function() { return Credentials; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DNSRecordAorAAAA\", function() { return DNSRecordAorAAAA; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DNSRecordSRV\", function() { return DNSRecordSRV; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DRep\", function() { return DRep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataCost\", function() { return DataCost; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataHash\", function() { return DataHash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DatumSource\", function() { return DatumSource; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DrepDeregistration\", function() { return DrepDeregistration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DrepRegistration\", function() { return DrepRegistration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DrepUpdate\", function() { return DrepUpdate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DrepVotingThresholds\", function() { return DrepVotingThresholds; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Ed25519KeyHash\", function() { return Ed25519KeyHash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Ed25519KeyHashes\", function() { return Ed25519KeyHashes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Ed25519Signature\", function() { return Ed25519Signature; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EnterpriseAddress\", function() { return EnterpriseAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExUnitPrices\", function() { return ExUnitPrices; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExUnits\", function() { return ExUnits; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FixedTransaction\", function() { return FixedTransaction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeneralTransactionMetadata\", function() { return GeneralTransactionMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GenesisDelegateHash\", function() { return GenesisDelegateHash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GenesisHash\", function() { return GenesisHash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GenesisHashes\", function() { return GenesisHashes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GenesisKeyDelegation\", function() { return GenesisKeyDelegation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GovernanceActionId\", function() { return GovernanceActionId; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GovernanceActionIds\", function() { return GovernanceActionIds; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HardForkInitiationProposal\", function() { return HardForkInitiationProposal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Header\", function() { return Header; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HeaderBody\", function() { return HeaderBody; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InfoProposal\", function() { return InfoProposal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InputWithScriptWitness\", function() { return InputWithScriptWitness; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InputsWithScriptWitness\", function() { return InputsWithScriptWitness; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Int\", function() { return Int; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Ipv4\", function() { return Ipv4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Ipv6\", function() { return Ipv6; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KESSignature\", function() { return KESSignature; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KESVKey\", function() { return KESVKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Language\", function() { return Language; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Languages\", function() { return Languages; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LegacyDaedalusPrivateKey\", function() { return LegacyDaedalusPrivateKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearFee\", function() { return LinearFee; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MIRToStakeCredentials\", function() { return MIRToStakeCredentials; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MetadataList\", function() { return MetadataList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MetadataMap\", function() { return MetadataMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Mint\", function() { return Mint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MintAssets\", function() { return MintAssets; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MintBuilder\", function() { return MintBuilder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MintWitness\", function() { return MintWitness; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MintsAssets\", function() { return MintsAssets; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MoveInstantaneousReward\", function() { return MoveInstantaneousReward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MoveInstantaneousRewardsCert\", function() { return MoveInstantaneousRewardsCert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MultiAsset\", function() { return MultiAsset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MultiHostName\", function() { return MultiHostName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NativeScript\", function() { return NativeScript; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NativeScriptSource\", function() { return NativeScriptSource; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NativeScripts\", function() { return NativeScripts; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NetworkId\", function() { return NetworkId; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NetworkInfo\", function() { return NetworkInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NewConstitutionProposal\", function() { return NewConstitutionProposal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoConfidenceProposal\", function() { return NoConfidenceProposal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Nonce\", function() { return Nonce; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OperationalCert\", function() { return OperationalCert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OutputDatum\", function() { return OutputDatum; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParameterChangeProposal\", function() { return ParameterChangeProposal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlutusData\", function() { return PlutusData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlutusList\", function() { return PlutusList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlutusMap\", function() { return PlutusMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlutusScript\", function() { return PlutusScript; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlutusScriptSource\", function() { return PlutusScriptSource; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlutusScripts\", function() { return PlutusScripts; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlutusWitness\", function() { return PlutusWitness; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlutusWitnesses\", function() { return PlutusWitnesses; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Pointer\", function() { return Pointer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PointerAddress\", function() { return PointerAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PoolMetadata\", function() { return PoolMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PoolMetadataHash\", function() { return PoolMetadataHash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PoolParams\", function() { return PoolParams; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PoolRegistration\", function() { return PoolRegistration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PoolRetirement\", function() { return PoolRetirement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PoolVotingThresholds\", function() { return PoolVotingThresholds; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PrivateKey\", function() { return PrivateKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ProposedProtocolParameterUpdates\", function() { return ProposedProtocolParameterUpdates; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ProtocolParamUpdate\", function() { return ProtocolParamUpdate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ProtocolVersion\", function() { return ProtocolVersion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PublicKey\", function() { return PublicKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PublicKeys\", function() { return PublicKeys; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Redeemer\", function() { return Redeemer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RedeemerTag\", function() { return RedeemerTag; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Redeemers\", function() { return Redeemers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Relay\", function() { return Relay; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Relays\", function() { return Relays; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RewardAddress\", function() { return RewardAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RewardAddresses\", function() { return RewardAddresses; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScriptAll\", function() { return ScriptAll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScriptAny\", function() { return ScriptAny; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScriptDataHash\", function() { return ScriptDataHash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScriptHash\", function() { return ScriptHash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScriptHashes\", function() { return ScriptHashes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScriptNOfK\", function() { return ScriptNOfK; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScriptPubkey\", function() { return ScriptPubkey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScriptRef\", function() { return ScriptRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SingleHostAddr\", function() { return SingleHostAddr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SingleHostName\", function() { return SingleHostName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StakeAndVoteDelegation\", function() { return StakeAndVoteDelegation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StakeDelegation\", function() { return StakeDelegation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StakeDeregistration\", function() { return StakeDeregistration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StakeRegistration\", function() { return StakeRegistration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StakeRegistrationAndDelegation\", function() { return StakeRegistrationAndDelegation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StakeVoteRegistrationAndDelegation\", function() { return StakeVoteRegistrationAndDelegation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Strings\", function() { return Strings; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TimelockExpiry\", function() { return TimelockExpiry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TimelockStart\", function() { return TimelockStart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Transaction\", function() { return Transaction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransactionBatch\", function() { return TransactionBatch; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransactionBatchList\", function() { return TransactionBatchList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransactionBodies\", function() { return TransactionBodies; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransactionBody\", function() { return TransactionBody; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransactionBuilder\", function() { return TransactionBuilder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransactionBuilderConfig\", function() { return TransactionBuilderConfig; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransactionBuilderConfigBuilder\", function() { return TransactionBuilderConfigBuilder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransactionHash\", function() { return TransactionHash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransactionInput\", function() { return TransactionInput; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransactionInputs\", function() { return TransactionInputs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransactionMetadatum\", function() { return TransactionMetadatum; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransactionMetadatumLabels\", function() { return TransactionMetadatumLabels; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransactionOutput\", function() { return TransactionOutput; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransactionOutputAmountBuilder\", function() { return TransactionOutputAmountBuilder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransactionOutputBuilder\", function() { return TransactionOutputBuilder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransactionOutputs\", function() { return TransactionOutputs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransactionUnspentOutput\", function() { return TransactionUnspentOutput; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransactionUnspentOutputs\", function() { return TransactionUnspentOutputs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransactionWitnessSet\", function() { return TransactionWitnessSet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransactionWitnessSets\", function() { return TransactionWitnessSets; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TreasuryWithdrawals\", function() { return TreasuryWithdrawals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TreasuryWithdrawalsProposal\", function() { return TreasuryWithdrawalsProposal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TxBuilderConstants\", function() { return TxBuilderConstants; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TxInputsBuilder\", function() { return TxInputsBuilder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"URL\", function() { return URL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnitInterval\", function() { return UnitInterval; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Update\", function() { return Update; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UpdateCommitteeProposal\", function() { return UpdateCommitteeProposal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VRFCert\", function() { return VRFCert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VRFKeyHash\", function() { return VRFKeyHash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VRFVKey\", function() { return VRFVKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Value\", function() { return Value; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vkey\", function() { return Vkey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vkeys\", function() { return Vkeys; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vkeywitness\", function() { return Vkeywitness; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vkeywitnesses\", function() { return Vkeywitnesses; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VoteDelegation\", function() { return VoteDelegation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VoteRegistrationAndDelegation\", function() { return VoteRegistrationAndDelegation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Voter\", function() { return Voter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Voters\", function() { return Voters; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VotingBuilder\", function() { return VotingBuilder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VotingProcedure\", function() { return VotingProcedure; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VotingProcedures\", function() { return VotingProcedures; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VotingProposal\", function() { return VotingProposal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VotingProposalBuilder\", function() { return VotingProposalBuilder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VotingProposals\", function() { return VotingProposals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Withdrawals\", function() { return Withdrawals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WithdrawalsBuilder\", function() { return WithdrawalsBuilder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_string_new\", function() { return __wbindgen_string_new; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_object_drop_ref\", function() { return __wbindgen_object_drop_ref; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_string_get\", function() { return __wbindgen_string_get; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_error_new\", function() { return __wbindgen_error_new; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_number_new\", function() { return __wbindgen_number_new; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_object_clone_ref\", function() { return __wbindgen_object_clone_ref; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_is_object\", function() { return __wbindgen_is_object; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_set_20cbc34131e76824\", function() { return __wbg_set_20cbc34131e76824; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_String_91fba7ded13ba54c\", function() { return __wbg_String_91fba7ded13ba54c; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_randomFillSync_dc1e9a60c158336d\", function() { return __wbg_randomFillSync_dc1e9a60c158336d; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getRandomValues_37fa2ca9e4e07fab\", function() { return __wbg_getRandomValues_37fa2ca9e4e07fab; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_crypto_c48a774b022d20ac\", function() { return __wbg_crypto_c48a774b022d20ac; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_process_298734cf255a885d\", function() { return __wbg_process_298734cf255a885d; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_versions_e2e78e134e3e5d01\", function() { return __wbg_versions_e2e78e134e3e5d01; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_node_1cd7a5d853dbea79\", function() { return __wbg_node_1cd7a5d853dbea79; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_is_string\", function() { return __wbindgen_is_string; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_require_8f08ceecec0f4fee\", function() { return __wbg_require_8f08ceecec0f4fee; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_msCrypto_bcb970640f50a1e8\", function() { return __wbg_msCrypto_bcb970640f50a1e8; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_new_1d9a920c6bfc44a8\", function() { return __wbg_new_1d9a920c6bfc44a8; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_is_function\", function() { return __wbindgen_is_function; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_newnoargs_b5b063fc6c2f0376\", function() { return __wbg_newnoargs_b5b063fc6c2f0376; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_new_268f7b7dd3430798\", function() { return __wbg_new_268f7b7dd3430798; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_call_97ae9d8645dc388b\", function() { return __wbg_call_97ae9d8645dc388b; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_new_0b9bfdd97583284e\", function() { return __wbg_new_0b9bfdd97583284e; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_self_6d479506f72c6a71\", function() { return __wbg_self_6d479506f72c6a71; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_window_f2557cc78490aceb\", function() { return __wbg_window_f2557cc78490aceb; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_globalThis_7f206bda628d5286\", function() { return __wbg_globalThis_7f206bda628d5286; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_global_ba75c50d1cf384f4\", function() { return __wbg_global_ba75c50d1cf384f4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_is_undefined\", function() { return __wbindgen_is_undefined; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_set_a68214f35c417fa9\", function() { return __wbg_set_a68214f35c417fa9; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_call_168da88779e35f61\", function() { return __wbg_call_168da88779e35f61; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_set_933729cf5b66ac11\", function() { return __wbg_set_933729cf5b66ac11; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_buffer_3f3d764d4747d564\", function() { return __wbg_buffer_3f3d764d4747d564; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_newwithbyteoffsetandlength_d9aa266703cb98be\", function() { return __wbg_newwithbyteoffsetandlength_d9aa266703cb98be; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_new_8c3f0052272a457a\", function() { return __wbg_new_8c3f0052272a457a; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_set_83db9690f9353e79\", function() { return __wbg_set_83db9690f9353e79; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_newwithlength_f5933855e4f48a19\", function() { return __wbg_newwithlength_f5933855e4f48a19; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_subarray_58ad4efbb5bcb886\", function() { return __wbg_subarray_58ad4efbb5bcb886; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_new_d87f272aec784ec0\", function() { return __wbg_new_d87f272aec784ec0; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_call_eae29933372a39be\", function() { return __wbg_call_eae29933372a39be; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_jsval_eq\", function() { return __wbindgen_jsval_eq; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_self_e0b3266d2d9eba1a\", function() { return __wbg_self_e0b3266d2d9eba1a; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_crypto_e95a6e54c5c2e37f\", function() { return __wbg_crypto_e95a6e54c5c2e37f; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getRandomValues_dc67302a7bd1aec5\", function() { return __wbg_getRandomValues_dc67302a7bd1aec5; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_require_0993fe224bf8e202\", function() { return __wbg_require_0993fe224bf8e202; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_randomFillSync_dd2297de5917c74e\", function() { return __wbg_randomFillSync_dd2297de5917c74e; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getRandomValues_02639197c8166a96\", function() { return __wbg_getRandomValues_02639197c8166a96; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_debug_string\", function() { return __wbindgen_debug_string; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_throw\", function() { return __wbindgen_throw; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_memory\", function() { return __wbindgen_memory; });\nlet wasm;\nfunction __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n* @param {Address} address\n* @param {TransactionUnspentOutputs} utxos\n* @param {TransactionBuilderConfig} config\n* @returns {TransactionBatchList}\n*/\nfunction create_send_all(address, utxos, config) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(address, Address);\n        _assertClass(utxos, TransactionUnspentOutputs);\n        _assertClass(config, TransactionBuilderConfig);\n        wasm.create_send_all(retptr, address.__wbg_ptr, utxos.__wbg_ptr, config.__wbg_ptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return TransactionBatchList.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {Transaction} tx\n* @param {LinearFee} linear_fee\n* @returns {BigNum}\n*/\nfunction min_fee(tx, linear_fee) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(tx, Transaction);\n        _assertClass(linear_fee, LinearFee);\n        wasm.min_fee(retptr, tx.__wbg_ptr, linear_fee.__wbg_ptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return BigNum.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {ExUnits} ex_units\n* @param {ExUnitPrices} ex_unit_prices\n* @returns {BigNum}\n*/\nfunction calculate_ex_units_ceil_cost(ex_units, ex_unit_prices) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(ex_units, ExUnits);\n        _assertClass(ex_unit_prices, ExUnitPrices);\n        wasm.calculate_ex_units_ceil_cost(retptr, ex_units.__wbg_ptr, ex_unit_prices.__wbg_ptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return BigNum.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {Transaction} tx\n* @param {ExUnitPrices} ex_unit_prices\n* @returns {BigNum}\n*/\nfunction min_script_fee(tx, ex_unit_prices) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(tx, Transaction);\n        _assertClass(ex_unit_prices, ExUnitPrices);\n        wasm.min_script_fee(retptr, tx.__wbg_ptr, ex_unit_prices.__wbg_ptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return BigNum.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} password\n* @param {string} salt\n* @param {string} nonce\n* @param {string} data\n* @returns {string}\n*/\nfunction encrypt_with_password(password, salt, nonce, data) {\n    let deferred6_0;\n    let deferred6_1;\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(password, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(salt, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(nonce, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len2 = WASM_VECTOR_LEN;\n        const ptr3 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len3 = WASM_VECTOR_LEN;\n        wasm.encrypt_with_password(retptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr5 = r0;\n        var len5 = r1;\n        if (r3) {\n            ptr5 = 0; len5 = 0;\n            throw takeObject(r2);\n        }\n        deferred6_0 = ptr5;\n        deferred6_1 = len5;\n        return getStringFromWasm0(ptr5, len5);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(deferred6_0, deferred6_1, 1);\n    }\n}\n\n/**\n* @param {string} password\n* @param {string} data\n* @returns {string}\n*/\nfunction decrypt_with_password(password, data) {\n    let deferred4_0;\n    let deferred4_1;\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(password, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.decrypt_with_password(retptr, ptr0, len0, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr3 = r0;\n        var len3 = r1;\n        if (r3) {\n            ptr3 = 0; len3 = 0;\n            throw takeObject(r2);\n        }\n        deferred4_0 = ptr3;\n        deferred4_1 = len3;\n        return getStringFromWasm0(ptr3, len3);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(deferred4_0, deferred4_1, 1);\n    }\n}\n\n/**\n* @param {TransactionHash} tx_body_hash\n* @param {ByronAddress} addr\n* @param {LegacyDaedalusPrivateKey} key\n* @returns {BootstrapWitness}\n*/\nfunction make_daedalus_bootstrap_witness(tx_body_hash, addr, key) {\n    _assertClass(tx_body_hash, TransactionHash);\n    _assertClass(addr, ByronAddress);\n    _assertClass(key, LegacyDaedalusPrivateKey);\n    const ret = wasm.make_daedalus_bootstrap_witness(tx_body_hash.__wbg_ptr, addr.__wbg_ptr, key.__wbg_ptr);\n    return BootstrapWitness.__wrap(ret);\n}\n\n/**\n* @param {TransactionHash} tx_body_hash\n* @param {ByronAddress} addr\n* @param {Bip32PrivateKey} key\n* @returns {BootstrapWitness}\n*/\nfunction make_icarus_bootstrap_witness(tx_body_hash, addr, key) {\n    _assertClass(tx_body_hash, TransactionHash);\n    _assertClass(addr, ByronAddress);\n    _assertClass(key, Bip32PrivateKey);\n    const ret = wasm.make_icarus_bootstrap_witness(tx_body_hash.__wbg_ptr, addr.__wbg_ptr, key.__wbg_ptr);\n    return BootstrapWitness.__wrap(ret);\n}\n\n/**\n* @param {TransactionHash} tx_body_hash\n* @param {PrivateKey} sk\n* @returns {Vkeywitness}\n*/\nfunction make_vkey_witness(tx_body_hash, sk) {\n    _assertClass(tx_body_hash, TransactionHash);\n    _assertClass(sk, PrivateKey);\n    const ret = wasm.make_vkey_witness(tx_body_hash.__wbg_ptr, sk.__wbg_ptr);\n    return Vkeywitness.__wrap(ret);\n}\n\n/**\n* @param {AuxiliaryData} auxiliary_data\n* @returns {AuxiliaryDataHash}\n*/\nfunction hash_auxiliary_data(auxiliary_data) {\n    _assertClass(auxiliary_data, AuxiliaryData);\n    const ret = wasm.hash_auxiliary_data(auxiliary_data.__wbg_ptr);\n    return AuxiliaryDataHash.__wrap(ret);\n}\n\n/**\n* @param {TransactionBody} tx_body\n* @returns {TransactionHash}\n*/\nfunction hash_transaction(tx_body) {\n    _assertClass(tx_body, TransactionBody);\n    const ret = wasm.hash_transaction(tx_body.__wbg_ptr);\n    return TransactionHash.__wrap(ret);\n}\n\n/**\n* @param {PlutusData} plutus_data\n* @returns {DataHash}\n*/\nfunction hash_plutus_data(plutus_data) {\n    _assertClass(plutus_data, PlutusData);\n    const ret = wasm.hash_plutus_data(plutus_data.__wbg_ptr);\n    return DataHash.__wrap(ret);\n}\n\n/**\n* @param {Redeemers} redeemers\n* @param {Costmdls} cost_models\n* @param {PlutusList | undefined} datums\n* @returns {ScriptDataHash}\n*/\nfunction hash_script_data(redeemers, cost_models, datums) {\n    _assertClass(redeemers, Redeemers);\n    _assertClass(cost_models, Costmdls);\n    let ptr0 = 0;\n    if (!isLikeNone(datums)) {\n        _assertClass(datums, PlutusList);\n        ptr0 = datums.__destroy_into_raw();\n    }\n    const ret = wasm.hash_script_data(redeemers.__wbg_ptr, cost_models.__wbg_ptr, ptr0);\n    return ScriptDataHash.__wrap(ret);\n}\n\n/**\n* @param {TransactionBody} txbody\n* @param {BigNum} pool_deposit\n* @param {BigNum} key_deposit\n* @returns {Value}\n*/\nfunction get_implicit_input(txbody, pool_deposit, key_deposit) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(txbody, TransactionBody);\n        _assertClass(pool_deposit, BigNum);\n        _assertClass(key_deposit, BigNum);\n        wasm.get_implicit_input(retptr, txbody.__wbg_ptr, pool_deposit.__wbg_ptr, key_deposit.__wbg_ptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return Value.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {TransactionBody} txbody\n* @param {BigNum} pool_deposit\n* @param {BigNum} key_deposit\n* @returns {BigNum}\n*/\nfunction get_deposit(txbody, pool_deposit, key_deposit) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(txbody, TransactionBody);\n        _assertClass(pool_deposit, BigNum);\n        _assertClass(key_deposit, BigNum);\n        wasm.get_deposit(retptr, txbody.__wbg_ptr, pool_deposit.__wbg_ptr, key_deposit.__wbg_ptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return BigNum.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n*returns minimal amount of ada for the output for case when the amount is included to the output\n* @param {TransactionOutput} output\n* @param {DataCost} data_cost\n* @returns {BigNum}\n*/\nfunction min_ada_for_output(output, data_cost) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(output, TransactionOutput);\n        _assertClass(data_cost, DataCost);\n        wasm.min_ada_for_output(retptr, output.__wbg_ptr, data_cost.__wbg_ptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return BigNum.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* !!! DEPRECATED !!!\n* This function uses outdated set of arguments.\n* Use `min_ada_for_output` instead\n* @param {Value} assets\n* @param {boolean} has_data_hash\n* @param {BigNum} coins_per_utxo_word\n* @returns {BigNum}\n*/\nfunction min_ada_required(assets, has_data_hash, coins_per_utxo_word) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(assets, Value);\n        _assertClass(coins_per_utxo_word, BigNum);\n        wasm.min_ada_required(retptr, assets.__wbg_ptr, has_data_hash, coins_per_utxo_word.__wbg_ptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return BigNum.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* Receives a script JSON string\n* and returns a NativeScript.\n* Cardano Wallet and Node styles are supported.\n*\n* * wallet: https://github.com/input-output-hk/cardano-wallet/blob/master/specifications/api/swagger.yaml\n* * node: https://github.com/input-output-hk/cardano-node/blob/master/doc/reference/simple-scripts.md\n*\n* self_xpub is expected to be a Bip32PublicKey as hex-encoded bytes\n* @param {string} json\n* @param {string} self_xpub\n* @param {number} schema\n* @returns {NativeScript}\n*/\nfunction encode_json_str_to_native_script(json, self_xpub, schema) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(self_xpub, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.encode_json_str_to_native_script(retptr, ptr0, len0, ptr1, len1, schema);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return NativeScript.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nlet cachedUint32Memory0 = null;\n\nfunction getUint32Memory0() {\n    if (cachedUint32Memory0 === null || cachedUint32Memory0.byteLength === 0) {\n        cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n* @param {string} json\n* @param {number} schema\n* @returns {PlutusData}\n*/\nfunction encode_json_str_to_plutus_datum(json, schema) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.encode_json_str_to_plutus_datum(retptr, ptr0, len0, schema);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return PlutusData.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {PlutusData} datum\n* @param {number} schema\n* @returns {string}\n*/\nfunction decode_plutus_datum_to_json_str(datum, schema) {\n    let deferred2_0;\n    let deferred2_1;\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(datum, PlutusData);\n        wasm.decode_plutus_datum_to_json_str(retptr, datum.__wbg_ptr, schema);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr1 = r0;\n        var len1 = r1;\n        if (r3) {\n            ptr1 = 0; len1 = 0;\n            throw takeObject(r2);\n        }\n        deferred2_0 = ptr1;\n        deferred2_1 = len1;\n        return getStringFromWasm0(ptr1, len1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n    }\n}\n\n/**\n* @param {Uint8Array} bytes\n* @returns {TransactionMetadatum}\n*/\nfunction encode_arbitrary_bytes_as_metadatum(bytes) {\n    const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.encode_arbitrary_bytes_as_metadatum(ptr0, len0);\n    return TransactionMetadatum.__wrap(ret);\n}\n\n/**\n* @param {TransactionMetadatum} metadata\n* @returns {Uint8Array}\n*/\nfunction decode_arbitrary_bytes_from_metadatum(metadata) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(metadata, TransactionMetadatum);\n        wasm.decode_arbitrary_bytes_from_metadatum(retptr, metadata.__wbg_ptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        if (r3) {\n            throw takeObject(r2);\n        }\n        var v1 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1);\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} json\n* @param {number} schema\n* @returns {TransactionMetadatum}\n*/\nfunction encode_json_str_to_metadatum(json, schema) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.encode_json_str_to_metadatum(retptr, ptr0, len0, schema);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return TransactionMetadatum.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {TransactionMetadatum} metadatum\n* @param {number} schema\n* @returns {string}\n*/\nfunction decode_metadatum_to_json_str(metadatum, schema) {\n    let deferred2_0;\n    let deferred2_1;\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(metadatum, TransactionMetadatum);\n        wasm.decode_metadatum_to_json_str(retptr, metadatum.__wbg_ptr, schema);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr1 = r0;\n        var len1 = r1;\n        if (r3) {\n            ptr1 = 0; len1 = 0;\n            throw takeObject(r2);\n        }\n        deferred2_0 = ptr1;\n        deferred2_1 = len1;\n        return getStringFromWasm0(ptr1, len1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n    }\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n/**\n*/\nconst VoterKind = Object.freeze({ ConstitutionalCommitteeHotKeyHash:0,\"0\":\"ConstitutionalCommitteeHotKeyHash\",ConstitutionalCommitteeHotScriptHash:1,\"1\":\"ConstitutionalCommitteeHotScriptHash\",DRepKeyHash:2,\"2\":\"DRepKeyHash\",DRepScriptHash:3,\"3\":\"DRepScriptHash\",StakingPoolKeyHash:4,\"4\":\"StakingPoolKeyHash\", });\n/**\n*/\nconst CborContainerType = Object.freeze({ Array:0,\"0\":\"Array\",Map:1,\"1\":\"Map\", });\n/**\n*/\nconst CredKind = Object.freeze({ Key:0,\"0\":\"Key\",Script:1,\"1\":\"Script\", });\n/**\n*/\nconst DRepKind = Object.freeze({ KeyHash:0,\"0\":\"KeyHash\",ScriptHash:1,\"1\":\"ScriptHash\",AlwaysAbstain:2,\"2\":\"AlwaysAbstain\",AlwaysNoConfidence:3,\"3\":\"AlwaysNoConfidence\", });\n/**\n* Used to choosed the schema for a script JSON string\n*/\nconst ScriptSchema = Object.freeze({ Wallet:0,\"0\":\"Wallet\",Node:1,\"1\":\"Node\", });\n/**\n*/\nconst RelayKind = Object.freeze({ SingleHostAddr:0,\"0\":\"SingleHostAddr\",SingleHostName:1,\"1\":\"SingleHostName\",MultiHostName:2,\"2\":\"MultiHostName\", });\n/**\n*/\nconst NativeScriptKind = Object.freeze({ ScriptPubkey:0,\"0\":\"ScriptPubkey\",ScriptAll:1,\"1\":\"ScriptAll\",ScriptAny:2,\"2\":\"ScriptAny\",ScriptNOfK:3,\"3\":\"ScriptNOfK\",TimelockStart:4,\"4\":\"TimelockStart\",TimelockExpiry:5,\"5\":\"TimelockExpiry\", });\n/**\n* Each new language uses a different namespace for hashing its script\n* This is because you could have a language where the same bytes have different semantics\n* So this avoids scripts in different languages mapping to the same hash\n* Note that the enum value here is different than the enum value for deciding the cost model of a script\n*/\nconst ScriptHashNamespace = Object.freeze({ NativeScript:0,\"0\":\"NativeScript\",PlutusScript:1,\"1\":\"PlutusScript\",PlutusScriptV2:2,\"2\":\"PlutusScriptV2\",PlutusScriptV3:3,\"3\":\"PlutusScriptV3\", });\n/**\n*/\nconst NetworkIdKind = Object.freeze({ Testnet:0,\"0\":\"Testnet\",Mainnet:1,\"1\":\"Mainnet\", });\n/**\n*/\nconst VoteKind = Object.freeze({ No:0,\"0\":\"No\",Yes:1,\"1\":\"Yes\",Abstain:2,\"2\":\"Abstain\", });\n/**\n*/\nconst CertificateKind = Object.freeze({ StakeRegistration:0,\"0\":\"StakeRegistration\",StakeDeregistration:1,\"1\":\"StakeDeregistration\",StakeDelegation:2,\"2\":\"StakeDelegation\",PoolRegistration:3,\"3\":\"PoolRegistration\",PoolRetirement:4,\"4\":\"PoolRetirement\",GenesisKeyDelegation:5,\"5\":\"GenesisKeyDelegation\",MoveInstantaneousRewardsCert:6,\"6\":\"MoveInstantaneousRewardsCert\",CommitteeHotAuth:7,\"7\":\"CommitteeHotAuth\",CommitteeColdResign:8,\"8\":\"CommitteeColdResign\",DrepDeregistration:9,\"9\":\"DrepDeregistration\",DrepRegistration:10,\"10\":\"DrepRegistration\",DrepUpdate:11,\"11\":\"DrepUpdate\",StakeAndVoteDelegation:12,\"12\":\"StakeAndVoteDelegation\",StakeRegistrationAndDelegation:13,\"13\":\"StakeRegistrationAndDelegation\",StakeVoteRegistrationAndDelegation:14,\"14\":\"StakeVoteRegistrationAndDelegation\",VoteDelegation:15,\"15\":\"VoteDelegation\",VoteRegistrationAndDelegation:16,\"16\":\"VoteRegistrationAndDelegation\", });\n/**\n*/\nconst VotingProposalKind = Object.freeze({ ParameterChangeProposal:0,\"0\":\"ParameterChangeProposal\",HardForkInitiationProposal:1,\"1\":\"HardForkInitiationProposal\",TreasuryWithdrawalsProposal:2,\"2\":\"TreasuryWithdrawalsProposal\",NoConfidenceProposal:3,\"3\":\"NoConfidenceProposal\",UpdateCommitteeProposal:4,\"4\":\"UpdateCommitteeProposal\",NewConstitutionProposal:5,\"5\":\"NewConstitutionProposal\",InfoProposal:6,\"6\":\"InfoProposal\", });\n/**\n*/\nconst LanguageKind = Object.freeze({ PlutusV1:0,\"0\":\"PlutusV1\",PlutusV2:1,\"1\":\"PlutusV2\",PlutusV3:2,\"2\":\"PlutusV3\", });\n/**\n*/\nconst PlutusDataKind = Object.freeze({ ConstrPlutusData:0,\"0\":\"ConstrPlutusData\",Map:1,\"1\":\"Map\",List:2,\"2\":\"List\",Integer:3,\"3\":\"Integer\",Bytes:4,\"4\":\"Bytes\", });\n/**\n*/\nconst RedeemerTagKind = Object.freeze({ Spend:0,\"0\":\"Spend\",Mint:1,\"1\":\"Mint\",Cert:2,\"2\":\"Cert\",Reward:3,\"3\":\"Reward\",Vote:4,\"4\":\"Vote\",VotingProposal:5,\"5\":\"VotingProposal\", });\n/**\n* JSON <-> PlutusData conversion schemas.\n* Follows ScriptDataJsonSchema in cardano-cli defined at:\n* https://github.com/input-output-hk/cardano-node/blob/master/cardano-api/src/Cardano/Api/ScriptData.hs#L254\n*\n* All methods here have the following restrictions due to limitations on dependencies:\n* * JSON numbers above u64::MAX (positive) or below i64::MIN (negative) will throw errors\n* * Hex strings for bytes don't accept odd-length (half-byte) strings.\n*      cardano-cli seems to support these however but it seems to be different than just 0-padding\n*      on either side when tested so proceed with caution\n*/\nconst PlutusDatumSchema = Object.freeze({\n/**\n* ScriptDataJsonNoSchema in cardano-node.\n*\n* This is the format used by --script-data-value in cardano-cli\n* This tries to accept most JSON but does not support the full spectrum of Plutus datums.\n* From JSON:\n* * null/true/false/floats NOT supported\n* * strings starting with 0x are treated as hex bytes. All other strings are encoded as their utf8 bytes.\n* To JSON:\n* * ConstrPlutusData not supported in ANY FORM (neither keys nor values)\n* * Lists not supported in keys\n* * Maps not supported in keys\n*/\nBasicConversions:0,\"0\":\"BasicConversions\",\n/**\n* ScriptDataJsonDetailedSchema in cardano-node.\n*\n* This is the format used by --script-data-file in cardano-cli\n* This covers almost all (only minor exceptions) Plutus datums, but the JSON must conform to a strict schema.\n* The schema specifies that ALL keys and ALL values must be contained in a JSON map with 2 cases:\n* 1. For ConstrPlutusData there must be two fields \"constructor\" contianing a number and \"fields\" containing its fields\n*    e.g. { \"constructor\": 2, \"fields\": [{\"int\": 2}, {\"list\": [{\"bytes\": \"CAFEF00D\"}]}]}\n* 2. For all other cases there must be only one field named \"int\", \"bytes\", \"list\" or \"map\"\n*    Integer's value is a JSON number e.g. {\"int\": 100}\n*    Bytes' value is a hex string representing the bytes WITHOUT any prefix e.g. {\"bytes\": \"CAFEF00D\"}\n*    Lists' value is a JSON list of its elements encoded via the same schema e.g. {\"list\": [{\"bytes\": \"CAFEF00D\"}]}\n*    Maps' value is a JSON list of objects, one for each key-value pair in the map, with keys \"k\" and \"v\"\n*          respectively with their values being the plutus datum encoded via this same schema\n*          e.g. {\"map\": [\n*              {\"k\": {\"int\": 2}, \"v\": {\"int\": 5}},\n*              {\"k\": {\"map\": [{\"k\": {\"list\": [{\"int\": 1}]}, \"v\": {\"bytes\": \"FF03\"}}]}, \"v\": {\"list\": []}}\n*          ]}\n* From JSON:\n* * null/true/false/floats NOT supported\n* * the JSON must conform to a very specific schema\n* To JSON:\n* * all Plutus datums should be fully supported outside of the integer range limitations outlined above.\n*/\nDetailedSchema:1,\"1\":\"DetailedSchema\", });\n/**\n*/\nconst TransactionMetadatumKind = Object.freeze({ MetadataMap:0,\"0\":\"MetadataMap\",MetadataList:1,\"1\":\"MetadataList\",Int:2,\"2\":\"Int\",Bytes:3,\"3\":\"Bytes\",Text:4,\"4\":\"Text\", });\n/**\n*/\nconst MetadataJsonSchema = Object.freeze({ NoConversions:0,\"0\":\"NoConversions\",BasicConversions:1,\"1\":\"BasicConversions\",DetailedSchema:2,\"2\":\"DetailedSchema\", });\n/**\n*/\nconst CoinSelectionStrategyCIP2 = Object.freeze({\n/**\n* Performs CIP2's Largest First ada-only selection. Will error if outputs contain non-ADA assets.\n*/\nLargestFirst:0,\"0\":\"LargestFirst\",\n/**\n* Performs CIP2's Random Improve ada-only selection. Will error if outputs contain non-ADA assets.\n*/\nRandomImprove:1,\"1\":\"RandomImprove\",\n/**\n* Same as LargestFirst, but before adding ADA, will insert by largest-first for each asset type.\n*/\nLargestFirstMultiAsset:2,\"2\":\"LargestFirstMultiAsset\",\n/**\n* Same as RandomImprove, but before adding ADA, will insert by random-improve for each asset type.\n*/\nRandomImproveMultiAsset:3,\"3\":\"RandomImproveMultiAsset\", });\n/**\n*/\nconst MIRPot = Object.freeze({ Reserves:0,\"0\":\"Reserves\",Treasury:1,\"1\":\"Treasury\", });\n/**\n*/\nconst MIRKind = Object.freeze({ ToOtherPot:0,\"0\":\"ToOtherPot\",ToStakeCredentials:1,\"1\":\"ToStakeCredentials\", });\n/**\n*/\nclass Address {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Address.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_address_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {Address}\n    */\n    static from_bytes(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.address_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Address}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.address_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Address}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.address_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string | undefined} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = isLikeNone(prefix) ? 0 : passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {Address}\n    */\n    static from_bech32(bech_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.address_from_bech32(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number}\n    */\n    network_id() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_network_id(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass Anchor {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Anchor.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_anchor_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchor_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Anchor}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.anchor_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Anchor.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchor_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Anchor}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.anchor_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Anchor.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchor_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchor_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Anchor}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.anchor_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Anchor.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {URL}\n    */\n    url() {\n        const ret = wasm.anchor_url(this.__wbg_ptr);\n        return URL.__wrap(ret);\n    }\n    /**\n    * @returns {AnchorDataHash}\n    */\n    anchor_data_hash() {\n        const ret = wasm.anchor_anchor_data_hash(this.__wbg_ptr);\n        return AnchorDataHash.__wrap(ret);\n    }\n    /**\n    * @param {URL} anchor_url\n    * @param {AnchorDataHash} anchor_data_hash\n    * @returns {Anchor}\n    */\n    static new(anchor_url, anchor_data_hash) {\n        _assertClass(anchor_url, URL);\n        _assertClass(anchor_data_hash, AnchorDataHash);\n        const ret = wasm.anchor_new(anchor_url.__wbg_ptr, anchor_data_hash.__wbg_ptr);\n        return Anchor.__wrap(ret);\n    }\n}\n/**\n*/\nclass AnchorDataHash {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AnchorDataHash.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_anchordatahash_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {AnchorDataHash}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.anchordatahash_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AnchorDataHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchordatahash_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.anchordatahash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {AnchorDataHash}\n    */\n    static from_bech32(bech_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.anchordatahash_from_bech32(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AnchorDataHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchordatahash_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {AnchorDataHash}\n    */\n    static from_hex(hex) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.anchordatahash_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AnchorDataHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass AssetName {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AssetName.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_assetname_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetname_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {AssetName}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.assetname_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AssetName.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetname_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {AssetName}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.assetname_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AssetName.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetname_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetname_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {AssetName}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.assetname_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AssetName.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} name\n    * @returns {AssetName}\n    */\n    static new(name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(name, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.assetname_new(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AssetName.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    name() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetname_name(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass AssetNames {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AssetNames.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_assetnames_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetnames_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {AssetNames}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.assetnames_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AssetNames.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetnames_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {AssetNames}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.assetnames_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AssetNames.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetnames_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetnames_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {AssetNames}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.assetnames_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AssetNames.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {AssetNames}\n    */\n    static new() {\n        const ret = wasm.assetnames_new();\n        return AssetNames.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.assetnames_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {AssetName}\n    */\n    get(index) {\n        const ret = wasm.assetnames_get(this.__wbg_ptr, index);\n        return AssetName.__wrap(ret);\n    }\n    /**\n    * @param {AssetName} elem\n    */\n    add(elem) {\n        _assertClass(elem, AssetName);\n        wasm.assetnames_add(this.__wbg_ptr, elem.__wbg_ptr);\n    }\n}\n/**\n*/\nclass Assets {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Assets.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_assets_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assets_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Assets}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.assets_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Assets.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assets_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Assets}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.assets_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Assets.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assets_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assets_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Assets}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.assets_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Assets.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Assets}\n    */\n    static new() {\n        const ret = wasm.assets_new();\n        return Assets.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.assetnames_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {AssetName} key\n    * @param {BigNum} value\n    * @returns {BigNum | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, AssetName);\n        _assertClass(value, BigNum);\n        const ret = wasm.assets_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {AssetName} key\n    * @returns {BigNum | undefined}\n    */\n    get(key) {\n        _assertClass(key, AssetName);\n        const ret = wasm.assets_get(this.__wbg_ptr, key.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {AssetNames}\n    */\n    keys() {\n        const ret = wasm.assets_keys(this.__wbg_ptr);\n        return AssetNames.__wrap(ret);\n    }\n}\n/**\n*/\nclass AuxiliaryData {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AuxiliaryData.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_auxiliarydata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.auxiliarydata_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {AuxiliaryData}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.auxiliarydata_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AuxiliaryData.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.auxiliarydata_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {AuxiliaryData}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.auxiliarydata_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AuxiliaryData.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.auxiliarydata_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.auxiliarydata_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {AuxiliaryData}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.auxiliarydata_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AuxiliaryData.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {AuxiliaryData}\n    */\n    static new() {\n        const ret = wasm.auxiliarydata_new();\n        return AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @returns {GeneralTransactionMetadata | undefined}\n    */\n    metadata() {\n        const ret = wasm.auxiliarydata_metadata(this.__wbg_ptr);\n        return ret === 0 ? undefined : GeneralTransactionMetadata.__wrap(ret);\n    }\n    /**\n    * @param {GeneralTransactionMetadata} metadata\n    */\n    set_metadata(metadata) {\n        _assertClass(metadata, GeneralTransactionMetadata);\n        wasm.auxiliarydata_set_metadata(this.__wbg_ptr, metadata.__wbg_ptr);\n    }\n    /**\n    * @returns {NativeScripts | undefined}\n    */\n    native_scripts() {\n        const ret = wasm.auxiliarydata_native_scripts(this.__wbg_ptr);\n        return ret === 0 ? undefined : NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {NativeScripts} native_scripts\n    */\n    set_native_scripts(native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        wasm.auxiliarydata_set_native_scripts(this.__wbg_ptr, native_scripts.__wbg_ptr);\n    }\n    /**\n    * @returns {PlutusScripts | undefined}\n    */\n    plutus_scripts() {\n        const ret = wasm.auxiliarydata_plutus_scripts(this.__wbg_ptr);\n        return ret === 0 ? undefined : PlutusScripts.__wrap(ret);\n    }\n    /**\n    * @param {PlutusScripts} plutus_scripts\n    */\n    set_plutus_scripts(plutus_scripts) {\n        _assertClass(plutus_scripts, PlutusScripts);\n        wasm.auxiliarydata_set_plutus_scripts(this.__wbg_ptr, plutus_scripts.__wbg_ptr);\n    }\n    /**\n    * @returns {boolean}\n    */\n    prefer_alonzo_format() {\n        const ret = wasm.auxiliarydata_prefer_alonzo_format(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {boolean} prefer\n    */\n    set_prefer_alonzo_format(prefer) {\n        wasm.auxiliarydata_set_prefer_alonzo_format(this.__wbg_ptr, prefer);\n    }\n}\n/**\n*/\nclass AuxiliaryDataHash {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AuxiliaryDataHash.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_auxiliarydatahash_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {AuxiliaryDataHash}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.auxiliarydatahash_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AuxiliaryDataHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchordatahash_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.anchordatahash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {AuxiliaryDataHash}\n    */\n    static from_bech32(bech_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.auxiliarydatahash_from_bech32(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AuxiliaryDataHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchordatahash_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {AuxiliaryDataHash}\n    */\n    static from_hex(hex) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.auxiliarydatahash_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AuxiliaryDataHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass AuxiliaryDataSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AuxiliaryDataSet.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_auxiliarydataset_free(ptr);\n    }\n    /**\n    * @returns {AuxiliaryDataSet}\n    */\n    static new() {\n        const ret = wasm.auxiliarydataset_new();\n        return AuxiliaryDataSet.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.auxiliarydataset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} tx_index\n    * @param {AuxiliaryData} data\n    * @returns {AuxiliaryData | undefined}\n    */\n    insert(tx_index, data) {\n        _assertClass(data, AuxiliaryData);\n        const ret = wasm.auxiliarydataset_insert(this.__wbg_ptr, tx_index, data.__wbg_ptr);\n        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @param {number} tx_index\n    * @returns {AuxiliaryData | undefined}\n    */\n    get(tx_index) {\n        const ret = wasm.auxiliarydataset_get(this.__wbg_ptr, tx_index);\n        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @returns {Uint32Array}\n    */\n    indices() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.auxiliarydataset_indices(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass BaseAddress {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(BaseAddress.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_baseaddress_free(ptr);\n    }\n    /**\n    * @param {number} network\n    * @param {Credential} payment\n    * @param {Credential} stake\n    * @returns {BaseAddress}\n    */\n    static new(network, payment, stake) {\n        _assertClass(payment, Credential);\n        _assertClass(stake, Credential);\n        const ret = wasm.baseaddress_new(network, payment.__wbg_ptr, stake.__wbg_ptr);\n        return BaseAddress.__wrap(ret);\n    }\n    /**\n    * @returns {Credential}\n    */\n    payment_cred() {\n        const ret = wasm.baseaddress_payment_cred(this.__wbg_ptr);\n        return Credential.__wrap(ret);\n    }\n    /**\n    * @returns {Credential}\n    */\n    stake_cred() {\n        const ret = wasm.baseaddress_stake_cred(this.__wbg_ptr);\n        return Credential.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        const ret = wasm.baseaddress_to_address(this.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {BaseAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        const ret = wasm.baseaddress_from_address(addr.__wbg_ptr);\n        return ret === 0 ? undefined : BaseAddress.__wrap(ret);\n    }\n}\n/**\n*/\nclass BigInt {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(BigInt.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bigint_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bigint_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {BigInt}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bigint_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BigInt.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bigint_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {BigInt}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bigint_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BigInt.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bigint_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bigint_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {BigInt}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bigint_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BigInt.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_zero() {\n        const ret = wasm.bigint_is_zero(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    as_u64() {\n        const ret = wasm.bigint_as_u64(this.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {Int | undefined}\n    */\n    as_int() {\n        const ret = wasm.bigint_as_int(this.__wbg_ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @param {string} text\n    * @returns {BigInt}\n    */\n    static from_str(text) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bigint_from_str(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BigInt.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_str() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bigint_to_str(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {BigInt} other\n    * @returns {BigInt}\n    */\n    add(other) {\n        _assertClass(other, BigInt);\n        const ret = wasm.bigint_add(this.__wbg_ptr, other.__wbg_ptr);\n        return BigInt.__wrap(ret);\n    }\n    /**\n    * @param {BigInt} other\n    * @returns {BigInt}\n    */\n    mul(other) {\n        _assertClass(other, BigInt);\n        const ret = wasm.bigint_mul(this.__wbg_ptr, other.__wbg_ptr);\n        return BigInt.__wrap(ret);\n    }\n    /**\n    * @returns {BigInt}\n    */\n    static one() {\n        const ret = wasm.bigint_one();\n        return BigInt.__wrap(ret);\n    }\n    /**\n    * @returns {BigInt}\n    */\n    increment() {\n        const ret = wasm.bigint_increment(this.__wbg_ptr);\n        return BigInt.__wrap(ret);\n    }\n    /**\n    * @param {BigInt} other\n    * @returns {BigInt}\n    */\n    div_ceil(other) {\n        _assertClass(other, BigInt);\n        const ret = wasm.bigint_div_ceil(this.__wbg_ptr, other.__wbg_ptr);\n        return BigInt.__wrap(ret);\n    }\n}\n/**\n*/\nclass BigNum {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(BigNum.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bignum_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bignum_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {BigNum}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bignum_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BigNum.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bignum_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {BigNum}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bignum_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BigNum.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bignum_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bignum_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {BigNum}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bignum_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BigNum.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} string\n    * @returns {BigNum}\n    */\n    static from_str(string) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bignum_from_str(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BigNum.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_str() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bignum_to_str(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @returns {BigNum}\n    */\n    static zero() {\n        const ret = wasm.bignum_zero();\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    static one() {\n        const ret = wasm.bignum_one();\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_zero() {\n        const ret = wasm.bignum_is_zero(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    div_floor(other) {\n        _assertClass(other, BigNum);\n        const ret = wasm.bignum_div_floor(this.__wbg_ptr, other.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_mul(other) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(other, BigNum);\n            wasm.bignum_checked_mul(retptr, this.__wbg_ptr, other.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BigNum.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_add(other) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(other, BigNum);\n            wasm.bignum_checked_add(retptr, this.__wbg_ptr, other.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BigNum.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_sub(other) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(other, BigNum);\n            wasm.bignum_checked_sub(retptr, this.__wbg_ptr, other.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BigNum.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * returns 0 if it would otherwise underflow\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    clamped_sub(other) {\n        _assertClass(other, BigNum);\n        const ret = wasm.bignum_clamped_sub(this.__wbg_ptr, other.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} rhs_value\n    * @returns {number}\n    */\n    compare(rhs_value) {\n        _assertClass(rhs_value, BigNum);\n        const ret = wasm.bignum_compare(this.__wbg_ptr, rhs_value.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {BigNum} rhs_value\n    * @returns {boolean}\n    */\n    less_than(rhs_value) {\n        _assertClass(rhs_value, BigNum);\n        const ret = wasm.bignum_less_than(this.__wbg_ptr, rhs_value.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {BigNum}\n    */\n    static max_value() {\n        const ret = wasm.bignum_max_value();\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} a\n    * @param {BigNum} b\n    * @returns {BigNum}\n    */\n    static max(a, b) {\n        _assertClass(a, BigNum);\n        _assertClass(b, BigNum);\n        const ret = wasm.bignum_max(a.__wbg_ptr, b.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n}\n/**\n*/\nclass Bip32PrivateKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Bip32PrivateKey.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bip32privatekey_free(ptr);\n    }\n    /**\n    * derive this private key with the given index.\n    *\n    * # Security considerations\n    *\n    * * hard derivation index cannot be soft derived with the public key\n    *\n    * # Hard derivation vs Soft derivation\n    *\n    * If you pass an index below 0x80000000 then it is a soft derivation.\n    * The advantage of soft derivation is that it is possible to derive the\n    * public key too. I.e. derivation the private key with a soft derivation\n    * index and then retrieving the associated public key is equivalent to\n    * deriving the public key associated to the parent private key.\n    *\n    * Hard derivation index does not allow public key derivation.\n    *\n    * This is why deriving the private key should not fail while deriving\n    * the public key may fail (if the derivation index is invalid).\n    * @param {number} index\n    * @returns {Bip32PrivateKey}\n    */\n    derive(index) {\n        const ret = wasm.bip32privatekey_derive(this.__wbg_ptr, index);\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * 128-byte xprv a key format in Cardano that some software still uses or requires\n    * the traditional 96-byte xprv is simply encoded as\n    * prv | chaincode\n    * however, because some software may not know how to compute a public key from a private key,\n    * the 128-byte inlines the public key in the following format\n    * prv | pub | chaincode\n    * so be careful if you see the term \"xprv\" as it could refer to either one\n    * our library does not require the pub (instead we compute the pub key when needed)\n    * @param {Uint8Array} bytes\n    * @returns {Bip32PrivateKey}\n    */\n    static from_128_xprv(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bip32privatekey_from_128_xprv(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Bip32PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * see from_128_xprv\n    * @returns {Uint8Array}\n    */\n    to_128_xprv() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32privatekey_to_128_xprv(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Bip32PrivateKey}\n    */\n    static generate_ed25519_bip32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32privatekey_generate_ed25519_bip32(retptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Bip32PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {PrivateKey}\n    */\n    to_raw_key() {\n        const ret = wasm.bip32privatekey_to_raw_key(this.__wbg_ptr);\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {Bip32PublicKey}\n    */\n    to_public() {\n        const ret = wasm.bip32privatekey_to_public(this.__wbg_ptr);\n        return Bip32PublicKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Bip32PrivateKey}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bip32privatekey_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Bip32PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32privatekey_as_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} bech32_str\n    * @returns {Bip32PrivateKey}\n    */\n    static from_bech32(bech32_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bip32privatekey_from_bech32(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Bip32PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32privatekey_to_bech32(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {Uint8Array} entropy\n    * @param {Uint8Array} password\n    * @returns {Bip32PrivateKey}\n    */\n    static from_bip39_entropy(entropy, password) {\n        const ptr0 = passArray8ToWasm0(entropy, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray8ToWasm0(password, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.bip32privatekey_from_bip39_entropy(ptr0, len0, ptr1, len1);\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    chaincode() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32privatekey_chaincode(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32privatekey_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Bip32PrivateKey}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bip32privatekey_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Bip32PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass Bip32PublicKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Bip32PublicKey.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bip32publickey_free(ptr);\n    }\n    /**\n    * derive this public key with the given index.\n    *\n    * # Errors\n    *\n    * If the index is not a soft derivation index (< 0x80000000) then\n    * calling this method will fail.\n    *\n    * # Security considerations\n    *\n    * * hard derivation index cannot be soft derived with the public key\n    *\n    * # Hard derivation vs Soft derivation\n    *\n    * If you pass an index below 0x80000000 then it is a soft derivation.\n    * The advantage of soft derivation is that it is possible to derive the\n    * public key too. I.e. derivation the private key with a soft derivation\n    * index and then retrieving the associated public key is equivalent to\n    * deriving the public key associated to the parent private key.\n    *\n    * Hard derivation index does not allow public key derivation.\n    *\n    * This is why deriving the private key should not fail while deriving\n    * the public key may fail (if the derivation index is invalid).\n    * @param {number} index\n    * @returns {Bip32PublicKey}\n    */\n    derive(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32publickey_derive(retptr, this.__wbg_ptr, index);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Bip32PublicKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {PublicKey}\n    */\n    to_raw_key() {\n        const ret = wasm.bip32publickey_to_raw_key(this.__wbg_ptr);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Bip32PublicKey}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bip32publickey_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Bip32PublicKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32publickey_as_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} bech32_str\n    * @returns {Bip32PublicKey}\n    */\n    static from_bech32(bech32_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bip32publickey_from_bech32(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Bip32PublicKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32publickey_to_bech32(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    chaincode() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32publickey_chaincode(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32publickey_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Bip32PublicKey}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bip32publickey_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Bip32PublicKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass Block {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Block.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_block_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.block_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Block}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.block_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Block.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.block_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Block}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.block_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Block.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.block_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.block_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Block}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.block_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Block.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Header}\n    */\n    header() {\n        const ret = wasm.block_header(this.__wbg_ptr);\n        return Header.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionBodies}\n    */\n    transaction_bodies() {\n        const ret = wasm.block_transaction_bodies(this.__wbg_ptr);\n        return TransactionBodies.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionWitnessSets}\n    */\n    transaction_witness_sets() {\n        const ret = wasm.block_transaction_witness_sets(this.__wbg_ptr);\n        return TransactionWitnessSets.__wrap(ret);\n    }\n    /**\n    * @returns {AuxiliaryDataSet}\n    */\n    auxiliary_data_set() {\n        const ret = wasm.block_auxiliary_data_set(this.__wbg_ptr);\n        return AuxiliaryDataSet.__wrap(ret);\n    }\n    /**\n    * @returns {Uint32Array}\n    */\n    invalid_transactions() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.block_invalid_transactions(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Header} header\n    * @param {TransactionBodies} transaction_bodies\n    * @param {TransactionWitnessSets} transaction_witness_sets\n    * @param {AuxiliaryDataSet} auxiliary_data_set\n    * @param {Uint32Array} invalid_transactions\n    * @returns {Block}\n    */\n    static new(header, transaction_bodies, transaction_witness_sets, auxiliary_data_set, invalid_transactions) {\n        _assertClass(header, Header);\n        _assertClass(transaction_bodies, TransactionBodies);\n        _assertClass(transaction_witness_sets, TransactionWitnessSets);\n        _assertClass(auxiliary_data_set, AuxiliaryDataSet);\n        const ptr0 = passArray32ToWasm0(invalid_transactions, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.block_new(header.__wbg_ptr, transaction_bodies.__wbg_ptr, transaction_witness_sets.__wbg_ptr, auxiliary_data_set.__wbg_ptr, ptr0, len0);\n        return Block.__wrap(ret);\n    }\n}\n/**\n*/\nclass BlockHash {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(BlockHash.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_blockhash_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {BlockHash}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.blockhash_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BlockHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchordatahash_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.anchordatahash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {BlockHash}\n    */\n    static from_bech32(bech_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.blockhash_from_bech32(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BlockHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchordatahash_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {BlockHash}\n    */\n    static from_hex(hex) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.blockhash_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BlockHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass BootstrapWitness {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(BootstrapWitness.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bootstrapwitness_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bootstrapwitness_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {BootstrapWitness}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bootstrapwitness_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BootstrapWitness.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bootstrapwitness_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {BootstrapWitness}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bootstrapwitness_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BootstrapWitness.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bootstrapwitness_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bootstrapwitness_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {BootstrapWitness}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bootstrapwitness_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BootstrapWitness.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Vkey}\n    */\n    vkey() {\n        const ret = wasm.bootstrapwitness_vkey(this.__wbg_ptr);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519Signature}\n    */\n    signature() {\n        const ret = wasm.bootstrapwitness_signature(this.__wbg_ptr);\n        return Ed25519Signature.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    chain_code() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bootstrapwitness_chain_code(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    attributes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bootstrapwitness_attributes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Vkey} vkey\n    * @param {Ed25519Signature} signature\n    * @param {Uint8Array} chain_code\n    * @param {Uint8Array} attributes\n    * @returns {BootstrapWitness}\n    */\n    static new(vkey, signature, chain_code, attributes) {\n        _assertClass(vkey, Vkey);\n        _assertClass(signature, Ed25519Signature);\n        const ptr0 = passArray8ToWasm0(chain_code, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray8ToWasm0(attributes, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.bootstrapwitness_new(vkey.__wbg_ptr, signature.__wbg_ptr, ptr0, len0, ptr1, len1);\n        return BootstrapWitness.__wrap(ret);\n    }\n}\n/**\n*/\nclass BootstrapWitnesses {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(BootstrapWitnesses.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bootstrapwitnesses_free(ptr);\n    }\n    /**\n    * @returns {BootstrapWitnesses}\n    */\n    static new() {\n        const ret = wasm.bootstrapwitnesses_new();\n        return BootstrapWitnesses.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.bootstrapwitnesses_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {BootstrapWitness}\n    */\n    get(index) {\n        const ret = wasm.bootstrapwitnesses_get(this.__wbg_ptr, index);\n        return BootstrapWitness.__wrap(ret);\n    }\n    /**\n    * @param {BootstrapWitness} elem\n    */\n    add(elem) {\n        _assertClass(elem, BootstrapWitness);\n        wasm.bootstrapwitnesses_add(this.__wbg_ptr, elem.__wbg_ptr);\n    }\n}\n/**\n*/\nclass ByronAddress {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ByronAddress.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_byronaddress_free(ptr);\n    }\n    /**\n    * @returns {string}\n    */\n    to_base58() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.byronaddress_to_base58(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.byronaddress_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ByronAddress}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.byronaddress_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ByronAddress.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * returns the byron protocol magic embedded in the address, or mainnet id if none is present\n    * note: for bech32 addresses, you need to use network_id instead\n    * @returns {number}\n    */\n    byron_protocol_magic() {\n        const ret = wasm.byronaddress_byron_protocol_magic(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    attributes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.byronaddress_attributes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number}\n    */\n    network_id() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.byronaddress_network_id(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} s\n    * @returns {ByronAddress}\n    */\n    static from_base58(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.byronaddress_from_base58(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ByronAddress.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Bip32PublicKey} key\n    * @param {number} protocol_magic\n    * @returns {ByronAddress}\n    */\n    static icarus_from_key(key, protocol_magic) {\n        _assertClass(key, Bip32PublicKey);\n        const ret = wasm.byronaddress_icarus_from_key(key.__wbg_ptr, protocol_magic);\n        return ByronAddress.__wrap(ret);\n    }\n    /**\n    * @param {string} s\n    * @returns {boolean}\n    */\n    static is_valid(s) {\n        const ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.byronaddress_is_valid(ptr0, len0);\n        return ret !== 0;\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        const ret = wasm.byronaddress_to_address(this.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {ByronAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        const ret = wasm.byronaddress_from_address(addr.__wbg_ptr);\n        return ret === 0 ? undefined : ByronAddress.__wrap(ret);\n    }\n}\n/**\n*/\nclass Certificate {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Certificate.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_certificate_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.certificate_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Certificate}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.certificate_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Certificate.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.certificate_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Certificate}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.certificate_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Certificate.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.certificate_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.certificate_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Certificate}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.certificate_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Certificate.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {StakeRegistration} stake_registration\n    * @returns {Certificate}\n    */\n    static new_stake_registration(stake_registration) {\n        _assertClass(stake_registration, StakeRegistration);\n        const ret = wasm.certificate_new_stake_registration(stake_registration.__wbg_ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {StakeDeregistration} stake_deregistration\n    * @returns {Certificate}\n    */\n    static new_stake_deregistration(stake_deregistration) {\n        _assertClass(stake_deregistration, StakeDeregistration);\n        const ret = wasm.certificate_new_stake_deregistration(stake_deregistration.__wbg_ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {StakeDelegation} stake_delegation\n    * @returns {Certificate}\n    */\n    static new_stake_delegation(stake_delegation) {\n        _assertClass(stake_delegation, StakeDelegation);\n        const ret = wasm.certificate_new_stake_delegation(stake_delegation.__wbg_ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {PoolRegistration} pool_registration\n    * @returns {Certificate}\n    */\n    static new_pool_registration(pool_registration) {\n        _assertClass(pool_registration, PoolRegistration);\n        const ret = wasm.certificate_new_pool_registration(pool_registration.__wbg_ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {PoolRetirement} pool_retirement\n    * @returns {Certificate}\n    */\n    static new_pool_retirement(pool_retirement) {\n        _assertClass(pool_retirement, PoolRetirement);\n        const ret = wasm.certificate_new_pool_retirement(pool_retirement.__wbg_ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {GenesisKeyDelegation} genesis_key_delegation\n    * @returns {Certificate}\n    */\n    static new_genesis_key_delegation(genesis_key_delegation) {\n        _assertClass(genesis_key_delegation, GenesisKeyDelegation);\n        const ret = wasm.certificate_new_genesis_key_delegation(genesis_key_delegation.__wbg_ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {MoveInstantaneousRewardsCert} move_instantaneous_rewards_cert\n    * @returns {Certificate}\n    */\n    static new_move_instantaneous_rewards_cert(move_instantaneous_rewards_cert) {\n        _assertClass(move_instantaneous_rewards_cert, MoveInstantaneousRewardsCert);\n        const ret = wasm.certificate_new_move_instantaneous_rewards_cert(move_instantaneous_rewards_cert.__wbg_ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {CommitteeHotAuth} committee_hot_key_registration\n    * @returns {Certificate}\n    */\n    static new_committee_hot_key_registration(committee_hot_key_registration) {\n        _assertClass(committee_hot_key_registration, CommitteeHotAuth);\n        const ret = wasm.certificate_new_committee_hot_key_registration(committee_hot_key_registration.__wbg_ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {CommitteeColdResign} committee_hot_key_deregistration\n    * @returns {Certificate}\n    */\n    static new_committee_hot_key_deregistration(committee_hot_key_deregistration) {\n        _assertClass(committee_hot_key_deregistration, CommitteeColdResign);\n        const ret = wasm.certificate_new_committee_hot_key_deregistration(committee_hot_key_deregistration.__wbg_ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {DrepDeregistration} drep_deregistration\n    * @returns {Certificate}\n    */\n    static new_drep_deregistration(drep_deregistration) {\n        _assertClass(drep_deregistration, DrepDeregistration);\n        const ret = wasm.certificate_new_drep_deregistration(drep_deregistration.__wbg_ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {DrepRegistration} drep_registration\n    * @returns {Certificate}\n    */\n    static new_drep_registration(drep_registration) {\n        _assertClass(drep_registration, DrepRegistration);\n        const ret = wasm.certificate_new_drep_registration(drep_registration.__wbg_ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {DrepUpdate} drep_update\n    * @returns {Certificate}\n    */\n    static new_drep_update(drep_update) {\n        _assertClass(drep_update, DrepUpdate);\n        const ret = wasm.certificate_new_drep_update(drep_update.__wbg_ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {StakeAndVoteDelegation} stake_and_vote_delegation\n    * @returns {Certificate}\n    */\n    static new_stake_and_vote_delegation(stake_and_vote_delegation) {\n        _assertClass(stake_and_vote_delegation, StakeAndVoteDelegation);\n        const ret = wasm.certificate_new_stake_and_vote_delegation(stake_and_vote_delegation.__wbg_ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {StakeRegistrationAndDelegation} stake_registration_and_delegation\n    * @returns {Certificate}\n    */\n    static new_stake_registration_and_delegation(stake_registration_and_delegation) {\n        _assertClass(stake_registration_and_delegation, StakeRegistrationAndDelegation);\n        const ret = wasm.certificate_new_stake_registration_and_delegation(stake_registration_and_delegation.__wbg_ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {StakeVoteRegistrationAndDelegation} stake_vote_registration_and_delegation\n    * @returns {Certificate}\n    */\n    static new_stake_vote_registration_and_delegation(stake_vote_registration_and_delegation) {\n        _assertClass(stake_vote_registration_and_delegation, StakeVoteRegistrationAndDelegation);\n        const ret = wasm.certificate_new_stake_vote_registration_and_delegation(stake_vote_registration_and_delegation.__wbg_ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {VoteDelegation} vote_delegation\n    * @returns {Certificate}\n    */\n    static new_vote_delegation(vote_delegation) {\n        _assertClass(vote_delegation, VoteDelegation);\n        const ret = wasm.certificate_new_vote_delegation(vote_delegation.__wbg_ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {VoteRegistrationAndDelegation} vote_registration_and_delegation\n    * @returns {Certificate}\n    */\n    static new_vote_registration_and_delegation(vote_registration_and_delegation) {\n        _assertClass(vote_registration_and_delegation, VoteRegistrationAndDelegation);\n        const ret = wasm.certificate_new_vote_registration_and_delegation(vote_registration_and_delegation.__wbg_ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        const ret = wasm.certificate_kind(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {StakeRegistration | undefined}\n    */\n    as_stake_registration() {\n        const ret = wasm.certificate_as_stake_registration(this.__wbg_ptr);\n        return ret === 0 ? undefined : StakeRegistration.__wrap(ret);\n    }\n    /**\n    * @returns {StakeDeregistration | undefined}\n    */\n    as_stake_deregistration() {\n        const ret = wasm.certificate_as_stake_deregistration(this.__wbg_ptr);\n        return ret === 0 ? undefined : StakeDeregistration.__wrap(ret);\n    }\n    /**\n    * @returns {StakeDelegation | undefined}\n    */\n    as_stake_delegation() {\n        const ret = wasm.certificate_as_stake_delegation(this.__wbg_ptr);\n        return ret === 0 ? undefined : StakeDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {PoolRegistration | undefined}\n    */\n    as_pool_registration() {\n        const ret = wasm.certificate_as_pool_registration(this.__wbg_ptr);\n        return ret === 0 ? undefined : PoolRegistration.__wrap(ret);\n    }\n    /**\n    * @returns {PoolRetirement | undefined}\n    */\n    as_pool_retirement() {\n        const ret = wasm.certificate_as_pool_retirement(this.__wbg_ptr);\n        return ret === 0 ? undefined : PoolRetirement.__wrap(ret);\n    }\n    /**\n    * @returns {GenesisKeyDelegation | undefined}\n    */\n    as_genesis_key_delegation() {\n        const ret = wasm.certificate_as_genesis_key_delegation(this.__wbg_ptr);\n        return ret === 0 ? undefined : GenesisKeyDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {MoveInstantaneousRewardsCert | undefined}\n    */\n    as_move_instantaneous_rewards_cert() {\n        const ret = wasm.certificate_as_move_instantaneous_rewards_cert(this.__wbg_ptr);\n        return ret === 0 ? undefined : MoveInstantaneousRewardsCert.__wrap(ret);\n    }\n    /**\n    * @returns {CommitteeHotAuth | undefined}\n    */\n    as_committee_hot_key_registration() {\n        const ret = wasm.certificate_as_committee_hot_key_registration(this.__wbg_ptr);\n        return ret === 0 ? undefined : CommitteeHotAuth.__wrap(ret);\n    }\n    /**\n    * @returns {CommitteeColdResign | undefined}\n    */\n    as_committee_hot_key_deregistration() {\n        const ret = wasm.certificate_as_committee_hot_key_deregistration(this.__wbg_ptr);\n        return ret === 0 ? undefined : CommitteeColdResign.__wrap(ret);\n    }\n    /**\n    * @returns {DrepDeregistration | undefined}\n    */\n    as_drep_deregistration() {\n        const ret = wasm.certificate_as_drep_deregistration(this.__wbg_ptr);\n        return ret === 0 ? undefined : DrepDeregistration.__wrap(ret);\n    }\n    /**\n    * @returns {DrepRegistration | undefined}\n    */\n    as_drep_registration() {\n        const ret = wasm.certificate_as_drep_registration(this.__wbg_ptr);\n        return ret === 0 ? undefined : DrepRegistration.__wrap(ret);\n    }\n    /**\n    * @returns {DrepUpdate | undefined}\n    */\n    as_drep_update() {\n        const ret = wasm.certificate_as_drep_update(this.__wbg_ptr);\n        return ret === 0 ? undefined : DrepUpdate.__wrap(ret);\n    }\n    /**\n    * @returns {StakeAndVoteDelegation | undefined}\n    */\n    as_stake_and_vote_delegation() {\n        const ret = wasm.certificate_as_stake_and_vote_delegation(this.__wbg_ptr);\n        return ret === 0 ? undefined : StakeAndVoteDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {StakeRegistrationAndDelegation | undefined}\n    */\n    as_stake_registration_and_delegation() {\n        const ret = wasm.certificate_as_stake_registration_and_delegation(this.__wbg_ptr);\n        return ret === 0 ? undefined : StakeRegistrationAndDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {StakeVoteRegistrationAndDelegation | undefined}\n    */\n    as_stake_vote_registration_and_delegation() {\n        const ret = wasm.certificate_as_stake_vote_registration_and_delegation(this.__wbg_ptr);\n        return ret === 0 ? undefined : StakeVoteRegistrationAndDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {VoteDelegation | undefined}\n    */\n    as_vote_delegation() {\n        const ret = wasm.certificate_as_vote_delegation(this.__wbg_ptr);\n        return ret === 0 ? undefined : VoteDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {VoteRegistrationAndDelegation | undefined}\n    */\n    as_vote_registration_and_delegation() {\n        const ret = wasm.certificate_as_vote_registration_and_delegation(this.__wbg_ptr);\n        return ret === 0 ? undefined : VoteRegistrationAndDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_required_script_witness() {\n        const ret = wasm.certificate_has_required_script_witness(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nclass Certificates {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Certificates.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_certificates_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.certificates_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Certificates}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.certificates_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Certificates.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.certificates_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Certificates}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.certificates_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Certificates.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.certificates_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.certificates_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Certificates}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.certificates_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Certificates.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Certificates}\n    */\n    static new() {\n        const ret = wasm.certificates_new();\n        return Certificates.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.certificates_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Certificate}\n    */\n    get(index) {\n        const ret = wasm.certificates_get(this.__wbg_ptr, index);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {Certificate} elem\n    */\n    add(elem) {\n        _assertClass(elem, Certificate);\n        wasm.certificates_add(this.__wbg_ptr, elem.__wbg_ptr);\n    }\n}\n/**\n*/\nclass CertificatesBuilder {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(CertificatesBuilder.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_certificatesbuilder_free(ptr);\n    }\n    /**\n    * @returns {CertificatesBuilder}\n    */\n    static new() {\n        const ret = wasm.certificates_new();\n        return CertificatesBuilder.__wrap(ret);\n    }\n    /**\n    * @param {Certificate} cert\n    */\n    add(cert) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(cert, Certificate);\n            wasm.certificatesbuilder_add(retptr, this.__wbg_ptr, cert.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Certificate} cert\n    * @param {PlutusWitness} witness\n    */\n    add_with_plutus_witness(cert, witness) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(cert, Certificate);\n            _assertClass(witness, PlutusWitness);\n            wasm.certificatesbuilder_add_with_plutus_witness(retptr, this.__wbg_ptr, cert.__wbg_ptr, witness.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Certificate} cert\n    * @param {NativeScriptSource} native_script_source\n    */\n    add_with_native_script(cert, native_script_source) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(cert, Certificate);\n            _assertClass(native_script_source, NativeScriptSource);\n            wasm.certificatesbuilder_add_with_native_script(retptr, this.__wbg_ptr, cert.__wbg_ptr, native_script_source.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {PlutusWitnesses}\n    */\n    get_plutus_witnesses() {\n        const ret = wasm.certificatesbuilder_get_plutus_witnesses(this.__wbg_ptr);\n        return PlutusWitnesses.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInputs}\n    */\n    get_ref_inputs() {\n        const ret = wasm.certificatesbuilder_get_ref_inputs(this.__wbg_ptr);\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    get_native_scripts() {\n        const ret = wasm.certificatesbuilder_get_native_scripts(this.__wbg_ptr);\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} pool_deposit\n    * @param {BigNum} key_deposit\n    * @returns {Value}\n    */\n    get_certificates_refund(pool_deposit, key_deposit) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(pool_deposit, BigNum);\n            _assertClass(key_deposit, BigNum);\n            wasm.certificatesbuilder_get_certificates_refund(retptr, this.__wbg_ptr, pool_deposit.__wbg_ptr, key_deposit.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Value.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {BigNum} pool_deposit\n    * @param {BigNum} key_deposit\n    * @returns {BigNum}\n    */\n    get_certificates_deposit(pool_deposit, key_deposit) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(pool_deposit, BigNum);\n            _assertClass(key_deposit, BigNum);\n            wasm.certificatesbuilder_get_certificates_deposit(retptr, this.__wbg_ptr, pool_deposit.__wbg_ptr, key_deposit.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BigNum.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_plutus_scripts() {\n        const ret = wasm.certificatesbuilder_has_plutus_scripts(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {Certificates}\n    */\n    build() {\n        const ret = wasm.certificatesbuilder_build(this.__wbg_ptr);\n        return Certificates.__wrap(ret);\n    }\n}\n/**\n*/\nclass Committee {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Committee.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_committee_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.committee_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Committee}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.committee_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Committee.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.committee_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Committee}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.committee_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Committee.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.committee_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.committee_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Committee}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.committee_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Committee.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {UnitInterval} quorum_threshold\n    * @returns {Committee}\n    */\n    static new(quorum_threshold) {\n        _assertClass(quorum_threshold, UnitInterval);\n        const ret = wasm.committee_new(quorum_threshold.__wbg_ptr);\n        return Committee.__wrap(ret);\n    }\n    /**\n    * @returns {Credentials}\n    */\n    members_keys() {\n        const ret = wasm.committee_members_keys(this.__wbg_ptr);\n        return Credentials.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    quorum_threshold() {\n        const ret = wasm.committee_quorum_threshold(this.__wbg_ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @param {Credential} committee_cold_credential\n    * @param {number} epoch\n    */\n    add_member(committee_cold_credential, epoch) {\n        _assertClass(committee_cold_credential, Credential);\n        wasm.committee_add_member(this.__wbg_ptr, committee_cold_credential.__wbg_ptr, epoch);\n    }\n    /**\n    * @param {Credential} committee_cold_credential\n    * @returns {number | undefined}\n    */\n    get_member_epoch(committee_cold_credential) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(committee_cold_credential, Credential);\n            wasm.committee_get_member_epoch(retptr, this.__wbg_ptr, committee_cold_credential.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass CommitteeColdResign {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(CommitteeColdResign.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_committeecoldresign_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.committeecoldresign_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CommitteeColdResign}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.committeecoldresign_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return CommitteeColdResign.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.committeecoldresign_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {CommitteeColdResign}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.committeecoldresign_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return CommitteeColdResign.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.committeecoldresign_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.committeecoldresign_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {CommitteeColdResign}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.committeecoldresign_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return CommitteeColdResign.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Credential}\n    */\n    committee_cold_key() {\n        const ret = wasm.committeecoldresign_committee_cold_key(this.__wbg_ptr);\n        return Credential.__wrap(ret);\n    }\n    /**\n    * @param {Credential} committee_cold_key\n    * @returns {CommitteeColdResign}\n    */\n    static new(committee_cold_key) {\n        _assertClass(committee_cold_key, Credential);\n        const ret = wasm.committeecoldresign_new(committee_cold_key.__wbg_ptr);\n        return CommitteeColdResign.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_script_credentials() {\n        const ret = wasm.committeecoldresign_has_script_credentials(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nclass CommitteeHotAuth {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(CommitteeHotAuth.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_committeehotauth_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.committeehotauth_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CommitteeHotAuth}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.committeehotauth_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return CommitteeHotAuth.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.committeehotauth_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {CommitteeHotAuth}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.committeehotauth_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return CommitteeHotAuth.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.committeehotauth_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.committeehotauth_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {CommitteeHotAuth}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.committeehotauth_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return CommitteeHotAuth.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Credential}\n    */\n    committee_cold_key() {\n        const ret = wasm.committeehotauth_committee_cold_key(this.__wbg_ptr);\n        return Credential.__wrap(ret);\n    }\n    /**\n    * @returns {Credential}\n    */\n    committee_hot_key() {\n        const ret = wasm.committeehotauth_committee_hot_key(this.__wbg_ptr);\n        return Credential.__wrap(ret);\n    }\n    /**\n    * @param {Credential} committee_cold_key\n    * @param {Credential} committee_hot_key\n    * @returns {CommitteeHotAuth}\n    */\n    static new(committee_cold_key, committee_hot_key) {\n        _assertClass(committee_cold_key, Credential);\n        _assertClass(committee_hot_key, Credential);\n        const ret = wasm.committeehotauth_new(committee_cold_key.__wbg_ptr, committee_hot_key.__wbg_ptr);\n        return CommitteeHotAuth.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_script_credentials() {\n        const ret = wasm.committeehotauth_has_script_credentials(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nclass Constitution {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Constitution.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_constitution_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constitution_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Constitution}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.constitution_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constitution.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constitution_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Constitution}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.constitution_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constitution.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constitution_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constitution_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Constitution}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.constitution_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constitution.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Anchor}\n    */\n    anchor() {\n        const ret = wasm.constitution_anchor(this.__wbg_ptr);\n        return Anchor.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptHash | undefined}\n    */\n    script_hash() {\n        const ret = wasm.constitution_script_hash(this.__wbg_ptr);\n        return ret === 0 ? undefined : ScriptHash.__wrap(ret);\n    }\n    /**\n    * @param {Anchor} anchor\n    * @returns {Constitution}\n    */\n    static new(anchor) {\n        _assertClass(anchor, Anchor);\n        const ret = wasm.constitution_new(anchor.__wbg_ptr);\n        return Constitution.__wrap(ret);\n    }\n    /**\n    * @param {Anchor} anchor\n    * @param {ScriptHash} script_hash\n    * @returns {Constitution}\n    */\n    static new_with_script_hash(anchor, script_hash) {\n        _assertClass(anchor, Anchor);\n        _assertClass(script_hash, ScriptHash);\n        const ret = wasm.constitution_new_with_script_hash(anchor.__wbg_ptr, script_hash.__wbg_ptr);\n        return Constitution.__wrap(ret);\n    }\n}\n/**\n*/\nclass ConstrPlutusData {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ConstrPlutusData.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_constrplutusdata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constrplutusdata_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ConstrPlutusData}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.constrplutusdata_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ConstrPlutusData.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constrplutusdata_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ConstrPlutusData}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.constrplutusdata_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ConstrPlutusData.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {BigNum}\n    */\n    alternative() {\n        const ret = wasm.constrplutusdata_alternative(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusList}\n    */\n    data() {\n        const ret = wasm.constrplutusdata_data(this.__wbg_ptr);\n        return PlutusList.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} alternative\n    * @param {PlutusList} data\n    * @returns {ConstrPlutusData}\n    */\n    static new(alternative, data) {\n        _assertClass(alternative, BigNum);\n        _assertClass(data, PlutusList);\n        const ret = wasm.constrplutusdata_new(alternative.__wbg_ptr, data.__wbg_ptr);\n        return ConstrPlutusData.__wrap(ret);\n    }\n}\n/**\n*/\nclass CostModel {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(CostModel.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_costmodel_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.costmodel_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CostModel}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.costmodel_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return CostModel.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.costmodel_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {CostModel}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.costmodel_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return CostModel.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.costmodel_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.costmodel_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {CostModel}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.costmodel_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return CostModel.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Creates a new CostModels instance of an unrestricted length\n    * @returns {CostModel}\n    */\n    static new() {\n        const ret = wasm.costmodel_new();\n        return CostModel.__wrap(ret);\n    }\n    /**\n    * Sets the cost at the specified index to the specified value.\n    * In case the operation index is larger than the previous largest used index,\n    * it will fill any inbetween indexes with zeroes\n    * @param {number} operation\n    * @param {Int} cost\n    * @returns {Int}\n    */\n    set(operation, cost) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(cost, Int);\n            wasm.costmodel_set(retptr, this.__wbg_ptr, operation, cost.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Int.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} operation\n    * @returns {Int}\n    */\n    get(operation) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.costmodel_get(retptr, this.__wbg_ptr, operation);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Int.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.costmdls_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nclass Costmdls {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Costmdls.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_costmdls_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.costmdls_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Costmdls}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.costmdls_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Costmdls.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.costmdls_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Costmdls}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.costmdls_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Costmdls.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.costmdls_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.costmdls_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Costmdls}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.costmdls_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Costmdls.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Costmdls}\n    */\n    static new() {\n        const ret = wasm.costmdls_new();\n        return Costmdls.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.costmdls_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {Language} key\n    * @param {CostModel} value\n    * @returns {CostModel | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, Language);\n        _assertClass(value, CostModel);\n        const ret = wasm.costmdls_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);\n        return ret === 0 ? undefined : CostModel.__wrap(ret);\n    }\n    /**\n    * @param {Language} key\n    * @returns {CostModel | undefined}\n    */\n    get(key) {\n        _assertClass(key, Language);\n        const ret = wasm.costmdls_get(this.__wbg_ptr, key.__wbg_ptr);\n        return ret === 0 ? undefined : CostModel.__wrap(ret);\n    }\n    /**\n    * @returns {Languages}\n    */\n    keys() {\n        const ret = wasm.costmdls_keys(this.__wbg_ptr);\n        return Languages.__wrap(ret);\n    }\n    /**\n    * @param {Languages} languages\n    * @returns {Costmdls}\n    */\n    retain_language_versions(languages) {\n        _assertClass(languages, Languages);\n        const ret = wasm.costmdls_retain_language_versions(this.__wbg_ptr, languages.__wbg_ptr);\n        return Costmdls.__wrap(ret);\n    }\n}\n/**\n*/\nclass Credential {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Credential.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_credential_free(ptr);\n    }\n    /**\n    * @param {Ed25519KeyHash} hash\n    * @returns {Credential}\n    */\n    static from_keyhash(hash) {\n        _assertClass(hash, Ed25519KeyHash);\n        const ret = wasm.credential_from_keyhash(hash.__wbg_ptr);\n        return Credential.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} hash\n    * @returns {Credential}\n    */\n    static from_scripthash(hash) {\n        _assertClass(hash, ScriptHash);\n        const ret = wasm.credential_from_scripthash(hash.__wbg_ptr);\n        return Credential.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash | undefined}\n    */\n    to_keyhash() {\n        const ret = wasm.credential_to_keyhash(this.__wbg_ptr);\n        return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptHash | undefined}\n    */\n    to_scripthash() {\n        const ret = wasm.credential_to_scripthash(this.__wbg_ptr);\n        return ret === 0 ? undefined : ScriptHash.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        const ret = wasm.credential_has_script_hash(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_script_hash() {\n        const ret = wasm.credential_has_script_hash(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.credential_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Credential}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.credential_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Credential.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.credential_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Credential}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.credential_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Credential.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.credential_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.credential_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Credential}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.credential_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Credential.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass Credentials {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Credentials.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_credentials_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.credentials_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Credentials}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.credentials_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Credentials.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.credentials_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Credentials}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.credentials_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Credentials.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.credentials_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.credentials_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Credentials}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.credentials_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Credentials.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Credentials}\n    */\n    static new() {\n        const ret = wasm.credentials_new();\n        return Credentials.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.assetnames_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Credential}\n    */\n    get(index) {\n        const ret = wasm.credentials_get(this.__wbg_ptr, index);\n        return Credential.__wrap(ret);\n    }\n    /**\n    * @param {Credential} elem\n    */\n    add(elem) {\n        _assertClass(elem, Credential);\n        wasm.credentials_add(this.__wbg_ptr, elem.__wbg_ptr);\n    }\n}\n/**\n*/\nclass DNSRecordAorAAAA {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(DNSRecordAorAAAA.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_dnsrecordaoraaaa_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordaoraaaa_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {DNSRecordAorAAAA}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.dnsrecordaoraaaa_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DNSRecordAorAAAA.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordaoraaaa_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {DNSRecordAorAAAA}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.dnsrecordaoraaaa_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DNSRecordAorAAAA.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordaoraaaa_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordaoraaaa_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {DNSRecordAorAAAA}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.dnsrecordaoraaaa_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DNSRecordAorAAAA.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} dns_name\n    * @returns {DNSRecordAorAAAA}\n    */\n    static new(dns_name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(dns_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.dnsrecordaoraaaa_new(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DNSRecordAorAAAA.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    record() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordaoraaaa_record(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n/**\n*/\nclass DNSRecordSRV {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(DNSRecordSRV.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_dnsrecordsrv_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordsrv_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {DNSRecordSRV}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.dnsrecordsrv_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DNSRecordSRV.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordsrv_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {DNSRecordSRV}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.dnsrecordsrv_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DNSRecordSRV.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordaoraaaa_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordaoraaaa_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {DNSRecordSRV}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.dnsrecordsrv_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DNSRecordSRV.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} dns_name\n    * @returns {DNSRecordSRV}\n    */\n    static new(dns_name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(dns_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.dnsrecordsrv_new(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DNSRecordSRV.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    record() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordaoraaaa_record(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n/**\n*/\nclass DRep {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(DRep.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_drep_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.drep_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {DRep}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.drep_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DRep.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.drep_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {DRep}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.drep_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DRep.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.drep_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.drep_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {DRep}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.drep_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DRep.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Ed25519KeyHash} key_hash\n    * @returns {DRep}\n    */\n    static new_key_hash(key_hash) {\n        _assertClass(key_hash, Ed25519KeyHash);\n        const ret = wasm.credential_from_keyhash(key_hash.__wbg_ptr);\n        return DRep.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} script_hash\n    * @returns {DRep}\n    */\n    static new_script_hash(script_hash) {\n        _assertClass(script_hash, ScriptHash);\n        const ret = wasm.credential_from_scripthash(script_hash.__wbg_ptr);\n        return DRep.__wrap(ret);\n    }\n    /**\n    * @returns {DRep}\n    */\n    static new_always_abstain() {\n        const ret = wasm.drep_new_always_abstain();\n        return DRep.__wrap(ret);\n    }\n    /**\n    * @returns {DRep}\n    */\n    static new_always_no_confidence() {\n        const ret = wasm.drep_new_always_no_confidence();\n        return DRep.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        const ret = wasm.drep_kind(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Ed25519KeyHash | undefined}\n    */\n    to_key_hash() {\n        const ret = wasm.drep_to_key_hash(this.__wbg_ptr);\n        return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptHash | undefined}\n    */\n    to_script_hash() {\n        const ret = wasm.drep_to_script_hash(this.__wbg_ptr);\n        return ret === 0 ? undefined : ScriptHash.__wrap(ret);\n    }\n}\n/**\n*/\nclass DataCost {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(DataCost.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_datacost_free(ptr);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Since babbage era we should use coins per byte. Use `.new_coins_per_byte` instead.\n    * @param {BigNum} coins_per_word\n    * @returns {DataCost}\n    */\n    static new_coins_per_word(coins_per_word) {\n        _assertClass(coins_per_word, BigNum);\n        const ret = wasm.datacost_new_coins_per_word(coins_per_word.__wbg_ptr);\n        return DataCost.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coins_per_byte\n    * @returns {DataCost}\n    */\n    static new_coins_per_byte(coins_per_byte) {\n        _assertClass(coins_per_byte, BigNum);\n        const ret = wasm.datacost_new_coins_per_byte(coins_per_byte.__wbg_ptr);\n        return DataCost.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    coins_per_byte() {\n        const ret = wasm.datacost_coins_per_byte(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n}\n/**\n*/\nclass DataHash {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(DataHash.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_datahash_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {DataHash}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.datahash_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DataHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchordatahash_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.anchordatahash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {DataHash}\n    */\n    static from_bech32(bech_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.datahash_from_bech32(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DataHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchordatahash_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {DataHash}\n    */\n    static from_hex(hex) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.datahash_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DataHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass DatumSource {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(DatumSource.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_datumsource_free(ptr);\n    }\n    /**\n    * @param {PlutusData} datum\n    * @returns {DatumSource}\n    */\n    static new(datum) {\n        _assertClass(datum, PlutusData);\n        const ret = wasm.datumsource_new(datum.__wbg_ptr);\n        return DatumSource.__wrap(ret);\n    }\n    /**\n    * @param {TransactionInput} input\n    * @returns {DatumSource}\n    */\n    static new_ref_input(input) {\n        _assertClass(input, TransactionInput);\n        const ret = wasm.datumsource_new_ref_input(input.__wbg_ptr);\n        return DatumSource.__wrap(ret);\n    }\n}\n/**\n*/\nclass DrepDeregistration {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(DrepDeregistration.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_drepderegistration_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.drepderegistration_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {DrepDeregistration}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.drepderegistration_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DrepDeregistration.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.drepderegistration_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {DrepDeregistration}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.drepderegistration_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DrepDeregistration.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.drepderegistration_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.drepderegistration_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {DrepDeregistration}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.drepderegistration_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DrepDeregistration.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Credential}\n    */\n    voting_credential() {\n        const ret = wasm.drepderegistration_voting_credential(this.__wbg_ptr);\n        return Credential.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    coin() {\n        const ret = wasm.drepderegistration_coin(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {Credential} voting_credential\n    * @param {BigNum} coin\n    * @returns {DrepDeregistration}\n    */\n    static new(voting_credential, coin) {\n        _assertClass(voting_credential, Credential);\n        _assertClass(coin, BigNum);\n        const ret = wasm.drepderegistration_new(voting_credential.__wbg_ptr, coin.__wbg_ptr);\n        return DrepDeregistration.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_script_credentials() {\n        const ret = wasm.drepderegistration_has_script_credentials(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nclass DrepRegistration {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(DrepRegistration.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_drepregistration_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.drepregistration_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {DrepRegistration}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.drepregistration_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DrepRegistration.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.drepregistration_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {DrepRegistration}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.drepregistration_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DrepRegistration.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.drepregistration_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.drepregistration_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {DrepRegistration}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.drepregistration_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DrepRegistration.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Credential}\n    */\n    voting_credential() {\n        const ret = wasm.drepregistration_voting_credential(this.__wbg_ptr);\n        return Credential.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    coin() {\n        const ret = wasm.drepregistration_coin(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {Anchor | undefined}\n    */\n    anchor() {\n        const ret = wasm.drepregistration_anchor(this.__wbg_ptr);\n        return ret === 0 ? undefined : Anchor.__wrap(ret);\n    }\n    /**\n    * @param {Credential} voting_credential\n    * @param {BigNum} coin\n    * @returns {DrepRegistration}\n    */\n    static new(voting_credential, coin) {\n        _assertClass(voting_credential, Credential);\n        _assertClass(coin, BigNum);\n        const ret = wasm.drepregistration_new(voting_credential.__wbg_ptr, coin.__wbg_ptr);\n        return DrepRegistration.__wrap(ret);\n    }\n    /**\n    * @param {Credential} voting_credential\n    * @param {BigNum} coin\n    * @param {Anchor} anchor\n    * @returns {DrepRegistration}\n    */\n    static new_with_anchor(voting_credential, coin, anchor) {\n        _assertClass(voting_credential, Credential);\n        _assertClass(coin, BigNum);\n        _assertClass(anchor, Anchor);\n        const ret = wasm.drepregistration_new_with_anchor(voting_credential.__wbg_ptr, coin.__wbg_ptr, anchor.__wbg_ptr);\n        return DrepRegistration.__wrap(ret);\n    }\n}\n/**\n*/\nclass DrepUpdate {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(DrepUpdate.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_drepupdate_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.drepupdate_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {DrepUpdate}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.drepupdate_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DrepUpdate.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.drepupdate_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {DrepUpdate}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.drepupdate_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DrepUpdate.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.drepupdate_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.drepupdate_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {DrepUpdate}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.drepupdate_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DrepUpdate.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Credential}\n    */\n    voting_credential() {\n        const ret = wasm.drepupdate_voting_credential(this.__wbg_ptr);\n        return Credential.__wrap(ret);\n    }\n    /**\n    * @returns {Anchor | undefined}\n    */\n    anchor() {\n        const ret = wasm.drepupdate_anchor(this.__wbg_ptr);\n        return ret === 0 ? undefined : Anchor.__wrap(ret);\n    }\n    /**\n    * @param {Credential} voting_credential\n    * @returns {DrepUpdate}\n    */\n    static new(voting_credential) {\n        _assertClass(voting_credential, Credential);\n        const ret = wasm.drepupdate_new(voting_credential.__wbg_ptr);\n        return DrepUpdate.__wrap(ret);\n    }\n    /**\n    * @param {Credential} voting_credential\n    * @param {Anchor} anchor\n    * @returns {DrepUpdate}\n    */\n    static new_with_anchor(voting_credential, anchor) {\n        _assertClass(voting_credential, Credential);\n        _assertClass(anchor, Anchor);\n        const ret = wasm.drepupdate_new_with_anchor(voting_credential.__wbg_ptr, anchor.__wbg_ptr);\n        return DrepUpdate.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_script_credentials() {\n        const ret = wasm.drepupdate_has_script_credentials(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nclass DrepVotingThresholds {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(DrepVotingThresholds.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_drepvotingthresholds_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.drepvotingthresholds_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {DrepVotingThresholds}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.drepvotingthresholds_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DrepVotingThresholds.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.drepvotingthresholds_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {DrepVotingThresholds}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.drepvotingthresholds_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DrepVotingThresholds.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.drepvotingthresholds_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.drepvotingthresholds_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {DrepVotingThresholds}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.drepvotingthresholds_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DrepVotingThresholds.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {UnitInterval} motion_no_confidence\n    * @param {UnitInterval} committee_normal\n    * @param {UnitInterval} committee_no_confidence\n    * @param {UnitInterval} update_constitution\n    * @param {UnitInterval} hard_fork_initiation\n    * @param {UnitInterval} pp_network_group\n    * @param {UnitInterval} pp_economic_group\n    * @param {UnitInterval} pp_technical_group\n    * @param {UnitInterval} pp_governance_group\n    * @param {UnitInterval} treasury_withdrawal\n    * @returns {DrepVotingThresholds}\n    */\n    static new(motion_no_confidence, committee_normal, committee_no_confidence, update_constitution, hard_fork_initiation, pp_network_group, pp_economic_group, pp_technical_group, pp_governance_group, treasury_withdrawal) {\n        _assertClass(motion_no_confidence, UnitInterval);\n        _assertClass(committee_normal, UnitInterval);\n        _assertClass(committee_no_confidence, UnitInterval);\n        _assertClass(update_constitution, UnitInterval);\n        _assertClass(hard_fork_initiation, UnitInterval);\n        _assertClass(pp_network_group, UnitInterval);\n        _assertClass(pp_economic_group, UnitInterval);\n        _assertClass(pp_technical_group, UnitInterval);\n        _assertClass(pp_governance_group, UnitInterval);\n        _assertClass(treasury_withdrawal, UnitInterval);\n        const ret = wasm.drepvotingthresholds_new(motion_no_confidence.__wbg_ptr, committee_normal.__wbg_ptr, committee_no_confidence.__wbg_ptr, update_constitution.__wbg_ptr, hard_fork_initiation.__wbg_ptr, pp_network_group.__wbg_ptr, pp_economic_group.__wbg_ptr, pp_technical_group.__wbg_ptr, pp_governance_group.__wbg_ptr, treasury_withdrawal.__wbg_ptr);\n        return DrepVotingThresholds.__wrap(ret);\n    }\n    /**\n    * @returns {DrepVotingThresholds}\n    */\n    static new_default() {\n        const ret = wasm.drepvotingthresholds_new_default();\n        return DrepVotingThresholds.__wrap(ret);\n    }\n    /**\n    * @param {UnitInterval} motion_no_confidence\n    */\n    set_motion_no_confidence(motion_no_confidence) {\n        _assertClass(motion_no_confidence, UnitInterval);\n        wasm.drepvotingthresholds_set_motion_no_confidence(this.__wbg_ptr, motion_no_confidence.__wbg_ptr);\n    }\n    /**\n    * @param {UnitInterval} committee_normal\n    */\n    set_committee_normal(committee_normal) {\n        _assertClass(committee_normal, UnitInterval);\n        wasm.drepvotingthresholds_set_committee_normal(this.__wbg_ptr, committee_normal.__wbg_ptr);\n    }\n    /**\n    * @param {UnitInterval} committee_no_confidence\n    */\n    set_committee_no_confidence(committee_no_confidence) {\n        _assertClass(committee_no_confidence, UnitInterval);\n        wasm.drepvotingthresholds_set_committee_no_confidence(this.__wbg_ptr, committee_no_confidence.__wbg_ptr);\n    }\n    /**\n    * @param {UnitInterval} update_constitution\n    */\n    set_update_constitution(update_constitution) {\n        _assertClass(update_constitution, UnitInterval);\n        wasm.drepvotingthresholds_set_update_constitution(this.__wbg_ptr, update_constitution.__wbg_ptr);\n    }\n    /**\n    * @param {UnitInterval} hard_fork_initiation\n    */\n    set_hard_fork_initiation(hard_fork_initiation) {\n        _assertClass(hard_fork_initiation, UnitInterval);\n        wasm.drepvotingthresholds_set_hard_fork_initiation(this.__wbg_ptr, hard_fork_initiation.__wbg_ptr);\n    }\n    /**\n    * @param {UnitInterval} pp_network_group\n    */\n    set_pp_network_group(pp_network_group) {\n        _assertClass(pp_network_group, UnitInterval);\n        wasm.drepvotingthresholds_set_pp_network_group(this.__wbg_ptr, pp_network_group.__wbg_ptr);\n    }\n    /**\n    * @param {UnitInterval} pp_economic_group\n    */\n    set_pp_economic_group(pp_economic_group) {\n        _assertClass(pp_economic_group, UnitInterval);\n        wasm.drepvotingthresholds_set_pp_economic_group(this.__wbg_ptr, pp_economic_group.__wbg_ptr);\n    }\n    /**\n    * @param {UnitInterval} pp_technical_group\n    */\n    set_pp_technical_group(pp_technical_group) {\n        _assertClass(pp_technical_group, UnitInterval);\n        wasm.drepvotingthresholds_set_pp_technical_group(this.__wbg_ptr, pp_technical_group.__wbg_ptr);\n    }\n    /**\n    * @param {UnitInterval} pp_governance_group\n    */\n    set_pp_governance_group(pp_governance_group) {\n        _assertClass(pp_governance_group, UnitInterval);\n        wasm.drepvotingthresholds_set_pp_governance_group(this.__wbg_ptr, pp_governance_group.__wbg_ptr);\n    }\n    /**\n    * @param {UnitInterval} treasury_withdrawal\n    */\n    set_treasury_withdrawal(treasury_withdrawal) {\n        _assertClass(treasury_withdrawal, UnitInterval);\n        wasm.drepvotingthresholds_set_treasury_withdrawal(this.__wbg_ptr, treasury_withdrawal.__wbg_ptr);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    motion_no_confidence() {\n        const ret = wasm.drepvotingthresholds_motion_no_confidence(this.__wbg_ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    committee_normal() {\n        const ret = wasm.drepvotingthresholds_committee_normal(this.__wbg_ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    committee_no_confidence() {\n        const ret = wasm.drepvotingthresholds_committee_no_confidence(this.__wbg_ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    update_constitution() {\n        const ret = wasm.drepvotingthresholds_update_constitution(this.__wbg_ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    hard_fork_initiation() {\n        const ret = wasm.drepvotingthresholds_hard_fork_initiation(this.__wbg_ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    pp_network_group() {\n        const ret = wasm.drepvotingthresholds_pp_network_group(this.__wbg_ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    pp_economic_group() {\n        const ret = wasm.drepvotingthresholds_pp_economic_group(this.__wbg_ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    pp_technical_group() {\n        const ret = wasm.drepvotingthresholds_pp_technical_group(this.__wbg_ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    pp_governance_group() {\n        const ret = wasm.drepvotingthresholds_pp_governance_group(this.__wbg_ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    treasury_withdrawal() {\n        const ret = wasm.drepvotingthresholds_treasury_withdrawal(this.__wbg_ptr);\n        return UnitInterval.__wrap(ret);\n    }\n}\n/**\n*/\nclass Ed25519KeyHash {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Ed25519KeyHash.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ed25519keyhash_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ed25519KeyHash}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ed25519keyhash_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ed25519KeyHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519keyhash_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ed25519keyhash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {Ed25519KeyHash}\n    */\n    static from_bech32(bech_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ed25519keyhash_from_bech32(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ed25519KeyHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519keyhash_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {Ed25519KeyHash}\n    */\n    static from_hex(hex) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ed25519keyhash_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ed25519KeyHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass Ed25519KeyHashes {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Ed25519KeyHashes.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ed25519keyhashes_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519keyhashes_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ed25519KeyHashes}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ed25519keyhashes_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ed25519KeyHashes.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519keyhashes_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Ed25519KeyHashes}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ed25519keyhashes_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ed25519KeyHashes.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519keyhashes_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519keyhashes_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Ed25519KeyHashes}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ed25519keyhashes_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ed25519KeyHashes.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Ed25519KeyHashes}\n    */\n    static new() {\n        const ret = wasm.credentials_new();\n        return Ed25519KeyHashes.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.assetnames_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Ed25519KeyHash}\n    */\n    get(index) {\n        const ret = wasm.ed25519keyhashes_get(this.__wbg_ptr, index);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @param {Ed25519KeyHash} elem\n    */\n    add(elem) {\n        _assertClass(elem, Ed25519KeyHash);\n        wasm.ed25519keyhashes_add(this.__wbg_ptr, elem.__wbg_ptr);\n    }\n    /**\n    * @returns {Ed25519KeyHashes | undefined}\n    */\n    to_option() {\n        const ret = wasm.ed25519keyhashes_to_option(this.__wbg_ptr);\n        return ret === 0 ? undefined : Ed25519KeyHashes.__wrap(ret);\n    }\n}\n/**\n*/\nclass Ed25519Signature {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Ed25519Signature.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ed25519signature_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519signature_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519signature_to_bech32(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519signature_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} bech32_str\n    * @returns {Ed25519Signature}\n    */\n    static from_bech32(bech32_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ed25519signature_from_bech32(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ed25519Signature.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} input\n    * @returns {Ed25519Signature}\n    */\n    static from_hex(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ed25519signature_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ed25519Signature.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ed25519Signature}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ed25519signature_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ed25519Signature.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass EnterpriseAddress {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(EnterpriseAddress.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_enterpriseaddress_free(ptr);\n    }\n    /**\n    * @param {number} network\n    * @param {Credential} payment\n    * @returns {EnterpriseAddress}\n    */\n    static new(network, payment) {\n        _assertClass(payment, Credential);\n        const ret = wasm.enterpriseaddress_new(network, payment.__wbg_ptr);\n        return EnterpriseAddress.__wrap(ret);\n    }\n    /**\n    * @returns {Credential}\n    */\n    payment_cred() {\n        const ret = wasm.baseaddress_payment_cred(this.__wbg_ptr);\n        return Credential.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        const ret = wasm.enterpriseaddress_to_address(this.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {EnterpriseAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        const ret = wasm.enterpriseaddress_from_address(addr.__wbg_ptr);\n        return ret === 0 ? undefined : EnterpriseAddress.__wrap(ret);\n    }\n}\n/**\n*/\nclass ExUnitPrices {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ExUnitPrices.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_exunitprices_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.exunitprices_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ExUnitPrices}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.exunitprices_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExUnitPrices.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.exunitprices_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ExUnitPrices}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.exunitprices_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExUnitPrices.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.exunitprices_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.exunitprices_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {ExUnitPrices}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.exunitprices_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExUnitPrices.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    mem_price() {\n        const ret = wasm.exunitprices_mem_price(this.__wbg_ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    step_price() {\n        const ret = wasm.exunitprices_step_price(this.__wbg_ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @param {UnitInterval} mem_price\n    * @param {UnitInterval} step_price\n    * @returns {ExUnitPrices}\n    */\n    static new(mem_price, step_price) {\n        _assertClass(mem_price, UnitInterval);\n        _assertClass(step_price, UnitInterval);\n        const ret = wasm.exunitprices_new(mem_price.__wbg_ptr, step_price.__wbg_ptr);\n        return ExUnitPrices.__wrap(ret);\n    }\n}\n/**\n*/\nclass ExUnits {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ExUnits.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_exunits_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.exunits_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ExUnits}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.exunits_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExUnits.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.exunits_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ExUnits}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.exunits_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExUnits.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.exunits_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.exunits_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {ExUnits}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.exunits_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExUnits.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {BigNum}\n    */\n    mem() {\n        const ret = wasm.exunits_mem(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    steps() {\n        const ret = wasm.exunits_steps(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} mem\n    * @param {BigNum} steps\n    * @returns {ExUnits}\n    */\n    static new(mem, steps) {\n        _assertClass(mem, BigNum);\n        _assertClass(steps, BigNum);\n        const ret = wasm.exunits_new(mem.__wbg_ptr, steps.__wbg_ptr);\n        return ExUnits.__wrap(ret);\n    }\n}\n/**\n*/\nclass FixedTransaction {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FixedTransaction.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_fixedtransaction_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.fixedtransaction_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {FixedTransaction}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.fixedtransaction_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return FixedTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.fixedtransaction_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {FixedTransaction}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.fixedtransaction_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return FixedTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} raw_body\n    * @param {Uint8Array} raw_witness_set\n    * @param {boolean} is_valid\n    * @returns {FixedTransaction}\n    */\n    static new(raw_body, raw_witness_set, is_valid) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(raw_body, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passArray8ToWasm0(raw_witness_set, wasm.__wbindgen_malloc);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.fixedtransaction_new(retptr, ptr0, len0, ptr1, len1, is_valid);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return FixedTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} raw_body\n    * @param {Uint8Array} raw_witness_set\n    * @param {Uint8Array} raw_auxiliary_data\n    * @param {boolean} is_valid\n    * @returns {FixedTransaction}\n    */\n    static new_with_auxiliary(raw_body, raw_witness_set, raw_auxiliary_data, is_valid) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(raw_body, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passArray8ToWasm0(raw_witness_set, wasm.__wbindgen_malloc);\n            const len1 = WASM_VECTOR_LEN;\n            const ptr2 = passArray8ToWasm0(raw_auxiliary_data, wasm.__wbindgen_malloc);\n            const len2 = WASM_VECTOR_LEN;\n            wasm.fixedtransaction_new_with_auxiliary(retptr, ptr0, len0, ptr1, len1, ptr2, len2, is_valid);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return FixedTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {TransactionBody}\n    */\n    body() {\n        const ret = wasm.fixedtransaction_body(this.__wbg_ptr);\n        return TransactionBody.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    raw_body() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.fixedtransaction_raw_body(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} raw_body\n    */\n    set_body(raw_body) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(raw_body, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.fixedtransaction_set_body(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} raw_witness_set\n    */\n    set_witness_set(raw_witness_set) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(raw_witness_set, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.fixedtransaction_set_witness_set(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {TransactionWitnessSet}\n    */\n    witness_set() {\n        const ret = wasm.fixedtransaction_witness_set(this.__wbg_ptr);\n        return TransactionWitnessSet.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    raw_witness_set() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.fixedtransaction_raw_witness_set(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {boolean} valid\n    */\n    set_is_valid(valid) {\n        wasm.fixedtransaction_set_is_valid(this.__wbg_ptr, valid);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_valid() {\n        const ret = wasm.fixedtransaction_is_valid(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {Uint8Array} raw_auxiliary_data\n    */\n    set_auxiliary_data(raw_auxiliary_data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(raw_auxiliary_data, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.fixedtransaction_set_auxiliary_data(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {AuxiliaryData | undefined}\n    */\n    auxiliary_data() {\n        const ret = wasm.fixedtransaction_auxiliary_data(this.__wbg_ptr);\n        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    raw_auxiliary_data() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.fixedtransaction_raw_auxiliary_data(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass GeneralTransactionMetadata {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(GeneralTransactionMetadata.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_generaltransactionmetadata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.generaltransactionmetadata_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GeneralTransactionMetadata}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.generaltransactionmetadata_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return GeneralTransactionMetadata.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.generaltransactionmetadata_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {GeneralTransactionMetadata}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.generaltransactionmetadata_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return GeneralTransactionMetadata.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.generaltransactionmetadata_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.generaltransactionmetadata_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {GeneralTransactionMetadata}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.generaltransactionmetadata_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return GeneralTransactionMetadata.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {GeneralTransactionMetadata}\n    */\n    static new() {\n        const ret = wasm.generaltransactionmetadata_new();\n        return GeneralTransactionMetadata.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.generaltransactionmetadata_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {BigNum} key\n    * @param {TransactionMetadatum} value\n    * @returns {TransactionMetadatum | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, BigNum);\n        _assertClass(value, TransactionMetadatum);\n        const ret = wasm.generaltransactionmetadata_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} key\n    * @returns {TransactionMetadatum | undefined}\n    */\n    get(key) {\n        _assertClass(key, BigNum);\n        const ret = wasm.generaltransactionmetadata_get(this.__wbg_ptr, key.__wbg_ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionMetadatumLabels}\n    */\n    keys() {\n        const ret = wasm.generaltransactionmetadata_keys(this.__wbg_ptr);\n        return TransactionMetadatumLabels.__wrap(ret);\n    }\n}\n/**\n*/\nclass GenesisDelegateHash {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(GenesisDelegateHash.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_genesisdelegatehash_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GenesisDelegateHash}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.genesisdelegatehash_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return GenesisDelegateHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519keyhash_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ed25519keyhash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {GenesisDelegateHash}\n    */\n    static from_bech32(bech_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.genesisdelegatehash_from_bech32(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return GenesisDelegateHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519keyhash_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {GenesisDelegateHash}\n    */\n    static from_hex(hex) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.genesisdelegatehash_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return GenesisDelegateHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass GenesisHash {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(GenesisHash.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_genesishash_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GenesisHash}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.genesishash_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return GenesisHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519keyhash_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ed25519keyhash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {GenesisHash}\n    */\n    static from_bech32(bech_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.genesishash_from_bech32(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return GenesisHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519keyhash_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {GenesisHash}\n    */\n    static from_hex(hex) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.genesishash_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return GenesisHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass GenesisHashes {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(GenesisHashes.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_genesishashes_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesishashes_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GenesisHashes}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.genesishashes_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return GenesisHashes.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesishashes_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {GenesisHashes}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.genesishashes_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return GenesisHashes.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesishashes_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesishashes_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {GenesisHashes}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.genesishashes_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return GenesisHashes.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {GenesisHashes}\n    */\n    static new() {\n        const ret = wasm.credentials_new();\n        return GenesisHashes.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.assetnames_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {GenesisHash}\n    */\n    get(index) {\n        const ret = wasm.genesishashes_get(this.__wbg_ptr, index);\n        return GenesisHash.__wrap(ret);\n    }\n    /**\n    * @param {GenesisHash} elem\n    */\n    add(elem) {\n        _assertClass(elem, GenesisHash);\n        wasm.genesishashes_add(this.__wbg_ptr, elem.__wbg_ptr);\n    }\n}\n/**\n*/\nclass GenesisKeyDelegation {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(GenesisKeyDelegation.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_genesiskeydelegation_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesiskeydelegation_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GenesisKeyDelegation}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.genesiskeydelegation_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return GenesisKeyDelegation.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesiskeydelegation_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {GenesisKeyDelegation}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.genesiskeydelegation_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return GenesisKeyDelegation.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesiskeydelegation_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesiskeydelegation_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {GenesisKeyDelegation}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.genesiskeydelegation_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return GenesisKeyDelegation.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {GenesisHash}\n    */\n    genesishash() {\n        const ret = wasm.genesiskeydelegation_genesishash(this.__wbg_ptr);\n        return GenesisHash.__wrap(ret);\n    }\n    /**\n    * @returns {GenesisDelegateHash}\n    */\n    genesis_delegate_hash() {\n        const ret = wasm.genesiskeydelegation_genesis_delegate_hash(this.__wbg_ptr);\n        return GenesisDelegateHash.__wrap(ret);\n    }\n    /**\n    * @returns {VRFKeyHash}\n    */\n    vrf_keyhash() {\n        const ret = wasm.genesiskeydelegation_vrf_keyhash(this.__wbg_ptr);\n        return VRFKeyHash.__wrap(ret);\n    }\n    /**\n    * @param {GenesisHash} genesishash\n    * @param {GenesisDelegateHash} genesis_delegate_hash\n    * @param {VRFKeyHash} vrf_keyhash\n    * @returns {GenesisKeyDelegation}\n    */\n    static new(genesishash, genesis_delegate_hash, vrf_keyhash) {\n        _assertClass(genesishash, GenesisHash);\n        _assertClass(genesis_delegate_hash, GenesisDelegateHash);\n        _assertClass(vrf_keyhash, VRFKeyHash);\n        const ret = wasm.genesiskeydelegation_new(genesishash.__wbg_ptr, genesis_delegate_hash.__wbg_ptr, vrf_keyhash.__wbg_ptr);\n        return GenesisKeyDelegation.__wrap(ret);\n    }\n}\n/**\n*/\nclass GovernanceActionId {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(GovernanceActionId.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_governanceactionid_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.governanceactionid_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GovernanceActionId}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.governanceactionid_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return GovernanceActionId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.governanceactionid_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {GovernanceActionId}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.governanceactionid_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return GovernanceActionId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.governanceactionid_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.governanceactionid_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {GovernanceActionId}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.governanceactionid_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return GovernanceActionId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {TransactionHash}\n    */\n    transaction_id() {\n        const ret = wasm.governanceactionid_transaction_id(this.__wbg_ptr);\n        return TransactionHash.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    index() {\n        const ret = wasm.governanceactionid_index(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {TransactionHash} transaction_id\n    * @param {number} index\n    * @returns {GovernanceActionId}\n    */\n    static new(transaction_id, index) {\n        _assertClass(transaction_id, TransactionHash);\n        const ret = wasm.governanceactionid_new(transaction_id.__wbg_ptr, index);\n        return GovernanceActionId.__wrap(ret);\n    }\n}\n/**\n*/\nclass GovernanceActionIds {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(GovernanceActionIds.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_governanceactionids_free(ptr);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.governanceactionids_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.governanceactionids_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {GovernanceActionIds}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.governanceactionids_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return GovernanceActionIds.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {GovernanceActionIds}\n    */\n    static new() {\n        const ret = wasm.governanceactionids_new();\n        return GovernanceActionIds.__wrap(ret);\n    }\n    /**\n    * @param {GovernanceActionId} governance_action_id\n    */\n    add(governance_action_id) {\n        _assertClass(governance_action_id, GovernanceActionId);\n        wasm.governanceactionids_add(this.__wbg_ptr, governance_action_id.__wbg_ptr);\n    }\n    /**\n    * @param {number} index\n    * @returns {GovernanceActionId | undefined}\n    */\n    get(index) {\n        const ret = wasm.governanceactionids_get(this.__wbg_ptr, index);\n        return ret === 0 ? undefined : GovernanceActionId.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.governanceactionids_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nclass HardForkInitiationProposal {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(HardForkInitiationProposal.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_hardforkinitiationproposal_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.hardforkinitiationproposal_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {HardForkInitiationProposal}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.hardforkinitiationproposal_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return HardForkInitiationProposal.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.hardforkinitiationproposal_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {HardForkInitiationProposal}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.hardforkinitiationproposal_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return HardForkInitiationProposal.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.hardforkinitiationproposal_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.hardforkinitiationproposal_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {HardForkInitiationProposal}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.hardforkinitiationproposal_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return HardForkInitiationProposal.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {GovernanceActionId | undefined}\n    */\n    gov_action_id() {\n        const ret = wasm.hardforkinitiationproposal_gov_action_id(this.__wbg_ptr);\n        return ret === 0 ? undefined : GovernanceActionId.__wrap(ret);\n    }\n    /**\n    * @returns {ProtocolVersion}\n    */\n    protocol_version() {\n        const ret = wasm.hardforkinitiationproposal_protocol_version(this.__wbg_ptr);\n        return ProtocolVersion.__wrap(ret);\n    }\n    /**\n    * @param {ProtocolVersion} protocol_version\n    * @returns {HardForkInitiationProposal}\n    */\n    static new(protocol_version) {\n        _assertClass(protocol_version, ProtocolVersion);\n        const ret = wasm.hardforkinitiationproposal_new(protocol_version.__wbg_ptr);\n        return HardForkInitiationProposal.__wrap(ret);\n    }\n    /**\n    * @param {GovernanceActionId} gov_action_id\n    * @param {ProtocolVersion} protocol_version\n    * @returns {HardForkInitiationProposal}\n    */\n    static new_with_action_id(gov_action_id, protocol_version) {\n        _assertClass(gov_action_id, GovernanceActionId);\n        _assertClass(protocol_version, ProtocolVersion);\n        const ret = wasm.hardforkinitiationproposal_new_with_action_id(gov_action_id.__wbg_ptr, protocol_version.__wbg_ptr);\n        return HardForkInitiationProposal.__wrap(ret);\n    }\n}\n/**\n*/\nclass Header {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Header.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_header_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.header_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Header}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.header_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Header.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.header_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Header}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.header_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Header.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.header_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.header_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Header}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.header_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Header.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {HeaderBody}\n    */\n    header_body() {\n        const ret = wasm.header_header_body(this.__wbg_ptr);\n        return HeaderBody.__wrap(ret);\n    }\n    /**\n    * @returns {KESSignature}\n    */\n    body_signature() {\n        const ret = wasm.header_body_signature(this.__wbg_ptr);\n        return KESSignature.__wrap(ret);\n    }\n    /**\n    * @param {HeaderBody} header_body\n    * @param {KESSignature} body_signature\n    * @returns {Header}\n    */\n    static new(header_body, body_signature) {\n        _assertClass(header_body, HeaderBody);\n        _assertClass(body_signature, KESSignature);\n        const ret = wasm.header_new(header_body.__wbg_ptr, body_signature.__wbg_ptr);\n        return Header.__wrap(ret);\n    }\n}\n/**\n*/\nclass HeaderBody {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(HeaderBody.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_headerbody_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headerbody_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {HeaderBody}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.headerbody_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return HeaderBody.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headerbody_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {HeaderBody}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.headerbody_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return HeaderBody.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headerbody_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headerbody_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {HeaderBody}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.headerbody_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return HeaderBody.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number}\n    */\n    block_number() {\n        const ret = wasm.headerbody_block_number(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Returns a Slot32 (u32) value in case the underlying original BigNum (u64) value is within the limits.\n    * Otherwise will just raise an error.\n    * @returns {number}\n    */\n    slot() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headerbody_slot(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {BigNum}\n    */\n    slot_bignum() {\n        const ret = wasm.headerbody_slot_bignum(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BlockHash | undefined}\n    */\n    prev_hash() {\n        const ret = wasm.headerbody_prev_hash(this.__wbg_ptr);\n        return ret === 0 ? undefined : BlockHash.__wrap(ret);\n    }\n    /**\n    * @returns {Vkey}\n    */\n    issuer_vkey() {\n        const ret = wasm.headerbody_issuer_vkey(this.__wbg_ptr);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @returns {VRFVKey}\n    */\n    vrf_vkey() {\n        const ret = wasm.headerbody_vrf_vkey(this.__wbg_ptr);\n        return VRFVKey.__wrap(ret);\n    }\n    /**\n    * If this function returns true, the `.nonce_vrf_or_nothing`\n    * and the `.leader_vrf_or_nothing` functions will return\n    * non-empty results\n    * @returns {boolean}\n    */\n    has_nonce_and_leader_vrf() {\n        const ret = wasm.headerbody_has_nonce_and_leader_vrf(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Might return nothing in case `.has_nonce_and_leader_vrf` returns false\n    * @returns {VRFCert | undefined}\n    */\n    nonce_vrf_or_nothing() {\n        const ret = wasm.headerbody_nonce_vrf_or_nothing(this.__wbg_ptr);\n        return ret === 0 ? undefined : VRFCert.__wrap(ret);\n    }\n    /**\n    * Might return nothing in case `.has_nonce_and_leader_vrf` returns false\n    * @returns {VRFCert | undefined}\n    */\n    leader_vrf_or_nothing() {\n        const ret = wasm.headerbody_leader_vrf_or_nothing(this.__wbg_ptr);\n        return ret === 0 ? undefined : VRFCert.__wrap(ret);\n    }\n    /**\n    * If this function returns true, the `.vrf_result_or_nothing`\n    * function will return a non-empty result\n    * @returns {boolean}\n    */\n    has_vrf_result() {\n        const ret = wasm.headerbody_has_vrf_result(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Might return nothing in case `.has_vrf_result` returns false\n    * @returns {VRFCert | undefined}\n    */\n    vrf_result_or_nothing() {\n        const ret = wasm.headerbody_vrf_result_or_nothing(this.__wbg_ptr);\n        return ret === 0 ? undefined : VRFCert.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    block_body_size() {\n        const ret = wasm.headerbody_block_body_size(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {BlockHash}\n    */\n    block_body_hash() {\n        const ret = wasm.headerbody_block_body_hash(this.__wbg_ptr);\n        return BlockHash.__wrap(ret);\n    }\n    /**\n    * @returns {OperationalCert}\n    */\n    operational_cert() {\n        const ret = wasm.headerbody_operational_cert(this.__wbg_ptr);\n        return OperationalCert.__wrap(ret);\n    }\n    /**\n    * @returns {ProtocolVersion}\n    */\n    protocol_version() {\n        const ret = wasm.headerbody_protocol_version(this.__wbg_ptr);\n        return ProtocolVersion.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * This constructor uses outdated slot number format.\n    * Use `.new_headerbody` instead\n    * @param {number} block_number\n    * @param {number} slot\n    * @param {BlockHash | undefined} prev_hash\n    * @param {Vkey} issuer_vkey\n    * @param {VRFVKey} vrf_vkey\n    * @param {VRFCert} vrf_result\n    * @param {number} block_body_size\n    * @param {BlockHash} block_body_hash\n    * @param {OperationalCert} operational_cert\n    * @param {ProtocolVersion} protocol_version\n    * @returns {HeaderBody}\n    */\n    static new(block_number, slot, prev_hash, issuer_vkey, vrf_vkey, vrf_result, block_body_size, block_body_hash, operational_cert, protocol_version) {\n        let ptr0 = 0;\n        if (!isLikeNone(prev_hash)) {\n            _assertClass(prev_hash, BlockHash);\n            ptr0 = prev_hash.__destroy_into_raw();\n        }\n        _assertClass(issuer_vkey, Vkey);\n        _assertClass(vrf_vkey, VRFVKey);\n        _assertClass(vrf_result, VRFCert);\n        _assertClass(block_body_hash, BlockHash);\n        _assertClass(operational_cert, OperationalCert);\n        _assertClass(protocol_version, ProtocolVersion);\n        const ret = wasm.headerbody_new(block_number, slot, ptr0, issuer_vkey.__wbg_ptr, vrf_vkey.__wbg_ptr, vrf_result.__wbg_ptr, block_body_size, block_body_hash.__wbg_ptr, operational_cert.__wbg_ptr, protocol_version.__wbg_ptr);\n        return HeaderBody.__wrap(ret);\n    }\n    /**\n    * @param {number} block_number\n    * @param {BigNum} slot\n    * @param {BlockHash | undefined} prev_hash\n    * @param {Vkey} issuer_vkey\n    * @param {VRFVKey} vrf_vkey\n    * @param {VRFCert} vrf_result\n    * @param {number} block_body_size\n    * @param {BlockHash} block_body_hash\n    * @param {OperationalCert} operational_cert\n    * @param {ProtocolVersion} protocol_version\n    * @returns {HeaderBody}\n    */\n    static new_headerbody(block_number, slot, prev_hash, issuer_vkey, vrf_vkey, vrf_result, block_body_size, block_body_hash, operational_cert, protocol_version) {\n        _assertClass(slot, BigNum);\n        let ptr0 = 0;\n        if (!isLikeNone(prev_hash)) {\n            _assertClass(prev_hash, BlockHash);\n            ptr0 = prev_hash.__destroy_into_raw();\n        }\n        _assertClass(issuer_vkey, Vkey);\n        _assertClass(vrf_vkey, VRFVKey);\n        _assertClass(vrf_result, VRFCert);\n        _assertClass(block_body_hash, BlockHash);\n        _assertClass(operational_cert, OperationalCert);\n        _assertClass(protocol_version, ProtocolVersion);\n        const ret = wasm.headerbody_new_headerbody(block_number, slot.__wbg_ptr, ptr0, issuer_vkey.__wbg_ptr, vrf_vkey.__wbg_ptr, vrf_result.__wbg_ptr, block_body_size, block_body_hash.__wbg_ptr, operational_cert.__wbg_ptr, protocol_version.__wbg_ptr);\n        return HeaderBody.__wrap(ret);\n    }\n}\n/**\n*/\nclass InfoProposal {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(InfoProposal.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_infoproposal_free(ptr);\n    }\n    /**\n    * @returns {InfoProposal}\n    */\n    static new() {\n        const ret = wasm.infoproposal_new();\n        return InfoProposal.__wrap(ret);\n    }\n}\n/**\n*/\nclass InputWithScriptWitness {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(InputWithScriptWitness.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_inputwithscriptwitness_free(ptr);\n    }\n    /**\n    * @param {TransactionInput} input\n    * @param {NativeScript} witness\n    * @returns {InputWithScriptWitness}\n    */\n    static new_with_native_script_witness(input, witness) {\n        _assertClass(input, TransactionInput);\n        _assertClass(witness, NativeScript);\n        const ret = wasm.inputwithscriptwitness_new_with_native_script_witness(input.__wbg_ptr, witness.__wbg_ptr);\n        return InputWithScriptWitness.__wrap(ret);\n    }\n    /**\n    * @param {TransactionInput} input\n    * @param {PlutusWitness} witness\n    * @returns {InputWithScriptWitness}\n    */\n    static new_with_plutus_witness(input, witness) {\n        _assertClass(input, TransactionInput);\n        _assertClass(witness, PlutusWitness);\n        const ret = wasm.inputwithscriptwitness_new_with_plutus_witness(input.__wbg_ptr, witness.__wbg_ptr);\n        return InputWithScriptWitness.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInput}\n    */\n    input() {\n        const ret = wasm.inputwithscriptwitness_input(this.__wbg_ptr);\n        return TransactionInput.__wrap(ret);\n    }\n}\n/**\n*/\nclass InputsWithScriptWitness {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(InputsWithScriptWitness.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_inputswithscriptwitness_free(ptr);\n    }\n    /**\n    * @returns {InputsWithScriptWitness}\n    */\n    static new() {\n        const ret = wasm.inputswithscriptwitness_new();\n        return InputsWithScriptWitness.__wrap(ret);\n    }\n    /**\n    * @param {InputWithScriptWitness} input\n    */\n    add(input) {\n        _assertClass(input, InputWithScriptWitness);\n        wasm.inputswithscriptwitness_add(this.__wbg_ptr, input.__wbg_ptr);\n    }\n    /**\n    * @param {number} index\n    * @returns {InputWithScriptWitness}\n    */\n    get(index) {\n        const ret = wasm.inputswithscriptwitness_get(this.__wbg_ptr, index);\n        return InputWithScriptWitness.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.inputswithscriptwitness_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nclass Int {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Int.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_int_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.int_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Int}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.int_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Int.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.int_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Int}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.int_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Int.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.int_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.int_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Int}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.int_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Int.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {BigNum} x\n    * @returns {Int}\n    */\n    static new(x) {\n        _assertClass(x, BigNum);\n        const ret = wasm.int_new(x.__wbg_ptr);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} x\n    * @returns {Int}\n    */\n    static new_negative(x) {\n        _assertClass(x, BigNum);\n        const ret = wasm.int_new_negative(x.__wbg_ptr);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @param {number} x\n    * @returns {Int}\n    */\n    static new_i32(x) {\n        const ret = wasm.int_new_i32(x);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_positive() {\n        const ret = wasm.int_is_positive(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * BigNum can only contain unsigned u64 values\n    *\n    * This function will return the BigNum representation\n    * only in case the underlying i128 value is positive.\n    *\n    * Otherwise nothing will be returned (undefined).\n    * @returns {BigNum | undefined}\n    */\n    as_positive() {\n        const ret = wasm.int_as_positive(this.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * BigNum can only contain unsigned u64 values\n    *\n    * This function will return the *absolute* BigNum representation\n    * only in case the underlying i128 value is negative.\n    *\n    * Otherwise nothing will be returned (undefined).\n    * @returns {BigNum | undefined}\n    */\n    as_negative() {\n        const ret = wasm.int_as_negative(this.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Returns an i32 value in case the underlying original i128 value is within the limits.\n    * Otherwise will just return an empty value (undefined).\n    * @returns {number | undefined}\n    */\n    as_i32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.int_as_i32(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the underlying value converted to i32 if possible (within limits)\n    * Otherwise will just return an empty value (undefined).\n    * @returns {number | undefined}\n    */\n    as_i32_or_nothing() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.int_as_i32(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the underlying value converted to i32 if possible (within limits)\n    * JsError in case of out of boundary overflow\n    * @returns {number}\n    */\n    as_i32_or_fail() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.int_as_i32_or_fail(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns string representation of the underlying i128 value directly.\n    * Might contain the minus sign (-) in case of negative value.\n    * @returns {string}\n    */\n    to_str() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.int_to_str(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} string\n    * @returns {Int}\n    */\n    static from_str(string) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.int_from_str(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Int.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass Ipv4 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Ipv4.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ipv4_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv4_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ipv4}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ipv4_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ipv4.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv4_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Ipv4}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ipv4_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ipv4.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv4_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv4_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Ipv4}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ipv4_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ipv4.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {Ipv4}\n    */\n    static new(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ipv4_new(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ipv4.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    ip() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv4_ip(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass Ipv6 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Ipv6.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ipv6_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv6_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ipv6}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ipv6_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ipv6.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv6_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Ipv6}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ipv6_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ipv6.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv6_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv6_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Ipv6}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ipv6_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ipv6.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {Ipv6}\n    */\n    static new(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ipv6_new(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ipv6.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    ip() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv6_ip(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass KESSignature {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(KESSignature.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_kessignature_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.kessignature_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {KESSignature}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.kessignature_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return KESSignature.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass KESVKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(KESVKey.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_kesvkey_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {KESVKey}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.kesvkey_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return KESVKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchordatahash_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.anchordatahash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {KESVKey}\n    */\n    static from_bech32(bech_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.kesvkey_from_bech32(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return KESVKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchordatahash_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {KESVKey}\n    */\n    static from_hex(hex) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.kesvkey_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return KESVKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass Language {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Language.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_language_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.language_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Language}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.language_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Language.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.language_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Language}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.language_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Language.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.language_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.language_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Language}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.language_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Language.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Language}\n    */\n    static new_plutus_v1() {\n        const ret = wasm.language_new_plutus_v1();\n        return Language.__wrap(ret);\n    }\n    /**\n    * @returns {Language}\n    */\n    static new_plutus_v2() {\n        const ret = wasm.language_new_plutus_v2();\n        return Language.__wrap(ret);\n    }\n    /**\n    * @returns {Language}\n    */\n    static new_plutus_v3() {\n        const ret = wasm.language_new_plutus_v3();\n        return Language.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        const ret = wasm.language_kind(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nclass Languages {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Languages.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_languages_free(ptr);\n    }\n    /**\n    * @returns {Languages}\n    */\n    static new() {\n        const ret = wasm.languages_new();\n        return Languages.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.costmdls_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Language}\n    */\n    get(index) {\n        const ret = wasm.languages_get(this.__wbg_ptr, index);\n        return Language.__wrap(ret);\n    }\n    /**\n    * @param {Language} elem\n    */\n    add(elem) {\n        _assertClass(elem, Language);\n        var ptr0 = elem.__destroy_into_raw();\n        wasm.languages_add(this.__wbg_ptr, ptr0);\n    }\n    /**\n    * @returns {Languages}\n    */\n    static list() {\n        const ret = wasm.languages_list();\n        return Languages.__wrap(ret);\n    }\n}\n/**\n*/\nclass LegacyDaedalusPrivateKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(LegacyDaedalusPrivateKey.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_legacydaedalusprivatekey_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {LegacyDaedalusPrivateKey}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.legacydaedalusprivatekey_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return LegacyDaedalusPrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.legacydaedalusprivatekey_as_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    chaincode() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.legacydaedalusprivatekey_chaincode(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass LinearFee {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(LinearFee.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_linearfee_free(ptr);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    constant() {\n        const ret = wasm.linearfee_constant(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    coefficient() {\n        const ret = wasm.linearfee_coefficient(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coefficient\n    * @param {BigNum} constant\n    * @returns {LinearFee}\n    */\n    static new(coefficient, constant) {\n        _assertClass(coefficient, BigNum);\n        _assertClass(constant, BigNum);\n        const ret = wasm.linearfee_new(coefficient.__wbg_ptr, constant.__wbg_ptr);\n        return LinearFee.__wrap(ret);\n    }\n}\n/**\n*/\nclass MIRToStakeCredentials {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(MIRToStakeCredentials.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mirtostakecredentials_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mirtostakecredentials_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MIRToStakeCredentials}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.mirtostakecredentials_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return MIRToStakeCredentials.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mirtostakecredentials_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {MIRToStakeCredentials}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.mirtostakecredentials_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return MIRToStakeCredentials.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mirtostakecredentials_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mirtostakecredentials_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {MIRToStakeCredentials}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.mirtostakecredentials_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return MIRToStakeCredentials.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {MIRToStakeCredentials}\n    */\n    static new() {\n        const ret = wasm.mirtostakecredentials_new();\n        return MIRToStakeCredentials.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.mirtostakecredentials_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {Credential} cred\n    * @param {Int} delta\n    * @returns {Int | undefined}\n    */\n    insert(cred, delta) {\n        _assertClass(cred, Credential);\n        _assertClass(delta, Int);\n        const ret = wasm.mirtostakecredentials_insert(this.__wbg_ptr, cred.__wbg_ptr, delta.__wbg_ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @param {Credential} cred\n    * @returns {Int | undefined}\n    */\n    get(cred) {\n        _assertClass(cred, Credential);\n        const ret = wasm.mirtostakecredentials_get(this.__wbg_ptr, cred.__wbg_ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @returns {Credentials}\n    */\n    keys() {\n        const ret = wasm.mirtostakecredentials_keys(this.__wbg_ptr);\n        return Credentials.__wrap(ret);\n    }\n}\n/**\n*/\nclass MetadataList {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(MetadataList.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_metadatalist_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.metadatalist_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MetadataList}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.metadatalist_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return MetadataList.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.metadatalist_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {MetadataList}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.metadatalist_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return MetadataList.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {MetadataList}\n    */\n    static new() {\n        const ret = wasm.metadatalist_new();\n        return MetadataList.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.metadatalist_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionMetadatum}\n    */\n    get(index) {\n        const ret = wasm.metadatalist_get(this.__wbg_ptr, index);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {TransactionMetadatum} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionMetadatum);\n        wasm.metadatalist_add(this.__wbg_ptr, elem.__wbg_ptr);\n    }\n}\n/**\n*/\nclass MetadataMap {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(MetadataMap.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_metadatamap_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.metadatamap_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MetadataMap}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.metadatamap_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return MetadataMap.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.metadatamap_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {MetadataMap}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.metadatamap_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return MetadataMap.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {MetadataMap}\n    */\n    static new() {\n        const ret = wasm.generaltransactionmetadata_new();\n        return MetadataMap.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.generaltransactionmetadata_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {TransactionMetadatum} key\n    * @param {TransactionMetadatum} value\n    * @returns {TransactionMetadatum | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, TransactionMetadatum);\n        _assertClass(value, TransactionMetadatum);\n        const ret = wasm.metadatamap_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {string} key\n    * @param {TransactionMetadatum} value\n    * @returns {TransactionMetadatum | undefined}\n    */\n    insert_str(key, value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            _assertClass(value, TransactionMetadatum);\n            wasm.metadatamap_insert_str(retptr, this.__wbg_ptr, ptr0, len0, value.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 === 0 ? undefined : TransactionMetadatum.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} key\n    * @param {TransactionMetadatum} value\n    * @returns {TransactionMetadatum | undefined}\n    */\n    insert_i32(key, value) {\n        _assertClass(value, TransactionMetadatum);\n        const ret = wasm.metadatamap_insert_i32(this.__wbg_ptr, key, value.__wbg_ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {TransactionMetadatum} key\n    * @returns {TransactionMetadatum}\n    */\n    get(key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(key, TransactionMetadatum);\n            wasm.metadatamap_get(retptr, this.__wbg_ptr, key.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionMetadatum.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} key\n    * @returns {TransactionMetadatum}\n    */\n    get_str(key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.metadatamap_get_str(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionMetadatum.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} key\n    * @returns {TransactionMetadatum}\n    */\n    get_i32(key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.metadatamap_get_i32(retptr, this.__wbg_ptr, key);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionMetadatum.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {TransactionMetadatum} key\n    * @returns {boolean}\n    */\n    has(key) {\n        _assertClass(key, TransactionMetadatum);\n        const ret = wasm.metadatamap_has(this.__wbg_ptr, key.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {MetadataList}\n    */\n    keys() {\n        const ret = wasm.metadatamap_keys(this.__wbg_ptr);\n        return MetadataList.__wrap(ret);\n    }\n}\n/**\n*/\nclass Mint {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Mint.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mint_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mint_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Mint}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.mint_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Mint.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mint_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Mint}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.mint_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Mint.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mint_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mint_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Mint}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.mint_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Mint.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Mint}\n    */\n    static new() {\n        const ret = wasm.assetnames_new();\n        return Mint.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} key\n    * @param {MintAssets} value\n    * @returns {Mint}\n    */\n    static new_from_entry(key, value) {\n        _assertClass(key, ScriptHash);\n        _assertClass(value, MintAssets);\n        const ret = wasm.mint_new_from_entry(key.__wbg_ptr, value.__wbg_ptr);\n        return Mint.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.assetnames_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {ScriptHash} key\n    * @param {MintAssets} value\n    * @returns {MintAssets | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, ScriptHash);\n        _assertClass(value, MintAssets);\n        const ret = wasm.mint_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);\n        return ret === 0 ? undefined : MintAssets.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Mint can store multiple entries for the same policy id.\n    * Use `.get_all` instead.\n    * @param {ScriptHash} key\n    * @returns {MintAssets | undefined}\n    */\n    get(key) {\n        _assertClass(key, ScriptHash);\n        const ret = wasm.mint_get(this.__wbg_ptr, key.__wbg_ptr);\n        return ret === 0 ? undefined : MintAssets.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} key\n    * @returns {MintsAssets | undefined}\n    */\n    get_all(key) {\n        _assertClass(key, ScriptHash);\n        const ret = wasm.mint_get_all(this.__wbg_ptr, key.__wbg_ptr);\n        return ret === 0 ? undefined : MintsAssets.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptHashes}\n    */\n    keys() {\n        const ret = wasm.mint_keys(this.__wbg_ptr);\n        return ScriptHashes.__wrap(ret);\n    }\n    /**\n    * Returns the multiasset where only positive (minting) entries are present\n    * @returns {MultiAsset}\n    */\n    as_positive_multiasset() {\n        const ret = wasm.mint_as_positive_multiasset(this.__wbg_ptr);\n        return MultiAsset.__wrap(ret);\n    }\n    /**\n    * Returns the multiasset where only negative (burning) entries are present\n    * @returns {MultiAsset}\n    */\n    as_negative_multiasset() {\n        const ret = wasm.mint_as_negative_multiasset(this.__wbg_ptr);\n        return MultiAsset.__wrap(ret);\n    }\n}\n/**\n*/\nclass MintAssets {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(MintAssets.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mintassets_free(ptr);\n    }\n    /**\n    * @returns {MintAssets}\n    */\n    static new() {\n        const ret = wasm.assets_new();\n        return MintAssets.__wrap(ret);\n    }\n    /**\n    * @param {AssetName} key\n    * @param {Int} value\n    * @returns {MintAssets}\n    */\n    static new_from_entry(key, value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(key, AssetName);\n            _assertClass(value, Int);\n            wasm.mintassets_new_from_entry(retptr, key.__wbg_ptr, value.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return MintAssets.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.assetnames_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {AssetName} key\n    * @param {Int} value\n    * @returns {Int | undefined}\n    */\n    insert(key, value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(key, AssetName);\n            _assertClass(value, Int);\n            var ptr0 = value.__destroy_into_raw();\n            wasm.mintassets_insert(retptr, this.__wbg_ptr, key.__wbg_ptr, ptr0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 === 0 ? undefined : Int.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {AssetName} key\n    * @returns {Int | undefined}\n    */\n    get(key) {\n        _assertClass(key, AssetName);\n        const ret = wasm.mintassets_get(this.__wbg_ptr, key.__wbg_ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @returns {AssetNames}\n    */\n    keys() {\n        const ret = wasm.mintassets_keys(this.__wbg_ptr);\n        return AssetNames.__wrap(ret);\n    }\n}\n/**\n*/\nclass MintBuilder {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(MintBuilder.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mintbuilder_free(ptr);\n    }\n    /**\n    * @returns {MintBuilder}\n    */\n    static new() {\n        const ret = wasm.mintbuilder_new();\n        return MintBuilder.__wrap(ret);\n    }\n    /**\n    * @param {MintWitness} mint\n    * @param {AssetName} asset_name\n    * @param {Int} amount\n    */\n    add_asset(mint, asset_name, amount) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(mint, MintWitness);\n            _assertClass(asset_name, AssetName);\n            _assertClass(amount, Int);\n            wasm.mintbuilder_add_asset(retptr, this.__wbg_ptr, mint.__wbg_ptr, asset_name.__wbg_ptr, amount.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {MintWitness} mint\n    * @param {AssetName} asset_name\n    * @param {Int} amount\n    */\n    set_asset(mint, asset_name, amount) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(mint, MintWitness);\n            _assertClass(asset_name, AssetName);\n            _assertClass(amount, Int);\n            wasm.mintbuilder_set_asset(retptr, this.__wbg_ptr, mint.__wbg_ptr, asset_name.__wbg_ptr, amount.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Mint}\n    */\n    build() {\n        const ret = wasm.mintbuilder_build(this.__wbg_ptr);\n        return Mint.__wrap(ret);\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    get_native_scripts() {\n        const ret = wasm.mintbuilder_get_native_scripts(this.__wbg_ptr);\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusWitnesses}\n    */\n    get_plutus_witnesses() {\n        const ret = wasm.mintbuilder_get_plutus_witnesses(this.__wbg_ptr);\n        return PlutusWitnesses.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInputs}\n    */\n    get_ref_inputs() {\n        const ret = wasm.mintbuilder_get_ref_inputs(this.__wbg_ptr);\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @returns {Redeemers}\n    */\n    get_redeeemers() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mintbuilder_get_redeeemers(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Redeemers.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_plutus_scripts() {\n        const ret = wasm.mintbuilder_has_plutus_scripts(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_native_scripts() {\n        const ret = wasm.mintbuilder_has_native_scripts(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nclass MintWitness {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(MintWitness.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mintwitness_free(ptr);\n    }\n    /**\n    * @param {NativeScript} native_script\n    * @returns {MintWitness}\n    */\n    static new_native_script(native_script) {\n        _assertClass(native_script, NativeScript);\n        const ret = wasm.mintwitness_new_native_script(native_script.__wbg_ptr);\n        return MintWitness.__wrap(ret);\n    }\n    /**\n    * @param {PlutusScriptSource} plutus_script\n    * @param {Redeemer} redeemer\n    * @returns {MintWitness}\n    */\n    static new_plutus_script(plutus_script, redeemer) {\n        _assertClass(plutus_script, PlutusScriptSource);\n        _assertClass(redeemer, Redeemer);\n        const ret = wasm.mintwitness_new_plutus_script(plutus_script.__wbg_ptr, redeemer.__wbg_ptr);\n        return MintWitness.__wrap(ret);\n    }\n}\n/**\n*/\nclass MintsAssets {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(MintsAssets.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mintsassets_free(ptr);\n    }\n}\n/**\n*/\nclass MoveInstantaneousReward {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(MoveInstantaneousReward.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_moveinstantaneousreward_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.moveinstantaneousreward_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MoveInstantaneousReward}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.moveinstantaneousreward_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return MoveInstantaneousReward.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.moveinstantaneousreward_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {MoveInstantaneousReward}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.moveinstantaneousreward_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return MoveInstantaneousReward.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.moveinstantaneousreward_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.moveinstantaneousreward_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {MoveInstantaneousReward}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.moveinstantaneousreward_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return MoveInstantaneousReward.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} pot\n    * @param {BigNum} amount\n    * @returns {MoveInstantaneousReward}\n    */\n    static new_to_other_pot(pot, amount) {\n        _assertClass(amount, BigNum);\n        const ret = wasm.moveinstantaneousreward_new_to_other_pot(pot, amount.__wbg_ptr);\n        return MoveInstantaneousReward.__wrap(ret);\n    }\n    /**\n    * @param {number} pot\n    * @param {MIRToStakeCredentials} amounts\n    * @returns {MoveInstantaneousReward}\n    */\n    static new_to_stake_creds(pot, amounts) {\n        _assertClass(amounts, MIRToStakeCredentials);\n        const ret = wasm.moveinstantaneousreward_new_to_stake_creds(pot, amounts.__wbg_ptr);\n        return MoveInstantaneousReward.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    pot() {\n        const ret = wasm.moveinstantaneousreward_pot(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        const ret = wasm.moveinstantaneousreward_kind(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    as_to_other_pot() {\n        const ret = wasm.moveinstantaneousreward_as_to_other_pot(this.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {MIRToStakeCredentials | undefined}\n    */\n    as_to_stake_creds() {\n        const ret = wasm.moveinstantaneousreward_as_to_stake_creds(this.__wbg_ptr);\n        return ret === 0 ? undefined : MIRToStakeCredentials.__wrap(ret);\n    }\n}\n/**\n*/\nclass MoveInstantaneousRewardsCert {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(MoveInstantaneousRewardsCert.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_moveinstantaneousrewardscert_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.moveinstantaneousrewardscert_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MoveInstantaneousRewardsCert}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.moveinstantaneousrewardscert_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return MoveInstantaneousRewardsCert.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.moveinstantaneousrewardscert_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {MoveInstantaneousRewardsCert}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.moveinstantaneousrewardscert_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return MoveInstantaneousRewardsCert.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.moveinstantaneousrewardscert_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.moveinstantaneousrewardscert_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {MoveInstantaneousRewardsCert}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.moveinstantaneousrewardscert_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return MoveInstantaneousRewardsCert.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {MoveInstantaneousReward}\n    */\n    move_instantaneous_reward() {\n        const ret = wasm.moveinstantaneousrewardscert_move_instantaneous_reward(this.__wbg_ptr);\n        return MoveInstantaneousReward.__wrap(ret);\n    }\n    /**\n    * @param {MoveInstantaneousReward} move_instantaneous_reward\n    * @returns {MoveInstantaneousRewardsCert}\n    */\n    static new(move_instantaneous_reward) {\n        _assertClass(move_instantaneous_reward, MoveInstantaneousReward);\n        const ret = wasm.moveinstantaneousrewardscert_new(move_instantaneous_reward.__wbg_ptr);\n        return MoveInstantaneousRewardsCert.__wrap(ret);\n    }\n}\n/**\n*/\nclass MultiAsset {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(MultiAsset.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_multiasset_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.multiasset_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MultiAsset}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.multiasset_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return MultiAsset.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.multiasset_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {MultiAsset}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.multiasset_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return MultiAsset.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.multiasset_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.multiasset_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {MultiAsset}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.multiasset_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return MultiAsset.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {MultiAsset}\n    */\n    static new() {\n        const ret = wasm.assets_new();\n        return MultiAsset.__wrap(ret);\n    }\n    /**\n    * the number of unique policy IDs in the multiasset\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.assetnames_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * set (and replace if it exists) all assets with policy {policy_id} to a copy of {assets}\n    * @param {ScriptHash} policy_id\n    * @param {Assets} assets\n    * @returns {Assets | undefined}\n    */\n    insert(policy_id, assets) {\n        _assertClass(policy_id, ScriptHash);\n        _assertClass(assets, Assets);\n        const ret = wasm.multiasset_insert(this.__wbg_ptr, policy_id.__wbg_ptr, assets.__wbg_ptr);\n        return ret === 0 ? undefined : Assets.__wrap(ret);\n    }\n    /**\n    * all assets under {policy_id}, if any exist, or else None (undefined in JS)\n    * @param {ScriptHash} policy_id\n    * @returns {Assets | undefined}\n    */\n    get(policy_id) {\n        _assertClass(policy_id, ScriptHash);\n        const ret = wasm.multiasset_get(this.__wbg_ptr, policy_id.__wbg_ptr);\n        return ret === 0 ? undefined : Assets.__wrap(ret);\n    }\n    /**\n    * sets the asset {asset_name} to {value} under policy {policy_id}\n    * returns the previous amount if it was set, or else None (undefined in JS)\n    * @param {ScriptHash} policy_id\n    * @param {AssetName} asset_name\n    * @param {BigNum} value\n    * @returns {BigNum | undefined}\n    */\n    set_asset(policy_id, asset_name, value) {\n        _assertClass(policy_id, ScriptHash);\n        _assertClass(asset_name, AssetName);\n        _assertClass(value, BigNum);\n        var ptr0 = value.__destroy_into_raw();\n        const ret = wasm.multiasset_set_asset(this.__wbg_ptr, policy_id.__wbg_ptr, asset_name.__wbg_ptr, ptr0);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * returns the amount of asset {asset_name} under policy {policy_id}\n    * If such an asset does not exist, 0 is returned.\n    * @param {ScriptHash} policy_id\n    * @param {AssetName} asset_name\n    * @returns {BigNum}\n    */\n    get_asset(policy_id, asset_name) {\n        _assertClass(policy_id, ScriptHash);\n        _assertClass(asset_name, AssetName);\n        const ret = wasm.multiasset_get_asset(this.__wbg_ptr, policy_id.__wbg_ptr, asset_name.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * returns all policy IDs used by assets in this multiasset\n    * @returns {ScriptHashes}\n    */\n    keys() {\n        const ret = wasm.multiasset_keys(this.__wbg_ptr);\n        return ScriptHashes.__wrap(ret);\n    }\n    /**\n    * removes an asset from the list if the result is 0 or less\n    * does not modify this object, instead the result is returned\n    * @param {MultiAsset} rhs_ma\n    * @returns {MultiAsset}\n    */\n    sub(rhs_ma) {\n        _assertClass(rhs_ma, MultiAsset);\n        const ret = wasm.multiasset_sub(this.__wbg_ptr, rhs_ma.__wbg_ptr);\n        return MultiAsset.__wrap(ret);\n    }\n}\n/**\n*/\nclass MultiHostName {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(MultiHostName.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_multihostname_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.multihostname_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MultiHostName}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.multihostname_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return MultiHostName.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.multihostname_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {MultiHostName}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.multihostname_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return MultiHostName.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.multihostname_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.multihostname_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {MultiHostName}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.multihostname_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return MultiHostName.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {DNSRecordSRV}\n    */\n    dns_name() {\n        const ret = wasm.multihostname_dns_name(this.__wbg_ptr);\n        return DNSRecordSRV.__wrap(ret);\n    }\n    /**\n    * @param {DNSRecordSRV} dns_name\n    * @returns {MultiHostName}\n    */\n    static new(dns_name) {\n        _assertClass(dns_name, DNSRecordSRV);\n        const ret = wasm.multihostname_new(dns_name.__wbg_ptr);\n        return MultiHostName.__wrap(ret);\n    }\n}\n/**\n*/\nclass NativeScript {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NativeScript.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nativescript_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nativescript_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {NativeScript}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.nativescript_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NativeScript.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nativescript_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {NativeScript}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.nativescript_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NativeScript.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nativescript_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nativescript_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {NativeScript}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.nativescript_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NativeScript.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {ScriptHash}\n    */\n    hash() {\n        const ret = wasm.nativescript_hash(this.__wbg_ptr);\n        return ScriptHash.__wrap(ret);\n    }\n    /**\n    * @param {ScriptPubkey} script_pubkey\n    * @returns {NativeScript}\n    */\n    static new_script_pubkey(script_pubkey) {\n        _assertClass(script_pubkey, ScriptPubkey);\n        const ret = wasm.nativescript_new_script_pubkey(script_pubkey.__wbg_ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {ScriptAll} script_all\n    * @returns {NativeScript}\n    */\n    static new_script_all(script_all) {\n        _assertClass(script_all, ScriptAll);\n        const ret = wasm.nativescript_new_script_all(script_all.__wbg_ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {ScriptAny} script_any\n    * @returns {NativeScript}\n    */\n    static new_script_any(script_any) {\n        _assertClass(script_any, ScriptAny);\n        const ret = wasm.nativescript_new_script_any(script_any.__wbg_ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {ScriptNOfK} script_n_of_k\n    * @returns {NativeScript}\n    */\n    static new_script_n_of_k(script_n_of_k) {\n        _assertClass(script_n_of_k, ScriptNOfK);\n        const ret = wasm.nativescript_new_script_n_of_k(script_n_of_k.__wbg_ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {TimelockStart} timelock_start\n    * @returns {NativeScript}\n    */\n    static new_timelock_start(timelock_start) {\n        _assertClass(timelock_start, TimelockStart);\n        const ret = wasm.nativescript_new_timelock_start(timelock_start.__wbg_ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {TimelockExpiry} timelock_expiry\n    * @returns {NativeScript}\n    */\n    static new_timelock_expiry(timelock_expiry) {\n        _assertClass(timelock_expiry, TimelockExpiry);\n        const ret = wasm.nativescript_new_timelock_expiry(timelock_expiry.__wbg_ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        const ret = wasm.nativescript_kind(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {ScriptPubkey | undefined}\n    */\n    as_script_pubkey() {\n        const ret = wasm.nativescript_as_script_pubkey(this.__wbg_ptr);\n        return ret === 0 ? undefined : ScriptPubkey.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptAll | undefined}\n    */\n    as_script_all() {\n        const ret = wasm.nativescript_as_script_all(this.__wbg_ptr);\n        return ret === 0 ? undefined : ScriptAll.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptAny | undefined}\n    */\n    as_script_any() {\n        const ret = wasm.nativescript_as_script_any(this.__wbg_ptr);\n        return ret === 0 ? undefined : ScriptAny.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptNOfK | undefined}\n    */\n    as_script_n_of_k() {\n        const ret = wasm.nativescript_as_script_n_of_k(this.__wbg_ptr);\n        return ret === 0 ? undefined : ScriptNOfK.__wrap(ret);\n    }\n    /**\n    * @returns {TimelockStart | undefined}\n    */\n    as_timelock_start() {\n        const ret = wasm.nativescript_as_timelock_start(this.__wbg_ptr);\n        return ret === 0 ? undefined : TimelockStart.__wrap(ret);\n    }\n    /**\n    * @returns {TimelockExpiry | undefined}\n    */\n    as_timelock_expiry() {\n        const ret = wasm.nativescript_as_timelock_expiry(this.__wbg_ptr);\n        return ret === 0 ? undefined : TimelockExpiry.__wrap(ret);\n    }\n    /**\n    * Returns an array of unique Ed25519KeyHashes\n    * contained within this script recursively on any depth level.\n    * The order of the keys in the result is not determined in any way.\n    * @returns {Ed25519KeyHashes}\n    */\n    get_required_signers() {\n        const ret = wasm.nativescript_get_required_signers(this.__wbg_ptr);\n        return Ed25519KeyHashes.__wrap(ret);\n    }\n}\n/**\n*/\nclass NativeScriptSource {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NativeScriptSource.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nativescriptsource_free(ptr);\n    }\n    /**\n    * @param {NativeScript} script\n    * @returns {NativeScriptSource}\n    */\n    static new(script) {\n        _assertClass(script, NativeScript);\n        const ret = wasm.nativescriptsource_new(script.__wbg_ptr);\n        return NativeScriptSource.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} script_hash\n    * @param {TransactionInput} input\n    * @param {Ed25519KeyHashes} required_signers\n    * @returns {NativeScriptSource}\n    */\n    static new_ref_input(script_hash, input, required_signers) {\n        _assertClass(script_hash, ScriptHash);\n        _assertClass(input, TransactionInput);\n        _assertClass(required_signers, Ed25519KeyHashes);\n        const ret = wasm.nativescriptsource_new_ref_input(script_hash.__wbg_ptr, input.__wbg_ptr, required_signers.__wbg_ptr);\n        return NativeScriptSource.__wrap(ret);\n    }\n}\n/**\n*/\nclass NativeScripts {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NativeScripts.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nativescripts_free(ptr);\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    static new() {\n        const ret = wasm.nativescripts_new();\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.assetnames_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {NativeScript}\n    */\n    get(index) {\n        const ret = wasm.nativescripts_get(this.__wbg_ptr, index);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {NativeScript} elem\n    */\n    add(elem) {\n        _assertClass(elem, NativeScript);\n        wasm.nativescripts_add(this.__wbg_ptr, elem.__wbg_ptr);\n    }\n}\n/**\n*/\nclass NetworkId {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NetworkId.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_networkid_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.networkid_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {NetworkId}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.networkid_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NetworkId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.networkid_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {NetworkId}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.networkid_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NetworkId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.networkid_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.networkid_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {NetworkId}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.networkid_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NetworkId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {NetworkId}\n    */\n    static testnet() {\n        const ret = wasm.networkid_testnet();\n        return NetworkId.__wrap(ret);\n    }\n    /**\n    * @returns {NetworkId}\n    */\n    static mainnet() {\n        const ret = wasm.networkid_mainnet();\n        return NetworkId.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        const ret = wasm.networkid_kind(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nclass NetworkInfo {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NetworkInfo.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_networkinfo_free(ptr);\n    }\n    /**\n    * @param {number} network_id\n    * @param {number} protocol_magic\n    * @returns {NetworkInfo}\n    */\n    static new(network_id, protocol_magic) {\n        const ret = wasm.networkinfo_new(network_id, protocol_magic);\n        return NetworkInfo.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    network_id() {\n        const ret = wasm.networkinfo_network_id(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    protocol_magic() {\n        const ret = wasm.networkinfo_protocol_magic(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {NetworkInfo}\n    */\n    static testnet_preview() {\n        const ret = wasm.networkinfo_testnet_preview();\n        return NetworkInfo.__wrap(ret);\n    }\n    /**\n    * @returns {NetworkInfo}\n    */\n    static testnet_preprod() {\n        const ret = wasm.networkinfo_testnet_preprod();\n        return NetworkInfo.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * This network does not exist anymore. Use `.testnet_preview()` or `.testnet_preprod()`\n    * @returns {NetworkInfo}\n    */\n    static testnet() {\n        const ret = wasm.networkinfo_testnet();\n        return NetworkInfo.__wrap(ret);\n    }\n    /**\n    * @returns {NetworkInfo}\n    */\n    static mainnet() {\n        const ret = wasm.networkinfo_mainnet();\n        return NetworkInfo.__wrap(ret);\n    }\n}\n/**\n*/\nclass NewConstitutionProposal {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NewConstitutionProposal.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_newconstitutionproposal_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.newconstitutionproposal_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {NewConstitutionProposal}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.newconstitutionproposal_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NewConstitutionProposal.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.newconstitutionproposal_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {NewConstitutionProposal}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.newconstitutionproposal_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NewConstitutionProposal.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.newconstitutionproposal_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.newconstitutionproposal_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {NewConstitutionProposal}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.newconstitutionproposal_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NewConstitutionProposal.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {GovernanceActionId | undefined}\n    */\n    gov_action_id() {\n        const ret = wasm.newconstitutionproposal_gov_action_id(this.__wbg_ptr);\n        return ret === 0 ? undefined : GovernanceActionId.__wrap(ret);\n    }\n    /**\n    * @returns {Constitution}\n    */\n    constitution() {\n        const ret = wasm.newconstitutionproposal_constitution(this.__wbg_ptr);\n        return Constitution.__wrap(ret);\n    }\n    /**\n    * @param {Constitution} constitution\n    * @returns {NewConstitutionProposal}\n    */\n    static new(constitution) {\n        _assertClass(constitution, Constitution);\n        const ret = wasm.newconstitutionproposal_new(constitution.__wbg_ptr);\n        return NewConstitutionProposal.__wrap(ret);\n    }\n    /**\n    * @param {GovernanceActionId} gov_action_id\n    * @param {Constitution} constitution\n    * @returns {NewConstitutionProposal}\n    */\n    static new_with_action_id(gov_action_id, constitution) {\n        _assertClass(gov_action_id, GovernanceActionId);\n        _assertClass(constitution, Constitution);\n        const ret = wasm.newconstitutionproposal_new_with_action_id(gov_action_id.__wbg_ptr, constitution.__wbg_ptr);\n        return NewConstitutionProposal.__wrap(ret);\n    }\n}\n/**\n*/\nclass NoConfidenceProposal {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoConfidenceProposal.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noconfidenceproposal_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noconfidenceproposal_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {NoConfidenceProposal}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.noconfidenceproposal_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoConfidenceProposal.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noconfidenceproposal_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {NoConfidenceProposal}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.noconfidenceproposal_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoConfidenceProposal.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noconfidenceproposal_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noconfidenceproposal_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {NoConfidenceProposal}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.noconfidenceproposal_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoConfidenceProposal.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {GovernanceActionId | undefined}\n    */\n    gov_action_id() {\n        const ret = wasm.noconfidenceproposal_gov_action_id(this.__wbg_ptr);\n        return ret === 0 ? undefined : GovernanceActionId.__wrap(ret);\n    }\n    /**\n    * @returns {NoConfidenceProposal}\n    */\n    static new() {\n        const ret = wasm.noconfidenceproposal_new();\n        return NoConfidenceProposal.__wrap(ret);\n    }\n    /**\n    * @param {GovernanceActionId} gov_action_id\n    * @returns {NoConfidenceProposal}\n    */\n    static new_with_action_id(gov_action_id) {\n        _assertClass(gov_action_id, GovernanceActionId);\n        const ret = wasm.noconfidenceproposal_new_with_action_id(gov_action_id.__wbg_ptr);\n        return NoConfidenceProposal.__wrap(ret);\n    }\n}\n/**\n*/\nclass Nonce {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Nonce.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nonce_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nonce_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Nonce}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.nonce_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Nonce.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nonce_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Nonce}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.nonce_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Nonce.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nonce_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nonce_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Nonce}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.nonce_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Nonce.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Nonce}\n    */\n    static new_identity() {\n        const ret = wasm.nonce_new_identity();\n        return Nonce.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} hash\n    * @returns {Nonce}\n    */\n    static new_from_hash(hash) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(hash, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.nonce_new_from_hash(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Nonce.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    get_hash() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nonce_get_hash(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass OperationalCert {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(OperationalCert.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_operationalcert_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.operationalcert_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {OperationalCert}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.operationalcert_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return OperationalCert.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.operationalcert_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {OperationalCert}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.operationalcert_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return OperationalCert.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.operationalcert_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.operationalcert_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {OperationalCert}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.operationalcert_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return OperationalCert.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {KESVKey}\n    */\n    hot_vkey() {\n        const ret = wasm.operationalcert_hot_vkey(this.__wbg_ptr);\n        return KESVKey.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    sequence_number() {\n        const ret = wasm.operationalcert_sequence_number(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    kes_period() {\n        const ret = wasm.operationalcert_kes_period(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Ed25519Signature}\n    */\n    sigma() {\n        const ret = wasm.operationalcert_sigma(this.__wbg_ptr);\n        return Ed25519Signature.__wrap(ret);\n    }\n    /**\n    * @param {KESVKey} hot_vkey\n    * @param {number} sequence_number\n    * @param {number} kes_period\n    * @param {Ed25519Signature} sigma\n    * @returns {OperationalCert}\n    */\n    static new(hot_vkey, sequence_number, kes_period, sigma) {\n        _assertClass(hot_vkey, KESVKey);\n        _assertClass(sigma, Ed25519Signature);\n        const ret = wasm.operationalcert_new(hot_vkey.__wbg_ptr, sequence_number, kes_period, sigma.__wbg_ptr);\n        return OperationalCert.__wrap(ret);\n    }\n}\n/**\n*/\nclass OutputDatum {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(OutputDatum.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_outputdatum_free(ptr);\n    }\n    /**\n    * @param {DataHash} data_hash\n    * @returns {OutputDatum}\n    */\n    static new_data_hash(data_hash) {\n        _assertClass(data_hash, DataHash);\n        const ret = wasm.outputdatum_new_data_hash(data_hash.__wbg_ptr);\n        return OutputDatum.__wrap(ret);\n    }\n    /**\n    * @param {PlutusData} data\n    * @returns {OutputDatum}\n    */\n    static new_data(data) {\n        _assertClass(data, PlutusData);\n        const ret = wasm.outputdatum_new_data(data.__wbg_ptr);\n        return OutputDatum.__wrap(ret);\n    }\n    /**\n    * @returns {DataHash | undefined}\n    */\n    data_hash() {\n        const ret = wasm.outputdatum_data_hash(this.__wbg_ptr);\n        return ret === 0 ? undefined : DataHash.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusData | undefined}\n    */\n    data() {\n        const ret = wasm.outputdatum_data(this.__wbg_ptr);\n        return ret === 0 ? undefined : PlutusData.__wrap(ret);\n    }\n}\n/**\n*/\nclass ParameterChangeProposal {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ParameterChangeProposal.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_parameterchangeproposal_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.parameterchangeproposal_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ParameterChangeProposal}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.parameterchangeproposal_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ParameterChangeProposal.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.parameterchangeproposal_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ParameterChangeProposal}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.parameterchangeproposal_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ParameterChangeProposal.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.parameterchangeproposal_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.parameterchangeproposal_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {ParameterChangeProposal}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.parameterchangeproposal_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ParameterChangeProposal.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {GovernanceActionId | undefined}\n    */\n    gov_action_id() {\n        const ret = wasm.parameterchangeproposal_gov_action_id(this.__wbg_ptr);\n        return ret === 0 ? undefined : GovernanceActionId.__wrap(ret);\n    }\n    /**\n    * @returns {ProtocolParamUpdate}\n    */\n    protocol_param_updates() {\n        const ret = wasm.parameterchangeproposal_protocol_param_updates(this.__wbg_ptr);\n        return ProtocolParamUpdate.__wrap(ret);\n    }\n    /**\n    * @param {ProtocolParamUpdate} protocol_param_updates\n    * @returns {ParameterChangeProposal}\n    */\n    static new(protocol_param_updates) {\n        _assertClass(protocol_param_updates, ProtocolParamUpdate);\n        const ret = wasm.parameterchangeproposal_new(protocol_param_updates.__wbg_ptr);\n        return ParameterChangeProposal.__wrap(ret);\n    }\n    /**\n    * @param {GovernanceActionId} gov_action_id\n    * @param {ProtocolParamUpdate} protocol_param_updates\n    * @returns {ParameterChangeProposal}\n    */\n    static new_with_action_id(gov_action_id, protocol_param_updates) {\n        _assertClass(gov_action_id, GovernanceActionId);\n        _assertClass(protocol_param_updates, ProtocolParamUpdate);\n        const ret = wasm.parameterchangeproposal_new_with_action_id(gov_action_id.__wbg_ptr, protocol_param_updates.__wbg_ptr);\n        return ParameterChangeProposal.__wrap(ret);\n    }\n}\n/**\n*/\nclass PlutusData {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PlutusData.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutusdata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusdata_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusData}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.plutusdata_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PlutusData.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusdata_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {PlutusData}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.plutusdata_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PlutusData.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {ConstrPlutusData} constr_plutus_data\n    * @returns {PlutusData}\n    */\n    static new_constr_plutus_data(constr_plutus_data) {\n        _assertClass(constr_plutus_data, ConstrPlutusData);\n        const ret = wasm.plutusdata_new_constr_plutus_data(constr_plutus_data.__wbg_ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * Same as `.new_constr_plutus_data` but creates constr with empty data list\n    * @param {BigNum} alternative\n    * @returns {PlutusData}\n    */\n    static new_empty_constr_plutus_data(alternative) {\n        _assertClass(alternative, BigNum);\n        const ret = wasm.plutusdata_new_empty_constr_plutus_data(alternative.__wbg_ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} alternative\n    * @param {PlutusData} plutus_data\n    * @returns {PlutusData}\n    */\n    static new_single_value_constr_plutus_data(alternative, plutus_data) {\n        _assertClass(alternative, BigNum);\n        _assertClass(plutus_data, PlutusData);\n        const ret = wasm.plutusdata_new_single_value_constr_plutus_data(alternative.__wbg_ptr, plutus_data.__wbg_ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {PlutusMap} map\n    * @returns {PlutusData}\n    */\n    static new_map(map) {\n        _assertClass(map, PlutusMap);\n        const ret = wasm.plutusdata_new_map(map.__wbg_ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {PlutusList} list\n    * @returns {PlutusData}\n    */\n    static new_list(list) {\n        _assertClass(list, PlutusList);\n        const ret = wasm.plutusdata_new_list(list.__wbg_ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {BigInt} integer\n    * @returns {PlutusData}\n    */\n    static new_integer(integer) {\n        _assertClass(integer, BigInt);\n        const ret = wasm.plutusdata_new_integer(integer.__wbg_ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusData}\n    */\n    static new_bytes(bytes) {\n        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.plutusdata_new_bytes(ptr0, len0);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        const ret = wasm.plutusdata_kind(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {ConstrPlutusData | undefined}\n    */\n    as_constr_plutus_data() {\n        const ret = wasm.plutusdata_as_constr_plutus_data(this.__wbg_ptr);\n        return ret === 0 ? undefined : ConstrPlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusMap | undefined}\n    */\n    as_map() {\n        const ret = wasm.plutusdata_as_map(this.__wbg_ptr);\n        return ret === 0 ? undefined : PlutusMap.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusList | undefined}\n    */\n    as_list() {\n        const ret = wasm.plutusdata_as_list(this.__wbg_ptr);\n        return ret === 0 ? undefined : PlutusList.__wrap(ret);\n    }\n    /**\n    * @returns {BigInt | undefined}\n    */\n    as_integer() {\n        const ret = wasm.plutusdata_as_integer(this.__wbg_ptr);\n        return ret === 0 ? undefined : BigInt.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusdata_as_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} schema\n    * @returns {string}\n    */\n    to_json(schema) {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.decode_plutus_datum_to_json_str(retptr, this.__wbg_ptr, schema);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @param {string} json\n    * @param {number} schema\n    * @returns {PlutusData}\n    */\n    static from_json(json, schema) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.encode_json_str_to_plutus_datum(retptr, ptr0, len0, schema);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PlutusData.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Address} address\n    * @returns {PlutusData}\n    */\n    static from_address(address) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(address, Address);\n            wasm.plutusdata_from_address(retptr, address.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PlutusData.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass PlutusList {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PlutusList.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutuslist_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutuslist_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusList}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.plutuslist_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PlutusList.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutuslist_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {PlutusList}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.plutuslist_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PlutusList.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {PlutusList}\n    */\n    static new() {\n        const ret = wasm.plutuslist_new();\n        return PlutusList.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.costmdls_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {PlutusData}\n    */\n    get(index) {\n        const ret = wasm.plutuslist_get(this.__wbg_ptr, index);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {PlutusData} elem\n    */\n    add(elem) {\n        _assertClass(elem, PlutusData);\n        wasm.plutuslist_add(this.__wbg_ptr, elem.__wbg_ptr);\n    }\n}\n/**\n*/\nclass PlutusMap {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PlutusMap.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutusmap_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusmap_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusMap}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.plutusmap_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PlutusMap.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusmap_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {PlutusMap}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.plutusmap_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PlutusMap.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {PlutusMap}\n    */\n    static new() {\n        const ret = wasm.plutusmap_new();\n        return PlutusMap.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.plutusmap_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {PlutusData} key\n    * @param {PlutusData} value\n    * @returns {PlutusData | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, PlutusData);\n        _assertClass(value, PlutusData);\n        const ret = wasm.plutusmap_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);\n        return ret === 0 ? undefined : PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {PlutusData} key\n    * @returns {PlutusData | undefined}\n    */\n    get(key) {\n        _assertClass(key, PlutusData);\n        const ret = wasm.plutusmap_get(this.__wbg_ptr, key.__wbg_ptr);\n        return ret === 0 ? undefined : PlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusList}\n    */\n    keys() {\n        const ret = wasm.plutusmap_keys(this.__wbg_ptr);\n        return PlutusList.__wrap(ret);\n    }\n}\n/**\n*/\nclass PlutusScript {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PlutusScript.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutusscript_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusscript_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusScript}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.plutusscript_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PlutusScript.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusscript_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {PlutusScript}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.plutusscript_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PlutusScript.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    *\n    *     * Creates a new Plutus script from the RAW bytes of the compiled script.\n    *     * This does NOT include any CBOR encoding around these bytes (e.g. from \"cborBytes\" in cardano-cli)\n    *     * If you creating this from those you should use PlutusScript::from_bytes() instead.\n    *\n    * @param {Uint8Array} bytes\n    * @returns {PlutusScript}\n    */\n    static new(bytes) {\n        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.plutusscript_new(ptr0, len0);\n        return PlutusScript.__wrap(ret);\n    }\n    /**\n    *\n    *     * Creates a new Plutus script from the RAW bytes of the compiled script.\n    *     * This does NOT include any CBOR encoding around these bytes (e.g. from \"cborBytes\" in cardano-cli)\n    *     * If you creating this from those you should use PlutusScript::from_bytes() instead.\n    *\n    * @param {Uint8Array} bytes\n    * @returns {PlutusScript}\n    */\n    static new_v2(bytes) {\n        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.plutusscript_new_v2(ptr0, len0);\n        return PlutusScript.__wrap(ret);\n    }\n    /**\n    *\n    *     * Creates a new Plutus script from the RAW bytes of the compiled script.\n    *     * This does NOT include any CBOR encoding around these bytes (e.g. from \"cborBytes\" in cardano-cli)\n    *     * If you creating this from those you should use PlutusScript::from_bytes() instead.\n    *\n    * @param {Uint8Array} bytes\n    * @returns {PlutusScript}\n    */\n    static new_v3(bytes) {\n        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.plutusscript_new_v3(ptr0, len0);\n        return PlutusScript.__wrap(ret);\n    }\n    /**\n    *\n    *     * Creates a new Plutus script from the RAW bytes of the compiled script.\n    *     * This does NOT include any CBOR encoding around these bytes (e.g. from \"cborBytes\" in cardano-cli)\n    *     * If you creating this from those you should use PlutusScript::from_bytes() instead.\n    *\n    * @param {Uint8Array} bytes\n    * @param {Language} language\n    * @returns {PlutusScript}\n    */\n    static new_with_version(bytes, language) {\n        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(language, Language);\n        const ret = wasm.plutusscript_new_with_version(ptr0, len0, language.__wbg_ptr);\n        return PlutusScript.__wrap(ret);\n    }\n    /**\n    *\n    *     * The raw bytes of this compiled Plutus script.\n    *     * If you need \"cborBytes\" for cardano-cli use PlutusScript::to_bytes() instead.\n    *\n    * @returns {Uint8Array}\n    */\n    bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusscript_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Same as `.from_bytes` but will consider the script as requiring the Plutus Language V2\n    * @param {Uint8Array} bytes\n    * @returns {PlutusScript}\n    */\n    static from_bytes_v2(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.plutusscript_from_bytes_v2(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PlutusScript.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Same as `.from_bytes` but will consider the script as requiring the Plutus Language V3\n    * @param {Uint8Array} bytes\n    * @returns {PlutusScript}\n    */\n    static from_bytes_v3(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.plutusscript_from_bytes_v3(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PlutusScript.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Same as `.from_bytes` but will consider the script as requiring the specified language version\n    * @param {Uint8Array} bytes\n    * @param {Language} language\n    * @returns {PlutusScript}\n    */\n    static from_bytes_with_version(bytes, language) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            _assertClass(language, Language);\n            wasm.plutusscript_from_bytes_with_version(retptr, ptr0, len0, language.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PlutusScript.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Same as .from_hex but will consider the script as requiring the specified language version\n    * @param {string} hex_str\n    * @param {Language} language\n    * @returns {PlutusScript}\n    */\n    static from_hex_with_version(hex_str, language) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            _assertClass(language, Language);\n            wasm.plutusscript_from_hex_with_version(retptr, ptr0, len0, language.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PlutusScript.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {ScriptHash}\n    */\n    hash() {\n        const ret = wasm.plutusscript_hash(this.__wbg_ptr);\n        return ScriptHash.__wrap(ret);\n    }\n    /**\n    * @returns {Language}\n    */\n    language_version() {\n        const ret = wasm.plutusscript_language_version(this.__wbg_ptr);\n        return Language.__wrap(ret);\n    }\n}\n/**\n*/\nclass PlutusScriptSource {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PlutusScriptSource.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutusscriptsource_free(ptr);\n    }\n    /**\n    * @param {PlutusScript} script\n    * @returns {PlutusScriptSource}\n    */\n    static new(script) {\n        _assertClass(script, PlutusScript);\n        const ret = wasm.plutusscriptsource_new(script.__wbg_ptr);\n        return PlutusScriptSource.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * This constructor has missed information about plutus script language vesrion. That can affect\n    * the script data hash calculation.\n    * Use `.new_ref_input_with_lang_ver` instead\n    * @param {ScriptHash} script_hash\n    * @param {TransactionInput} input\n    * @returns {PlutusScriptSource}\n    */\n    static new_ref_input(script_hash, input) {\n        _assertClass(script_hash, ScriptHash);\n        _assertClass(input, TransactionInput);\n        const ret = wasm.plutusscriptsource_new_ref_input(script_hash.__wbg_ptr, input.__wbg_ptr);\n        return PlutusScriptSource.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} script_hash\n    * @param {TransactionInput} input\n    * @param {Language} lang_ver\n    * @returns {PlutusScriptSource}\n    */\n    static new_ref_input_with_lang_ver(script_hash, input, lang_ver) {\n        _assertClass(script_hash, ScriptHash);\n        _assertClass(input, TransactionInput);\n        _assertClass(lang_ver, Language);\n        const ret = wasm.plutusscriptsource_new_ref_input_with_lang_ver(script_hash.__wbg_ptr, input.__wbg_ptr, lang_ver.__wbg_ptr);\n        return PlutusScriptSource.__wrap(ret);\n    }\n}\n/**\n*/\nclass PlutusScripts {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PlutusScripts.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutusscripts_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusscripts_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusScripts}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.plutusscripts_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PlutusScripts.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusscripts_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {PlutusScripts}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.plutusscripts_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PlutusScripts.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusscripts_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusscripts_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {PlutusScripts}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.plutusscripts_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PlutusScripts.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {PlutusScripts}\n    */\n    static new() {\n        const ret = wasm.plutusscripts_new();\n        return PlutusScripts.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.costmdls_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {PlutusScript}\n    */\n    get(index) {\n        const ret = wasm.plutusscripts_get(this.__wbg_ptr, index);\n        return PlutusScript.__wrap(ret);\n    }\n    /**\n    * @param {PlutusScript} elem\n    */\n    add(elem) {\n        _assertClass(elem, PlutusScript);\n        wasm.plutusscripts_add(this.__wbg_ptr, elem.__wbg_ptr);\n    }\n}\n/**\n*/\nclass PlutusWitness {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PlutusWitness.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutuswitness_free(ptr);\n    }\n    /**\n    * @param {PlutusScript} script\n    * @param {PlutusData} datum\n    * @param {Redeemer} redeemer\n    * @returns {PlutusWitness}\n    */\n    static new(script, datum, redeemer) {\n        _assertClass(script, PlutusScript);\n        _assertClass(datum, PlutusData);\n        _assertClass(redeemer, Redeemer);\n        const ret = wasm.plutuswitness_new(script.__wbg_ptr, datum.__wbg_ptr, redeemer.__wbg_ptr);\n        return PlutusWitness.__wrap(ret);\n    }\n    /**\n    * @param {PlutusScriptSource} script\n    * @param {DatumSource} datum\n    * @param {Redeemer} redeemer\n    * @returns {PlutusWitness}\n    */\n    static new_with_ref(script, datum, redeemer) {\n        _assertClass(script, PlutusScriptSource);\n        _assertClass(datum, DatumSource);\n        _assertClass(redeemer, Redeemer);\n        const ret = wasm.plutuswitness_new_with_ref(script.__wbg_ptr, datum.__wbg_ptr, redeemer.__wbg_ptr);\n        return PlutusWitness.__wrap(ret);\n    }\n    /**\n    * @param {PlutusScript} script\n    * @param {Redeemer} redeemer\n    * @returns {PlutusWitness}\n    */\n    static new_without_datum(script, redeemer) {\n        _assertClass(script, PlutusScript);\n        _assertClass(redeemer, Redeemer);\n        const ret = wasm.plutuswitness_new_without_datum(script.__wbg_ptr, redeemer.__wbg_ptr);\n        return PlutusWitness.__wrap(ret);\n    }\n    /**\n    * @param {PlutusScriptSource} script\n    * @param {Redeemer} redeemer\n    * @returns {PlutusWitness}\n    */\n    static new_with_ref_without_datum(script, redeemer) {\n        _assertClass(script, PlutusScriptSource);\n        _assertClass(redeemer, Redeemer);\n        const ret = wasm.plutuswitness_new_with_ref_without_datum(script.__wbg_ptr, redeemer.__wbg_ptr);\n        return PlutusWitness.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusScript | undefined}\n    */\n    script() {\n        const ret = wasm.plutuswitness_script(this.__wbg_ptr);\n        return ret === 0 ? undefined : PlutusScript.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusData | undefined}\n    */\n    datum() {\n        const ret = wasm.plutuswitness_datum(this.__wbg_ptr);\n        return ret === 0 ? undefined : PlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {Redeemer}\n    */\n    redeemer() {\n        const ret = wasm.plutuswitness_redeemer(this.__wbg_ptr);\n        return Redeemer.__wrap(ret);\n    }\n}\n/**\n*/\nclass PlutusWitnesses {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PlutusWitnesses.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutuswitnesses_free(ptr);\n    }\n    /**\n    * @returns {PlutusWitnesses}\n    */\n    static new() {\n        const ret = wasm.plutuswitnesses_new();\n        return PlutusWitnesses.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.governanceactionids_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {PlutusWitness}\n    */\n    get(index) {\n        const ret = wasm.plutuswitnesses_get(this.__wbg_ptr, index);\n        return PlutusWitness.__wrap(ret);\n    }\n    /**\n    * @param {PlutusWitness} elem\n    */\n    add(elem) {\n        _assertClass(elem, PlutusWitness);\n        wasm.plutuswitnesses_add(this.__wbg_ptr, elem.__wbg_ptr);\n    }\n}\n/**\n*/\nclass Pointer {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Pointer.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_pointer_free(ptr);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * This constructor uses outdated slot number format for the ttl value, tx_index and cert_index.\n    * Use `.new_pointer` instead\n    * @param {number} slot\n    * @param {number} tx_index\n    * @param {number} cert_index\n    * @returns {Pointer}\n    */\n    static new(slot, tx_index, cert_index) {\n        const ret = wasm.pointer_new(slot, tx_index, cert_index);\n        return Pointer.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} slot\n    * @param {BigNum} tx_index\n    * @param {BigNum} cert_index\n    * @returns {Pointer}\n    */\n    static new_pointer(slot, tx_index, cert_index) {\n        _assertClass(slot, BigNum);\n        _assertClass(tx_index, BigNum);\n        _assertClass(cert_index, BigNum);\n        const ret = wasm.pointer_new_pointer(slot.__wbg_ptr, tx_index.__wbg_ptr, cert_index.__wbg_ptr);\n        return Pointer.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    slot() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.pointer_slot(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number}\n    */\n    tx_index() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.pointer_tx_index(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number}\n    */\n    cert_index() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.pointer_cert_index(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {BigNum}\n    */\n    slot_bignum() {\n        const ret = wasm.pointer_slot_bignum(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    tx_index_bignum() {\n        const ret = wasm.pointer_tx_index_bignum(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    cert_index_bignum() {\n        const ret = wasm.pointer_cert_index_bignum(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n}\n/**\n*/\nclass PointerAddress {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PointerAddress.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_pointeraddress_free(ptr);\n    }\n    /**\n    * @param {number} network\n    * @param {Credential} payment\n    * @param {Pointer} stake\n    * @returns {PointerAddress}\n    */\n    static new(network, payment, stake) {\n        _assertClass(payment, Credential);\n        _assertClass(stake, Pointer);\n        const ret = wasm.pointeraddress_new(network, payment.__wbg_ptr, stake.__wbg_ptr);\n        return PointerAddress.__wrap(ret);\n    }\n    /**\n    * @returns {Credential}\n    */\n    payment_cred() {\n        const ret = wasm.pointeraddress_payment_cred(this.__wbg_ptr);\n        return Credential.__wrap(ret);\n    }\n    /**\n    * @returns {Pointer}\n    */\n    stake_pointer() {\n        const ret = wasm.pointeraddress_stake_pointer(this.__wbg_ptr);\n        return Pointer.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        const ret = wasm.pointeraddress_to_address(this.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {PointerAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        const ret = wasm.pointeraddress_from_address(addr.__wbg_ptr);\n        return ret === 0 ? undefined : PointerAddress.__wrap(ret);\n    }\n}\n/**\n*/\nclass PoolMetadata {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PoolMetadata.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poolmetadata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolmetadata_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolMetadata}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poolmetadata_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PoolMetadata.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolmetadata_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {PoolMetadata}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poolmetadata_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PoolMetadata.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolmetadata_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolmetadata_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {PoolMetadata}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poolmetadata_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PoolMetadata.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {URL}\n    */\n    url() {\n        const ret = wasm.poolmetadata_url(this.__wbg_ptr);\n        return URL.__wrap(ret);\n    }\n    /**\n    * @returns {PoolMetadataHash}\n    */\n    pool_metadata_hash() {\n        const ret = wasm.poolmetadata_pool_metadata_hash(this.__wbg_ptr);\n        return PoolMetadataHash.__wrap(ret);\n    }\n    /**\n    * @param {URL} url\n    * @param {PoolMetadataHash} pool_metadata_hash\n    * @returns {PoolMetadata}\n    */\n    static new(url, pool_metadata_hash) {\n        _assertClass(url, URL);\n        _assertClass(pool_metadata_hash, PoolMetadataHash);\n        const ret = wasm.poolmetadata_new(url.__wbg_ptr, pool_metadata_hash.__wbg_ptr);\n        return PoolMetadata.__wrap(ret);\n    }\n}\n/**\n*/\nclass PoolMetadataHash {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PoolMetadataHash.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poolmetadatahash_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolMetadataHash}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poolmetadatahash_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PoolMetadataHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchordatahash_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.anchordatahash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {PoolMetadataHash}\n    */\n    static from_bech32(bech_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poolmetadatahash_from_bech32(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PoolMetadataHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchordatahash_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {PoolMetadataHash}\n    */\n    static from_hex(hex) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poolmetadatahash_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PoolMetadataHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass PoolParams {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PoolParams.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poolparams_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolparams_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolParams}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poolparams_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PoolParams.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolparams_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {PoolParams}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poolparams_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PoolParams.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolparams_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolparams_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {PoolParams}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poolparams_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PoolParams.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    operator() {\n        const ret = wasm.poolparams_operator(this.__wbg_ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {VRFKeyHash}\n    */\n    vrf_keyhash() {\n        const ret = wasm.poolparams_vrf_keyhash(this.__wbg_ptr);\n        return VRFKeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    pledge() {\n        const ret = wasm.poolparams_pledge(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    cost() {\n        const ret = wasm.poolparams_cost(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    margin() {\n        const ret = wasm.poolparams_margin(this.__wbg_ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {RewardAddress}\n    */\n    reward_account() {\n        const ret = wasm.poolparams_reward_account(this.__wbg_ptr);\n        return RewardAddress.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHashes}\n    */\n    pool_owners() {\n        const ret = wasm.poolparams_pool_owners(this.__wbg_ptr);\n        return Ed25519KeyHashes.__wrap(ret);\n    }\n    /**\n    * @returns {Relays}\n    */\n    relays() {\n        const ret = wasm.poolparams_relays(this.__wbg_ptr);\n        return Relays.__wrap(ret);\n    }\n    /**\n    * @returns {PoolMetadata | undefined}\n    */\n    pool_metadata() {\n        const ret = wasm.poolparams_pool_metadata(this.__wbg_ptr);\n        return ret === 0 ? undefined : PoolMetadata.__wrap(ret);\n    }\n    /**\n    * @param {Ed25519KeyHash} operator\n    * @param {VRFKeyHash} vrf_keyhash\n    * @param {BigNum} pledge\n    * @param {BigNum} cost\n    * @param {UnitInterval} margin\n    * @param {RewardAddress} reward_account\n    * @param {Ed25519KeyHashes} pool_owners\n    * @param {Relays} relays\n    * @param {PoolMetadata | undefined} pool_metadata\n    * @returns {PoolParams}\n    */\n    static new(operator, vrf_keyhash, pledge, cost, margin, reward_account, pool_owners, relays, pool_metadata) {\n        _assertClass(operator, Ed25519KeyHash);\n        _assertClass(vrf_keyhash, VRFKeyHash);\n        _assertClass(pledge, BigNum);\n        _assertClass(cost, BigNum);\n        _assertClass(margin, UnitInterval);\n        _assertClass(reward_account, RewardAddress);\n        _assertClass(pool_owners, Ed25519KeyHashes);\n        _assertClass(relays, Relays);\n        let ptr0 = 0;\n        if (!isLikeNone(pool_metadata)) {\n            _assertClass(pool_metadata, PoolMetadata);\n            ptr0 = pool_metadata.__destroy_into_raw();\n        }\n        const ret = wasm.poolparams_new(operator.__wbg_ptr, vrf_keyhash.__wbg_ptr, pledge.__wbg_ptr, cost.__wbg_ptr, margin.__wbg_ptr, reward_account.__wbg_ptr, pool_owners.__wbg_ptr, relays.__wbg_ptr, ptr0);\n        return PoolParams.__wrap(ret);\n    }\n}\n/**\n*/\nclass PoolRegistration {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PoolRegistration.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poolregistration_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolregistration_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolRegistration}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poolregistration_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PoolRegistration.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolregistration_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {PoolRegistration}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poolregistration_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PoolRegistration.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolregistration_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolregistration_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {PoolRegistration}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poolregistration_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PoolRegistration.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {PoolParams}\n    */\n    pool_params() {\n        const ret = wasm.poolregistration_pool_params(this.__wbg_ptr);\n        return PoolParams.__wrap(ret);\n    }\n    /**\n    * @param {PoolParams} pool_params\n    * @returns {PoolRegistration}\n    */\n    static new(pool_params) {\n        _assertClass(pool_params, PoolParams);\n        const ret = wasm.poolregistration_new(pool_params.__wbg_ptr);\n        return PoolRegistration.__wrap(ret);\n    }\n}\n/**\n*/\nclass PoolRetirement {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PoolRetirement.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poolretirement_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolretirement_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolRetirement}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poolretirement_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PoolRetirement.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolretirement_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {PoolRetirement}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poolretirement_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PoolRetirement.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolretirement_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolretirement_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {PoolRetirement}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poolretirement_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PoolRetirement.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    pool_keyhash() {\n        const ret = wasm.poolretirement_pool_keyhash(this.__wbg_ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    epoch() {\n        const ret = wasm.poolretirement_epoch(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {Ed25519KeyHash} pool_keyhash\n    * @param {number} epoch\n    * @returns {PoolRetirement}\n    */\n    static new(pool_keyhash, epoch) {\n        _assertClass(pool_keyhash, Ed25519KeyHash);\n        const ret = wasm.poolretirement_new(pool_keyhash.__wbg_ptr, epoch);\n        return PoolRetirement.__wrap(ret);\n    }\n}\n/**\n*/\nclass PoolVotingThresholds {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PoolVotingThresholds.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poolvotingthresholds_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolvotingthresholds_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolVotingThresholds}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poolvotingthresholds_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PoolVotingThresholds.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolvotingthresholds_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {PoolVotingThresholds}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poolvotingthresholds_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PoolVotingThresholds.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolvotingthresholds_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolvotingthresholds_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {PoolVotingThresholds}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poolvotingthresholds_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PoolVotingThresholds.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {UnitInterval} motion_no_confidence\n    * @param {UnitInterval} committee_normal\n    * @param {UnitInterval} committee_no_confidence\n    * @param {UnitInterval} hard_fork_initiation\n    * @returns {PoolVotingThresholds}\n    */\n    static new(motion_no_confidence, committee_normal, committee_no_confidence, hard_fork_initiation) {\n        _assertClass(motion_no_confidence, UnitInterval);\n        _assertClass(committee_normal, UnitInterval);\n        _assertClass(committee_no_confidence, UnitInterval);\n        _assertClass(hard_fork_initiation, UnitInterval);\n        const ret = wasm.poolvotingthresholds_new(motion_no_confidence.__wbg_ptr, committee_normal.__wbg_ptr, committee_no_confidence.__wbg_ptr, hard_fork_initiation.__wbg_ptr);\n        return PoolVotingThresholds.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    motion_no_confidence() {\n        const ret = wasm.drepvotingthresholds_motion_no_confidence(this.__wbg_ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    committee_normal() {\n        const ret = wasm.drepvotingthresholds_committee_normal(this.__wbg_ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    committee_no_confidence() {\n        const ret = wasm.drepvotingthresholds_committee_no_confidence(this.__wbg_ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    hard_fork_initiation() {\n        const ret = wasm.drepvotingthresholds_update_constitution(this.__wbg_ptr);\n        return UnitInterval.__wrap(ret);\n    }\n}\n/**\n*/\nclass PrivateKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PrivateKey.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_privatekey_free(ptr);\n    }\n    /**\n    * @returns {PublicKey}\n    */\n    to_public() {\n        const ret = wasm.privatekey_to_public(this.__wbg_ptr);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n    * @returns {PrivateKey}\n    */\n    static generate_ed25519() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.privatekey_generate_ed25519(retptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {PrivateKey}\n    */\n    static generate_ed25519extended() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.privatekey_generate_ed25519extended(retptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get private key from its bech32 representation\n    * ```javascript\n    * PrivateKey.from_bech32(&#39;ed25519_sk1ahfetf02qwwg4dkq7mgp4a25lx5vh9920cr5wnxmpzz9906qvm8qwvlts0&#39;);\n    * ```\n    * For an extended 25519 key\n    * ```javascript\n    * PrivateKey.from_bech32(&#39;ed25519e_sk1gqwl4szuwwh6d0yk3nsqcc6xxc3fpvjlevgwvt60df59v8zd8f8prazt8ln3lmz096ux3xvhhvm3ca9wj2yctdh3pnw0szrma07rt5gl748fp&#39;);\n    * ```\n    * @param {string} bech32_str\n    * @returns {PrivateKey}\n    */\n    static from_bech32(bech32_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_from_bech32(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.privatekey_to_bech32(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.privatekey_as_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PrivateKey}\n    */\n    static from_extended_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_from_extended_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PrivateKey}\n    */\n    static from_normal_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_from_normal_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} message\n    * @returns {Ed25519Signature}\n    */\n    sign(message) {\n        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.privatekey_sign(this.__wbg_ptr, ptr0, len0);\n        return Ed25519Signature.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.privatekey_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {PrivateKey}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass ProposedProtocolParameterUpdates {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ProposedProtocolParameterUpdates.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_proposedprotocolparameterupdates_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.proposedprotocolparameterupdates_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ProposedProtocolParameterUpdates}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.proposedprotocolparameterupdates_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProposedProtocolParameterUpdates.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.proposedprotocolparameterupdates_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ProposedProtocolParameterUpdates}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.proposedprotocolparameterupdates_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProposedProtocolParameterUpdates.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.proposedprotocolparameterupdates_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.proposedprotocolparameterupdates_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {ProposedProtocolParameterUpdates}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.proposedprotocolparameterupdates_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProposedProtocolParameterUpdates.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {ProposedProtocolParameterUpdates}\n    */\n    static new() {\n        const ret = wasm.auxiliarydataset_new();\n        return ProposedProtocolParameterUpdates.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.auxiliarydataset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {GenesisHash} key\n    * @param {ProtocolParamUpdate} value\n    * @returns {ProtocolParamUpdate | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, GenesisHash);\n        _assertClass(value, ProtocolParamUpdate);\n        const ret = wasm.proposedprotocolparameterupdates_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);\n        return ret === 0 ? undefined : ProtocolParamUpdate.__wrap(ret);\n    }\n    /**\n    * @param {GenesisHash} key\n    * @returns {ProtocolParamUpdate | undefined}\n    */\n    get(key) {\n        _assertClass(key, GenesisHash);\n        const ret = wasm.proposedprotocolparameterupdates_get(this.__wbg_ptr, key.__wbg_ptr);\n        return ret === 0 ? undefined : ProtocolParamUpdate.__wrap(ret);\n    }\n    /**\n    * @returns {GenesisHashes}\n    */\n    keys() {\n        const ret = wasm.proposedprotocolparameterupdates_keys(this.__wbg_ptr);\n        return GenesisHashes.__wrap(ret);\n    }\n}\n/**\n*/\nclass ProtocolParamUpdate {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ProtocolParamUpdate.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_protocolparamupdate_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ProtocolParamUpdate}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.protocolparamupdate_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProtocolParamUpdate.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ProtocolParamUpdate}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.protocolparamupdate_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProtocolParamUpdate.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {ProtocolParamUpdate}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.protocolparamupdate_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProtocolParamUpdate.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {BigNum} minfee_a\n    */\n    set_minfee_a(minfee_a) {\n        _assertClass(minfee_a, BigNum);\n        wasm.protocolparamupdate_set_minfee_a(this.__wbg_ptr, minfee_a.__wbg_ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    minfee_a() {\n        const ret = wasm.protocolparamupdate_minfee_a(this.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} minfee_b\n    */\n    set_minfee_b(minfee_b) {\n        _assertClass(minfee_b, BigNum);\n        wasm.protocolparamupdate_set_minfee_b(this.__wbg_ptr, minfee_b.__wbg_ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    minfee_b() {\n        const ret = wasm.protocolparamupdate_minfee_b(this.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {number} max_block_body_size\n    */\n    set_max_block_body_size(max_block_body_size) {\n        wasm.protocolparamupdate_set_max_block_body_size(this.__wbg_ptr, max_block_body_size);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_block_body_size() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_max_block_body_size(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} max_tx_size\n    */\n    set_max_tx_size(max_tx_size) {\n        wasm.protocolparamupdate_set_max_tx_size(this.__wbg_ptr, max_tx_size);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_tx_size() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_max_tx_size(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} max_block_header_size\n    */\n    set_max_block_header_size(max_block_header_size) {\n        wasm.protocolparamupdate_set_max_block_header_size(this.__wbg_ptr, max_block_header_size);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_block_header_size() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_max_block_header_size(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {BigNum} key_deposit\n    */\n    set_key_deposit(key_deposit) {\n        _assertClass(key_deposit, BigNum);\n        wasm.protocolparamupdate_set_key_deposit(this.__wbg_ptr, key_deposit.__wbg_ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    key_deposit() {\n        const ret = wasm.protocolparamupdate_key_deposit(this.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} pool_deposit\n    */\n    set_pool_deposit(pool_deposit) {\n        _assertClass(pool_deposit, BigNum);\n        wasm.protocolparamupdate_set_pool_deposit(this.__wbg_ptr, pool_deposit.__wbg_ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    pool_deposit() {\n        const ret = wasm.protocolparamupdate_pool_deposit(this.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {number} max_epoch\n    */\n    set_max_epoch(max_epoch) {\n        wasm.protocolparamupdate_set_max_epoch(this.__wbg_ptr, max_epoch);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_epoch() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_max_epoch(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} n_opt\n    */\n    set_n_opt(n_opt) {\n        wasm.protocolparamupdate_set_n_opt(this.__wbg_ptr, n_opt);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    n_opt() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_n_opt(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {UnitInterval} pool_pledge_influence\n    */\n    set_pool_pledge_influence(pool_pledge_influence) {\n        _assertClass(pool_pledge_influence, UnitInterval);\n        wasm.protocolparamupdate_set_pool_pledge_influence(this.__wbg_ptr, pool_pledge_influence.__wbg_ptr);\n    }\n    /**\n    * @returns {UnitInterval | undefined}\n    */\n    pool_pledge_influence() {\n        const ret = wasm.protocolparamupdate_pool_pledge_influence(this.__wbg_ptr);\n        return ret === 0 ? undefined : UnitInterval.__wrap(ret);\n    }\n    /**\n    * @param {UnitInterval} expansion_rate\n    */\n    set_expansion_rate(expansion_rate) {\n        _assertClass(expansion_rate, UnitInterval);\n        wasm.protocolparamupdate_set_expansion_rate(this.__wbg_ptr, expansion_rate.__wbg_ptr);\n    }\n    /**\n    * @returns {UnitInterval | undefined}\n    */\n    expansion_rate() {\n        const ret = wasm.protocolparamupdate_expansion_rate(this.__wbg_ptr);\n        return ret === 0 ? undefined : UnitInterval.__wrap(ret);\n    }\n    /**\n    * @param {UnitInterval} treasury_growth_rate\n    */\n    set_treasury_growth_rate(treasury_growth_rate) {\n        _assertClass(treasury_growth_rate, UnitInterval);\n        wasm.protocolparamupdate_set_treasury_growth_rate(this.__wbg_ptr, treasury_growth_rate.__wbg_ptr);\n    }\n    /**\n    * @returns {UnitInterval | undefined}\n    */\n    treasury_growth_rate() {\n        const ret = wasm.protocolparamupdate_treasury_growth_rate(this.__wbg_ptr);\n        return ret === 0 ? undefined : UnitInterval.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Since babbage era this param is outdated. But this param you can meet in a pre-babbage block.\n    * @returns {UnitInterval | undefined}\n    */\n    d() {\n        const ret = wasm.protocolparamupdate_d(this.__wbg_ptr);\n        return ret === 0 ? undefined : UnitInterval.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Since babbage era this param is outdated. But this param you can meet in a pre-babbage block.\n    * @returns {Nonce | undefined}\n    */\n    extra_entropy() {\n        const ret = wasm.protocolparamupdate_extra_entropy(this.__wbg_ptr);\n        return ret === 0 ? undefined : Nonce.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Since conway era this param is outdated. But this param you can meet in a pre-conway block.\n    * @param {ProtocolVersion} protocol_version\n    */\n    set_protocol_version(protocol_version) {\n        _assertClass(protocol_version, ProtocolVersion);\n        wasm.protocolparamupdate_set_protocol_version(this.__wbg_ptr, protocol_version.__wbg_ptr);\n    }\n    /**\n    * @returns {ProtocolVersion | undefined}\n    */\n    protocol_version() {\n        const ret = wasm.protocolparamupdate_protocol_version(this.__wbg_ptr);\n        return ret === 0 ? undefined : ProtocolVersion.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} min_pool_cost\n    */\n    set_min_pool_cost(min_pool_cost) {\n        _assertClass(min_pool_cost, BigNum);\n        wasm.protocolparamupdate_set_min_pool_cost(this.__wbg_ptr, min_pool_cost.__wbg_ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    min_pool_cost() {\n        const ret = wasm.protocolparamupdate_min_pool_cost(this.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} ada_per_utxo_byte\n    */\n    set_ada_per_utxo_byte(ada_per_utxo_byte) {\n        _assertClass(ada_per_utxo_byte, BigNum);\n        wasm.protocolparamupdate_set_ada_per_utxo_byte(this.__wbg_ptr, ada_per_utxo_byte.__wbg_ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    ada_per_utxo_byte() {\n        const ret = wasm.protocolparamupdate_ada_per_utxo_byte(this.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {Costmdls} cost_models\n    */\n    set_cost_models(cost_models) {\n        _assertClass(cost_models, Costmdls);\n        wasm.protocolparamupdate_set_cost_models(this.__wbg_ptr, cost_models.__wbg_ptr);\n    }\n    /**\n    * @returns {Costmdls | undefined}\n    */\n    cost_models() {\n        const ret = wasm.protocolparamupdate_cost_models(this.__wbg_ptr);\n        return ret === 0 ? undefined : Costmdls.__wrap(ret);\n    }\n    /**\n    * @param {ExUnitPrices} execution_costs\n    */\n    set_execution_costs(execution_costs) {\n        _assertClass(execution_costs, ExUnitPrices);\n        wasm.protocolparamupdate_set_execution_costs(this.__wbg_ptr, execution_costs.__wbg_ptr);\n    }\n    /**\n    * @returns {ExUnitPrices | undefined}\n    */\n    execution_costs() {\n        const ret = wasm.protocolparamupdate_execution_costs(this.__wbg_ptr);\n        return ret === 0 ? undefined : ExUnitPrices.__wrap(ret);\n    }\n    /**\n    * @param {ExUnits} max_tx_ex_units\n    */\n    set_max_tx_ex_units(max_tx_ex_units) {\n        _assertClass(max_tx_ex_units, ExUnits);\n        wasm.protocolparamupdate_set_max_tx_ex_units(this.__wbg_ptr, max_tx_ex_units.__wbg_ptr);\n    }\n    /**\n    * @returns {ExUnits | undefined}\n    */\n    max_tx_ex_units() {\n        const ret = wasm.protocolparamupdate_max_tx_ex_units(this.__wbg_ptr);\n        return ret === 0 ? undefined : ExUnits.__wrap(ret);\n    }\n    /**\n    * @param {ExUnits} max_block_ex_units\n    */\n    set_max_block_ex_units(max_block_ex_units) {\n        _assertClass(max_block_ex_units, ExUnits);\n        wasm.protocolparamupdate_set_max_block_ex_units(this.__wbg_ptr, max_block_ex_units.__wbg_ptr);\n    }\n    /**\n    * @returns {ExUnits | undefined}\n    */\n    max_block_ex_units() {\n        const ret = wasm.protocolparamupdate_max_block_ex_units(this.__wbg_ptr);\n        return ret === 0 ? undefined : ExUnits.__wrap(ret);\n    }\n    /**\n    * @param {number} max_value_size\n    */\n    set_max_value_size(max_value_size) {\n        wasm.protocolparamupdate_set_max_value_size(this.__wbg_ptr, max_value_size);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_value_size() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_max_value_size(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} collateral_percentage\n    */\n    set_collateral_percentage(collateral_percentage) {\n        wasm.protocolparamupdate_set_collateral_percentage(this.__wbg_ptr, collateral_percentage);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    collateral_percentage() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_collateral_percentage(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} max_collateral_inputs\n    */\n    set_max_collateral_inputs(max_collateral_inputs) {\n        wasm.protocolparamupdate_set_max_collateral_inputs(this.__wbg_ptr, max_collateral_inputs);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_collateral_inputs() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_max_collateral_inputs(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {PoolVotingThresholds} pool_voting_thresholds\n    */\n    set_pool_voting_thresholds(pool_voting_thresholds) {\n        _assertClass(pool_voting_thresholds, PoolVotingThresholds);\n        wasm.protocolparamupdate_set_pool_voting_thresholds(this.__wbg_ptr, pool_voting_thresholds.__wbg_ptr);\n    }\n    /**\n    * @returns {PoolVotingThresholds | undefined}\n    */\n    pool_voting_thresholds() {\n        const ret = wasm.protocolparamupdate_pool_voting_thresholds(this.__wbg_ptr);\n        return ret === 0 ? undefined : PoolVotingThresholds.__wrap(ret);\n    }\n    /**\n    * @param {DrepVotingThresholds} drep_voting_thresholds\n    */\n    set_drep_voting_thresholds(drep_voting_thresholds) {\n        _assertClass(drep_voting_thresholds, DrepVotingThresholds);\n        wasm.protocolparamupdate_set_drep_voting_thresholds(this.__wbg_ptr, drep_voting_thresholds.__wbg_ptr);\n    }\n    /**\n    * @returns {DrepVotingThresholds | undefined}\n    */\n    drep_voting_thresholds() {\n        const ret = wasm.protocolparamupdate_drep_voting_thresholds(this.__wbg_ptr);\n        return ret === 0 ? undefined : DrepVotingThresholds.__wrap(ret);\n    }\n    /**\n    * @param {number} min_committee_size\n    */\n    set_min_committee_size(min_committee_size) {\n        wasm.protocolparamupdate_set_min_committee_size(this.__wbg_ptr, min_committee_size);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    min_committee_size() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_min_committee_size(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} committee_term_limit\n    */\n    set_committee_term_limit(committee_term_limit) {\n        wasm.protocolparamupdate_set_committee_term_limit(this.__wbg_ptr, committee_term_limit);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    committee_term_limit() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_committee_term_limit(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} governance_action_validity_period\n    */\n    set_governance_action_validity_period(governance_action_validity_period) {\n        wasm.protocolparamupdate_set_governance_action_validity_period(this.__wbg_ptr, governance_action_validity_period);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    governance_action_validity_period() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_governance_action_validity_period(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {BigNum} governance_action_deposit\n    */\n    set_governance_action_deposit(governance_action_deposit) {\n        _assertClass(governance_action_deposit, BigNum);\n        wasm.protocolparamupdate_set_governance_action_deposit(this.__wbg_ptr, governance_action_deposit.__wbg_ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    governance_action_deposit() {\n        const ret = wasm.protocolparamupdate_governance_action_deposit(this.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} drep_deposit\n    */\n    set_drep_deposit(drep_deposit) {\n        _assertClass(drep_deposit, BigNum);\n        wasm.protocolparamupdate_set_drep_deposit(this.__wbg_ptr, drep_deposit.__wbg_ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    drep_deposit() {\n        const ret = wasm.protocolparamupdate_drep_deposit(this.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {number} drep_inactivity_period\n    */\n    set_drep_inactivity_period(drep_inactivity_period) {\n        wasm.protocolparamupdate_set_drep_inactivity_period(this.__wbg_ptr, drep_inactivity_period);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    drep_inactivity_period() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_drep_inactivity_period(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {ProtocolParamUpdate}\n    */\n    static new() {\n        const ret = wasm.protocolparamupdate_new();\n        return ProtocolParamUpdate.__wrap(ret);\n    }\n}\n/**\n*/\nclass ProtocolVersion {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ProtocolVersion.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_protocolversion_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolversion_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ProtocolVersion}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.protocolversion_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProtocolVersion.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolversion_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ProtocolVersion}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.protocolversion_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProtocolVersion.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolversion_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolversion_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {ProtocolVersion}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.protocolversion_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProtocolVersion.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number}\n    */\n    major() {\n        const ret = wasm.protocolversion_major(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    minor() {\n        const ret = wasm.protocolversion_minor(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} major\n    * @param {number} minor\n    * @returns {ProtocolVersion}\n    */\n    static new(major, minor) {\n        const ret = wasm.protocolversion_new(major, minor);\n        return ProtocolVersion.__wrap(ret);\n    }\n}\n/**\n* ED25519 key used as public key\n*/\nclass PublicKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PublicKey.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_publickey_free(ptr);\n    }\n    /**\n    * Get public key from its bech32 representation\n    * Example:\n    * ```javascript\n    * const pkey = PublicKey.from_bech32(&#39;ed25519_pk1dgaagyh470y66p899txcl3r0jaeaxu6yd7z2dxyk55qcycdml8gszkxze2&#39;);\n    * ```\n    * @param {string} bech32_str\n    * @returns {PublicKey}\n    */\n    static from_bech32(bech32_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.publickey_from_bech32(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PublicKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.publickey_to_bech32(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchordatahash_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PublicKey}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.publickey_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PublicKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} data\n    * @param {Ed25519Signature} signature\n    * @returns {boolean}\n    */\n    verify(data, signature) {\n        const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(signature, Ed25519Signature);\n        const ret = wasm.publickey_verify(this.__wbg_ptr, ptr0, len0, signature.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    hash() {\n        const ret = wasm.publickey_hash(this.__wbg_ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.publickey_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {PublicKey}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.publickey_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PublicKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass PublicKeys {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PublicKeys.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_publickeys_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.publickeys_new();\n        return PublicKeys.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    size() {\n        const ret = wasm.bootstrapwitnesses_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {PublicKey}\n    */\n    get(index) {\n        const ret = wasm.publickeys_get(this.__wbg_ptr, index);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n    * @param {PublicKey} key\n    */\n    add(key) {\n        _assertClass(key, PublicKey);\n        wasm.publickeys_add(this.__wbg_ptr, key.__wbg_ptr);\n    }\n}\n/**\n*/\nclass Redeemer {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Redeemer.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_redeemer_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemer_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Redeemer}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.redeemer_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Redeemer.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemer_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Redeemer}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.redeemer_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Redeemer.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemer_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemer_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Redeemer}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.redeemer_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Redeemer.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    tag() {\n        const ret = wasm.redeemer_tag(this.__wbg_ptr);\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    index() {\n        const ret = wasm.redeemer_index(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusData}\n    */\n    data() {\n        const ret = wasm.redeemer_data(this.__wbg_ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {ExUnits}\n    */\n    ex_units() {\n        const ret = wasm.redeemer_ex_units(this.__wbg_ptr);\n        return ExUnits.__wrap(ret);\n    }\n    /**\n    * @param {RedeemerTag} tag\n    * @param {BigNum} index\n    * @param {PlutusData} data\n    * @param {ExUnits} ex_units\n    * @returns {Redeemer}\n    */\n    static new(tag, index, data, ex_units) {\n        _assertClass(tag, RedeemerTag);\n        _assertClass(index, BigNum);\n        _assertClass(data, PlutusData);\n        _assertClass(ex_units, ExUnits);\n        const ret = wasm.redeemer_new(tag.__wbg_ptr, index.__wbg_ptr, data.__wbg_ptr, ex_units.__wbg_ptr);\n        return Redeemer.__wrap(ret);\n    }\n}\n/**\n*/\nclass RedeemerTag {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RedeemerTag.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_redeemertag_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemertag_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {RedeemerTag}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.redeemertag_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return RedeemerTag.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemertag_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {RedeemerTag}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.redeemertag_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return RedeemerTag.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemertag_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemertag_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {RedeemerTag}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.redeemertag_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return RedeemerTag.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    static new_spend() {\n        const ret = wasm.language_new_plutus_v1();\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    static new_mint() {\n        const ret = wasm.language_new_plutus_v2();\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    static new_cert() {\n        const ret = wasm.language_new_plutus_v3();\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    static new_reward() {\n        const ret = wasm.redeemertag_new_reward();\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    static new_vote() {\n        const ret = wasm.redeemertag_new_vote();\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    static new_voting_proposal() {\n        const ret = wasm.redeemertag_new_voting_proposal();\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        const ret = wasm.redeemertag_kind(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nclass Redeemers {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Redeemers.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_redeemers_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemers_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Redeemers}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.redeemers_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Redeemers.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemers_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Redeemers}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.redeemers_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Redeemers.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemers_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemers_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Redeemers}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.redeemers_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Redeemers.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Redeemers}\n    */\n    static new() {\n        const ret = wasm.costmodel_new();\n        return Redeemers.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.costmdls_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Redeemer}\n    */\n    get(index) {\n        const ret = wasm.redeemers_get(this.__wbg_ptr, index);\n        return Redeemer.__wrap(ret);\n    }\n    /**\n    * @param {Redeemer} elem\n    */\n    add(elem) {\n        _assertClass(elem, Redeemer);\n        wasm.redeemers_add(this.__wbg_ptr, elem.__wbg_ptr);\n    }\n    /**\n    * @returns {ExUnits}\n    */\n    total_ex_units() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemers_total_ex_units(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExUnits.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass Relay {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Relay.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_relay_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.relay_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Relay}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.relay_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Relay.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.relay_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Relay}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.relay_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Relay.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.relay_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.relay_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Relay}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.relay_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Relay.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {SingleHostAddr} single_host_addr\n    * @returns {Relay}\n    */\n    static new_single_host_addr(single_host_addr) {\n        _assertClass(single_host_addr, SingleHostAddr);\n        const ret = wasm.relay_new_single_host_addr(single_host_addr.__wbg_ptr);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @param {SingleHostName} single_host_name\n    * @returns {Relay}\n    */\n    static new_single_host_name(single_host_name) {\n        _assertClass(single_host_name, SingleHostName);\n        const ret = wasm.relay_new_single_host_name(single_host_name.__wbg_ptr);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @param {MultiHostName} multi_host_name\n    * @returns {Relay}\n    */\n    static new_multi_host_name(multi_host_name) {\n        _assertClass(multi_host_name, MultiHostName);\n        const ret = wasm.relay_new_multi_host_name(multi_host_name.__wbg_ptr);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        const ret = wasm.relay_kind(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {SingleHostAddr | undefined}\n    */\n    as_single_host_addr() {\n        const ret = wasm.relay_as_single_host_addr(this.__wbg_ptr);\n        return ret === 0 ? undefined : SingleHostAddr.__wrap(ret);\n    }\n    /**\n    * @returns {SingleHostName | undefined}\n    */\n    as_single_host_name() {\n        const ret = wasm.relay_as_single_host_name(this.__wbg_ptr);\n        return ret === 0 ? undefined : SingleHostName.__wrap(ret);\n    }\n    /**\n    * @returns {MultiHostName | undefined}\n    */\n    as_multi_host_name() {\n        const ret = wasm.relay_as_multi_host_name(this.__wbg_ptr);\n        return ret === 0 ? undefined : MultiHostName.__wrap(ret);\n    }\n}\n/**\n*/\nclass Relays {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Relays.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_relays_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.relays_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Relays}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.relays_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Relays.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.relays_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Relays}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.relays_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Relays.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.relays_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.relays_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Relays}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.relays_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Relays.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Relays}\n    */\n    static new() {\n        const ret = wasm.relays_new();\n        return Relays.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.relays_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Relay}\n    */\n    get(index) {\n        const ret = wasm.relays_get(this.__wbg_ptr, index);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @param {Relay} elem\n    */\n    add(elem) {\n        _assertClass(elem, Relay);\n        wasm.relays_add(this.__wbg_ptr, elem.__wbg_ptr);\n    }\n}\n/**\n*/\nclass RewardAddress {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RewardAddress.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rewardaddress_free(ptr);\n    }\n    /**\n    * @param {number} network\n    * @param {Credential} payment\n    * @returns {RewardAddress}\n    */\n    static new(network, payment) {\n        _assertClass(payment, Credential);\n        const ret = wasm.enterpriseaddress_new(network, payment.__wbg_ptr);\n        return RewardAddress.__wrap(ret);\n    }\n    /**\n    * @returns {Credential}\n    */\n    payment_cred() {\n        const ret = wasm.baseaddress_payment_cred(this.__wbg_ptr);\n        return Credential.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        const ret = wasm.rewardaddress_to_address(this.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {RewardAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        const ret = wasm.rewardaddress_from_address(addr.__wbg_ptr);\n        return ret === 0 ? undefined : RewardAddress.__wrap(ret);\n    }\n}\n/**\n*/\nclass RewardAddresses {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RewardAddresses.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rewardaddresses_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rewardaddresses_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {RewardAddresses}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.rewardaddresses_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return RewardAddresses.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rewardaddresses_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {RewardAddresses}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.rewardaddresses_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return RewardAddresses.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rewardaddresses_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rewardaddresses_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {RewardAddresses}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.rewardaddresses_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return RewardAddresses.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {RewardAddresses}\n    */\n    static new() {\n        const ret = wasm.credentials_new();\n        return RewardAddresses.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.assetnames_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {RewardAddress}\n    */\n    get(index) {\n        const ret = wasm.rewardaddresses_get(this.__wbg_ptr, index);\n        return RewardAddress.__wrap(ret);\n    }\n    /**\n    * @param {RewardAddress} elem\n    */\n    add(elem) {\n        _assertClass(elem, RewardAddress);\n        wasm.rewardaddresses_add(this.__wbg_ptr, elem.__wbg_ptr);\n    }\n}\n/**\n*/\nclass ScriptAll {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ScriptAll.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptall_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptall_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptAll}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptall_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptAll.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptall_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ScriptAll}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptall_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptAll.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptall_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptall_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {ScriptAll}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptall_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptAll.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    native_scripts() {\n        const ret = wasm.scriptall_native_scripts(this.__wbg_ptr);\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {NativeScripts} native_scripts\n    * @returns {ScriptAll}\n    */\n    static new(native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        const ret = wasm.scriptall_new(native_scripts.__wbg_ptr);\n        return ScriptAll.__wrap(ret);\n    }\n}\n/**\n*/\nclass ScriptAny {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ScriptAny.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptany_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptany_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptAny}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptany_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptAny.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptany_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ScriptAny}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptany_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptAny.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptall_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptany_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {ScriptAny}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptany_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptAny.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    native_scripts() {\n        const ret = wasm.scriptall_native_scripts(this.__wbg_ptr);\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {NativeScripts} native_scripts\n    * @returns {ScriptAny}\n    */\n    static new(native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        const ret = wasm.scriptall_new(native_scripts.__wbg_ptr);\n        return ScriptAny.__wrap(ret);\n    }\n}\n/**\n*/\nclass ScriptDataHash {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ScriptDataHash.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptdatahash_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptDataHash}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptdatahash_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptDataHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchordatahash_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.anchordatahash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {ScriptDataHash}\n    */\n    static from_bech32(bech_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptdatahash_from_bech32(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptDataHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchordatahash_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {ScriptDataHash}\n    */\n    static from_hex(hex) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptdatahash_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptDataHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass ScriptHash {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ScriptHash.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scripthash_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptHash}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scripthash_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519keyhash_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ed25519keyhash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {ScriptHash}\n    */\n    static from_bech32(bech_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scripthash_from_bech32(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519keyhash_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {ScriptHash}\n    */\n    static from_hex(hex) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scripthash_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass ScriptHashes {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ScriptHashes.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scripthashes_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scripthashes_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptHashes}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scripthashes_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptHashes.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scripthashes_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ScriptHashes}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scripthashes_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptHashes.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scripthashes_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scripthashes_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {ScriptHashes}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scripthashes_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptHashes.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {ScriptHashes}\n    */\n    static new() {\n        const ret = wasm.credentials_new();\n        return ScriptHashes.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.assetnames_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {ScriptHash}\n    */\n    get(index) {\n        const ret = wasm.scripthashes_get(this.__wbg_ptr, index);\n        return ScriptHash.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} elem\n    */\n    add(elem) {\n        _assertClass(elem, ScriptHash);\n        wasm.scripthashes_add(this.__wbg_ptr, elem.__wbg_ptr);\n    }\n}\n/**\n*/\nclass ScriptNOfK {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ScriptNOfK.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptnofk_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptnofk_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptNOfK}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptnofk_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptNOfK.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptnofk_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ScriptNOfK}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptnofk_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptNOfK.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptnofk_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptnofk_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {ScriptNOfK}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptnofk_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptNOfK.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number}\n    */\n    n() {\n        const ret = wasm.protocolversion_major(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    native_scripts() {\n        const ret = wasm.scriptnofk_native_scripts(this.__wbg_ptr);\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {number} n\n    * @param {NativeScripts} native_scripts\n    * @returns {ScriptNOfK}\n    */\n    static new(n, native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        const ret = wasm.scriptnofk_new(n, native_scripts.__wbg_ptr);\n        return ScriptNOfK.__wrap(ret);\n    }\n}\n/**\n*/\nclass ScriptPubkey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ScriptPubkey.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptpubkey_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptpubkey_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptPubkey}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptpubkey_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptPubkey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptpubkey_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ScriptPubkey}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptpubkey_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptPubkey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptpubkey_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptpubkey_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {ScriptPubkey}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptpubkey_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptPubkey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    addr_keyhash() {\n        const ret = wasm.scriptpubkey_addr_keyhash(this.__wbg_ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @param {Ed25519KeyHash} addr_keyhash\n    * @returns {ScriptPubkey}\n    */\n    static new(addr_keyhash) {\n        _assertClass(addr_keyhash, Ed25519KeyHash);\n        const ret = wasm.scriptpubkey_new(addr_keyhash.__wbg_ptr);\n        return ScriptPubkey.__wrap(ret);\n    }\n}\n/**\n*/\nclass ScriptRef {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ScriptRef.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptref_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptref_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptRef}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptref_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptRef.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptref_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ScriptRef}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptref_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptRef.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptref_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptref_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {ScriptRef}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptref_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptRef.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {NativeScript} native_script\n    * @returns {ScriptRef}\n    */\n    static new_native_script(native_script) {\n        _assertClass(native_script, NativeScript);\n        const ret = wasm.scriptref_new_native_script(native_script.__wbg_ptr);\n        return ScriptRef.__wrap(ret);\n    }\n    /**\n    * @param {PlutusScript} plutus_script\n    * @returns {ScriptRef}\n    */\n    static new_plutus_script(plutus_script) {\n        _assertClass(plutus_script, PlutusScript);\n        const ret = wasm.scriptref_new_plutus_script(plutus_script.__wbg_ptr);\n        return ScriptRef.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_native_script() {\n        const ret = wasm.scriptref_is_native_script(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_plutus_script() {\n        const ret = wasm.scriptref_is_plutus_script(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {NativeScript | undefined}\n    */\n    native_script() {\n        const ret = wasm.scriptref_native_script(this.__wbg_ptr);\n        return ret === 0 ? undefined : NativeScript.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusScript | undefined}\n    */\n    plutus_script() {\n        const ret = wasm.scriptref_plutus_script(this.__wbg_ptr);\n        return ret === 0 ? undefined : PlutusScript.__wrap(ret);\n    }\n}\n/**\n*/\nclass SingleHostAddr {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SingleHostAddr.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_singlehostaddr_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.singlehostaddr_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {SingleHostAddr}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.singlehostaddr_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SingleHostAddr.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.singlehostaddr_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {SingleHostAddr}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.singlehostaddr_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SingleHostAddr.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.singlehostaddr_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.singlehostaddr_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {SingleHostAddr}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.singlehostaddr_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SingleHostAddr.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    port() {\n        const ret = wasm.singlehostaddr_port(this.__wbg_ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n    /**\n    * @returns {Ipv4 | undefined}\n    */\n    ipv4() {\n        const ret = wasm.singlehostaddr_ipv4(this.__wbg_ptr);\n        return ret === 0 ? undefined : Ipv4.__wrap(ret);\n    }\n    /**\n    * @returns {Ipv6 | undefined}\n    */\n    ipv6() {\n        const ret = wasm.singlehostaddr_ipv6(this.__wbg_ptr);\n        return ret === 0 ? undefined : Ipv6.__wrap(ret);\n    }\n    /**\n    * @param {number | undefined} port\n    * @param {Ipv4 | undefined} ipv4\n    * @param {Ipv6 | undefined} ipv6\n    * @returns {SingleHostAddr}\n    */\n    static new(port, ipv4, ipv6) {\n        let ptr0 = 0;\n        if (!isLikeNone(ipv4)) {\n            _assertClass(ipv4, Ipv4);\n            ptr0 = ipv4.__destroy_into_raw();\n        }\n        let ptr1 = 0;\n        if (!isLikeNone(ipv6)) {\n            _assertClass(ipv6, Ipv6);\n            ptr1 = ipv6.__destroy_into_raw();\n        }\n        const ret = wasm.singlehostaddr_new(isLikeNone(port) ? 0xFFFFFF : port, ptr0, ptr1);\n        return SingleHostAddr.__wrap(ret);\n    }\n}\n/**\n*/\nclass SingleHostName {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SingleHostName.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_singlehostname_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.singlehostname_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {SingleHostName}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.singlehostname_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SingleHostName.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.singlehostname_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {SingleHostName}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.singlehostname_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SingleHostName.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.singlehostname_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.singlehostname_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {SingleHostName}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.singlehostname_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SingleHostName.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    port() {\n        const ret = wasm.singlehostname_port(this.__wbg_ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n    /**\n    * @returns {DNSRecordAorAAAA}\n    */\n    dns_name() {\n        const ret = wasm.multihostname_dns_name(this.__wbg_ptr);\n        return DNSRecordAorAAAA.__wrap(ret);\n    }\n    /**\n    * @param {number | undefined} port\n    * @param {DNSRecordAorAAAA} dns_name\n    * @returns {SingleHostName}\n    */\n    static new(port, dns_name) {\n        _assertClass(dns_name, DNSRecordAorAAAA);\n        const ret = wasm.singlehostname_new(isLikeNone(port) ? 0xFFFFFF : port, dns_name.__wbg_ptr);\n        return SingleHostName.__wrap(ret);\n    }\n}\n/**\n*/\nclass StakeAndVoteDelegation {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(StakeAndVoteDelegation.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_stakeandvotedelegation_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakeandvotedelegation_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeAndVoteDelegation}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.stakeandvotedelegation_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return StakeAndVoteDelegation.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakeandvotedelegation_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {StakeAndVoteDelegation}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.stakeandvotedelegation_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return StakeAndVoteDelegation.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakeandvotedelegation_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakeandvotedelegation_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {StakeAndVoteDelegation}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.stakeandvotedelegation_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return StakeAndVoteDelegation.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Credential}\n    */\n    stake_credential() {\n        const ret = wasm.stakeandvotedelegation_stake_credential(this.__wbg_ptr);\n        return Credential.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    pool_keyhash() {\n        const ret = wasm.stakeandvotedelegation_pool_keyhash(this.__wbg_ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {DRep}\n    */\n    drep() {\n        const ret = wasm.stakeandvotedelegation_drep(this.__wbg_ptr);\n        return DRep.__wrap(ret);\n    }\n    /**\n    * @param {Credential} stake_credential\n    * @param {Ed25519KeyHash} pool_keyhash\n    * @param {DRep} drep\n    * @returns {StakeAndVoteDelegation}\n    */\n    static new(stake_credential, pool_keyhash, drep) {\n        _assertClass(stake_credential, Credential);\n        _assertClass(pool_keyhash, Ed25519KeyHash);\n        _assertClass(drep, DRep);\n        const ret = wasm.stakeandvotedelegation_new(stake_credential.__wbg_ptr, pool_keyhash.__wbg_ptr, drep.__wbg_ptr);\n        return StakeAndVoteDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_script_credentials() {\n        const ret = wasm.stakeandvotedelegation_has_script_credentials(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nclass StakeDelegation {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(StakeDelegation.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_stakedelegation_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakedelegation_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeDelegation}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.stakedelegation_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return StakeDelegation.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakedelegation_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {StakeDelegation}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.stakedelegation_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return StakeDelegation.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakedelegation_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakedelegation_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {StakeDelegation}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.stakedelegation_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return StakeDelegation.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Credential}\n    */\n    stake_credential() {\n        const ret = wasm.stakedelegation_stake_credential(this.__wbg_ptr);\n        return Credential.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    pool_keyhash() {\n        const ret = wasm.stakeandvotedelegation_pool_keyhash(this.__wbg_ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @param {Credential} stake_credential\n    * @param {Ed25519KeyHash} pool_keyhash\n    * @returns {StakeDelegation}\n    */\n    static new(stake_credential, pool_keyhash) {\n        _assertClass(stake_credential, Credential);\n        _assertClass(pool_keyhash, Ed25519KeyHash);\n        const ret = wasm.stakedelegation_new(stake_credential.__wbg_ptr, pool_keyhash.__wbg_ptr);\n        return StakeDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_script_credentials() {\n        const ret = wasm.stakedelegation_has_script_credentials(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nclass StakeDeregistration {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(StakeDeregistration.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_stakederegistration_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakederegistration_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeDeregistration}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.stakederegistration_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return StakeDeregistration.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakederegistration_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {StakeDeregistration}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.stakederegistration_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return StakeDeregistration.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakederegistration_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakederegistration_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {StakeDeregistration}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.stakederegistration_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return StakeDeregistration.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Credential}\n    */\n    stake_credential() {\n        const ret = wasm.stakederegistration_stake_credential(this.__wbg_ptr);\n        return Credential.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    coin() {\n        const ret = wasm.stakederegistration_coin(this.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {Credential} stake_credential\n    * @returns {StakeDeregistration}\n    */\n    static new(stake_credential) {\n        _assertClass(stake_credential, Credential);\n        const ret = wasm.stakederegistration_new(stake_credential.__wbg_ptr);\n        return StakeDeregistration.__wrap(ret);\n    }\n    /**\n    * @param {Credential} stake_credential\n    * @param {BigNum} coin\n    * @returns {StakeDeregistration}\n    */\n    static new_with_coin(stake_credential, coin) {\n        _assertClass(stake_credential, Credential);\n        _assertClass(coin, BigNum);\n        const ret = wasm.stakederegistration_new_with_coin(stake_credential.__wbg_ptr, coin.__wbg_ptr);\n        return StakeDeregistration.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_script_credentials() {\n        const ret = wasm.stakederegistration_has_script_credentials(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nclass StakeRegistration {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(StakeRegistration.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_stakeregistration_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakeregistration_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeRegistration}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.stakeregistration_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return StakeRegistration.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakeregistration_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {StakeRegistration}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.stakeregistration_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return StakeRegistration.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakederegistration_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakeregistration_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {StakeRegistration}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.stakeregistration_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return StakeRegistration.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Credential}\n    */\n    stake_credential() {\n        const ret = wasm.stakederegistration_stake_credential(this.__wbg_ptr);\n        return Credential.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    coin() {\n        const ret = wasm.stakederegistration_coin(this.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {Credential} stake_credential\n    * @returns {StakeRegistration}\n    */\n    static new(stake_credential) {\n        _assertClass(stake_credential, Credential);\n        const ret = wasm.stakederegistration_new(stake_credential.__wbg_ptr);\n        return StakeRegistration.__wrap(ret);\n    }\n    /**\n    * @param {Credential} stake_credential\n    * @param {BigNum} coin\n    * @returns {StakeRegistration}\n    */\n    static new_with_coin(stake_credential, coin) {\n        _assertClass(stake_credential, Credential);\n        _assertClass(coin, BigNum);\n        const ret = wasm.stakederegistration_new_with_coin(stake_credential.__wbg_ptr, coin.__wbg_ptr);\n        return StakeRegistration.__wrap(ret);\n    }\n}\n/**\n*/\nclass StakeRegistrationAndDelegation {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(StakeRegistrationAndDelegation.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_stakeregistrationanddelegation_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakeregistrationanddelegation_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeRegistrationAndDelegation}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.stakeregistrationanddelegation_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return StakeRegistrationAndDelegation.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakeregistrationanddelegation_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {StakeRegistrationAndDelegation}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.stakeregistrationanddelegation_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return StakeRegistrationAndDelegation.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakeregistrationanddelegation_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakeregistrationanddelegation_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {StakeRegistrationAndDelegation}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.stakeregistrationanddelegation_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return StakeRegistrationAndDelegation.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Credential}\n    */\n    stake_credential() {\n        const ret = wasm.stakeregistrationanddelegation_stake_credential(this.__wbg_ptr);\n        return Credential.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    pool_keyhash() {\n        const ret = wasm.stakeregistrationanddelegation_pool_keyhash(this.__wbg_ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    coin() {\n        const ret = wasm.drepregistration_coin(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {Credential} stake_credential\n    * @param {Ed25519KeyHash} pool_keyhash\n    * @param {BigNum} coin\n    * @returns {StakeRegistrationAndDelegation}\n    */\n    static new(stake_credential, pool_keyhash, coin) {\n        _assertClass(stake_credential, Credential);\n        _assertClass(pool_keyhash, Ed25519KeyHash);\n        _assertClass(coin, BigNum);\n        const ret = wasm.stakeregistrationanddelegation_new(stake_credential.__wbg_ptr, pool_keyhash.__wbg_ptr, coin.__wbg_ptr);\n        return StakeRegistrationAndDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_script_credentials() {\n        const ret = wasm.stakeregistrationanddelegation_has_script_credentials(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nclass StakeVoteRegistrationAndDelegation {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(StakeVoteRegistrationAndDelegation.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_stakevoteregistrationanddelegation_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakevoteregistrationanddelegation_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeVoteRegistrationAndDelegation}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.stakevoteregistrationanddelegation_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return StakeVoteRegistrationAndDelegation.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakevoteregistrationanddelegation_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {StakeVoteRegistrationAndDelegation}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.stakevoteregistrationanddelegation_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return StakeVoteRegistrationAndDelegation.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakevoteregistrationanddelegation_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakevoteregistrationanddelegation_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {StakeVoteRegistrationAndDelegation}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.stakevoteregistrationanddelegation_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return StakeVoteRegistrationAndDelegation.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Credential}\n    */\n    stake_credential() {\n        const ret = wasm.stakevoteregistrationanddelegation_stake_credential(this.__wbg_ptr);\n        return Credential.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    pool_keyhash() {\n        const ret = wasm.stakevoteregistrationanddelegation_pool_keyhash(this.__wbg_ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {DRep}\n    */\n    drep() {\n        const ret = wasm.stakevoteregistrationanddelegation_drep(this.__wbg_ptr);\n        return DRep.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    coin() {\n        const ret = wasm.pointer_slot_bignum(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {Credential} stake_credential\n    * @param {Ed25519KeyHash} pool_keyhash\n    * @param {DRep} drep\n    * @param {BigNum} coin\n    * @returns {StakeVoteRegistrationAndDelegation}\n    */\n    static new(stake_credential, pool_keyhash, drep, coin) {\n        _assertClass(stake_credential, Credential);\n        _assertClass(pool_keyhash, Ed25519KeyHash);\n        _assertClass(drep, DRep);\n        _assertClass(coin, BigNum);\n        const ret = wasm.stakevoteregistrationanddelegation_new(stake_credential.__wbg_ptr, pool_keyhash.__wbg_ptr, drep.__wbg_ptr, coin.__wbg_ptr);\n        return StakeVoteRegistrationAndDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_script_credentials() {\n        const ret = wasm.stakevoteregistrationanddelegation_has_script_credentials(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nclass Strings {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Strings.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_strings_free(ptr);\n    }\n    /**\n    * @returns {Strings}\n    */\n    static new() {\n        const ret = wasm.plutusscripts_new();\n        return Strings.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.costmdls_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {string}\n    */\n    get(index) {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.strings_get(retptr, this.__wbg_ptr, index);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} elem\n    */\n    add(elem) {\n        const ptr0 = passStringToWasm0(elem, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.strings_add(this.__wbg_ptr, ptr0, len0);\n    }\n}\n/**\n*/\nclass TimelockExpiry {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TimelockExpiry.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_timelockexpiry_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.timelockexpiry_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TimelockExpiry}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.timelockexpiry_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TimelockExpiry.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.timelockexpiry_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TimelockExpiry}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.timelockexpiry_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TimelockExpiry.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.timelockexpiry_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.timelockexpiry_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {TimelockExpiry}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.timelockexpiry_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TimelockExpiry.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number}\n    */\n    slot() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.timelockexpiry_slot(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {BigNum}\n    */\n    slot_bignum() {\n        const ret = wasm.timelockexpiry_slot_bignum(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * This constructor uses outdated slot number format.\n    * Use `.new_timelockexpiry` instead\n    * @param {number} slot\n    * @returns {TimelockExpiry}\n    */\n    static new(slot) {\n        const ret = wasm.timelockexpiry_new(slot);\n        return TimelockExpiry.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} slot\n    * @returns {TimelockExpiry}\n    */\n    static new_timelockexpiry(slot) {\n        _assertClass(slot, BigNum);\n        const ret = wasm.timelockexpiry_new_timelockexpiry(slot.__wbg_ptr);\n        return TimelockExpiry.__wrap(ret);\n    }\n}\n/**\n*/\nclass TimelockStart {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TimelockStart.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_timelockstart_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.timelockstart_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TimelockStart}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.timelockstart_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TimelockStart.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.timelockstart_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TimelockStart}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.timelockstart_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TimelockStart.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.timelockexpiry_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.timelockstart_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {TimelockStart}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.timelockstart_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TimelockStart.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Returns a Slot32 (u32) value in case the underlying original BigNum (u64) value is within the limits.\n    * Otherwise will just raise an error.\n    * Use `.slot_bignum` instead\n    * @returns {number}\n    */\n    slot() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.timelockexpiry_slot(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {BigNum}\n    */\n    slot_bignum() {\n        const ret = wasm.timelockexpiry_slot_bignum(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * This constructor uses outdated slot number format.\n    * Use `.new_timelockstart` instead.\n    * @param {number} slot\n    * @returns {TimelockStart}\n    */\n    static new(slot) {\n        const ret = wasm.timelockexpiry_new(slot);\n        return TimelockStart.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} slot\n    * @returns {TimelockStart}\n    */\n    static new_timelockstart(slot) {\n        _assertClass(slot, BigNum);\n        const ret = wasm.timelockexpiry_new_timelockexpiry(slot.__wbg_ptr);\n        return TimelockStart.__wrap(ret);\n    }\n}\n/**\n*/\nclass Transaction {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Transaction.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transaction_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Transaction}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transaction_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Transaction}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transaction_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Transaction}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transaction_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {TransactionBody}\n    */\n    body() {\n        const ret = wasm.transaction_body(this.__wbg_ptr);\n        return TransactionBody.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionWitnessSet}\n    */\n    witness_set() {\n        const ret = wasm.transaction_witness_set(this.__wbg_ptr);\n        return TransactionWitnessSet.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_valid() {\n        const ret = wasm.transaction_is_valid(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {AuxiliaryData | undefined}\n    */\n    auxiliary_data() {\n        const ret = wasm.transaction_auxiliary_data(this.__wbg_ptr);\n        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @param {boolean} valid\n    */\n    set_is_valid(valid) {\n        wasm.transaction_set_is_valid(this.__wbg_ptr, valid);\n    }\n    /**\n    * @param {TransactionBody} body\n    * @param {TransactionWitnessSet} witness_set\n    * @param {AuxiliaryData | undefined} auxiliary_data\n    * @returns {Transaction}\n    */\n    static new(body, witness_set, auxiliary_data) {\n        _assertClass(body, TransactionBody);\n        _assertClass(witness_set, TransactionWitnessSet);\n        let ptr0 = 0;\n        if (!isLikeNone(auxiliary_data)) {\n            _assertClass(auxiliary_data, AuxiliaryData);\n            ptr0 = auxiliary_data.__destroy_into_raw();\n        }\n        const ret = wasm.transaction_new(body.__wbg_ptr, witness_set.__wbg_ptr, ptr0);\n        return Transaction.__wrap(ret);\n    }\n}\n/**\n*/\nclass TransactionBatch {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionBatch.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionbatch_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.certificates_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Transaction}\n    */\n    get(index) {\n        const ret = wasm.transactionbatch_get(this.__wbg_ptr, index);\n        return Transaction.__wrap(ret);\n    }\n}\n/**\n*/\nclass TransactionBatchList {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionBatchList.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionbatchlist_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.certificates_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionBatch}\n    */\n    get(index) {\n        const ret = wasm.transactionbatchlist_get(this.__wbg_ptr, index);\n        return TransactionBatch.__wrap(ret);\n    }\n}\n/**\n*/\nclass TransactionBodies {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionBodies.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionbodies_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbodies_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionBodies}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionbodies_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionBodies.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbodies_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TransactionBodies}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionbodies_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionBodies.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbodies_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbodies_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {TransactionBodies}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionbodies_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionBodies.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {TransactionBodies}\n    */\n    static new() {\n        const ret = wasm.nativescripts_new();\n        return TransactionBodies.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.assetnames_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionBody}\n    */\n    get(index) {\n        const ret = wasm.transactionbodies_get(this.__wbg_ptr, index);\n        return TransactionBody.__wrap(ret);\n    }\n    /**\n    * @param {TransactionBody} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionBody);\n        wasm.transactionbodies_add(this.__wbg_ptr, elem.__wbg_ptr);\n    }\n}\n/**\n*/\nclass TransactionBody {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionBody.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionbody_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbody_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionBody}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionbody_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionBody.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbody_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TransactionBody}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionbody_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionBody.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbody_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbody_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {TransactionBody}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionbody_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionBody.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {TransactionInputs}\n    */\n    inputs() {\n        const ret = wasm.transactionbody_inputs(this.__wbg_ptr);\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionOutputs}\n    */\n    outputs() {\n        const ret = wasm.transactionbody_outputs(this.__wbg_ptr);\n        return TransactionOutputs.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    fee() {\n        const ret = wasm.transactionbody_fee(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Returns a Slot32 (u32) value in case the underlying original BigNum (u64) value is within the limits.\n    * Otherwise will just raise an error.\n    * @returns {number | undefined}\n    */\n    ttl() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbody_ttl(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    ttl_bignum() {\n        const ret = wasm.transactionbody_ttl_bignum(this.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} ttl\n    */\n    set_ttl(ttl) {\n        _assertClass(ttl, BigNum);\n        wasm.transactionbody_set_ttl(this.__wbg_ptr, ttl.__wbg_ptr);\n    }\n    /**\n    */\n    remove_ttl() {\n        wasm.transactionbody_remove_ttl(this.__wbg_ptr);\n    }\n    /**\n    * @param {Certificates} certs\n    */\n    set_certs(certs) {\n        _assertClass(certs, Certificates);\n        wasm.transactionbody_set_certs(this.__wbg_ptr, certs.__wbg_ptr);\n    }\n    /**\n    * @returns {Certificates | undefined}\n    */\n    certs() {\n        const ret = wasm.transactionbody_certs(this.__wbg_ptr);\n        return ret === 0 ? undefined : Certificates.__wrap(ret);\n    }\n    /**\n    * @param {Withdrawals} withdrawals\n    */\n    set_withdrawals(withdrawals) {\n        _assertClass(withdrawals, Withdrawals);\n        wasm.transactionbody_set_withdrawals(this.__wbg_ptr, withdrawals.__wbg_ptr);\n    }\n    /**\n    * @returns {Withdrawals | undefined}\n    */\n    withdrawals() {\n        const ret = wasm.transactionbody_withdrawals(this.__wbg_ptr);\n        return ret === 0 ? undefined : Withdrawals.__wrap(ret);\n    }\n    /**\n    * @param {Update} update\n    */\n    set_update(update) {\n        _assertClass(update, Update);\n        wasm.transactionbody_set_update(this.__wbg_ptr, update.__wbg_ptr);\n    }\n    /**\n    * @returns {Update | undefined}\n    */\n    update() {\n        const ret = wasm.transactionbody_update(this.__wbg_ptr);\n        return ret === 0 ? undefined : Update.__wrap(ret);\n    }\n    /**\n    * @param {AuxiliaryDataHash} auxiliary_data_hash\n    */\n    set_auxiliary_data_hash(auxiliary_data_hash) {\n        _assertClass(auxiliary_data_hash, AuxiliaryDataHash);\n        wasm.transactionbody_set_auxiliary_data_hash(this.__wbg_ptr, auxiliary_data_hash.__wbg_ptr);\n    }\n    /**\n    * @returns {AuxiliaryDataHash | undefined}\n    */\n    auxiliary_data_hash() {\n        const ret = wasm.transactionbody_auxiliary_data_hash(this.__wbg_ptr);\n        return ret === 0 ? undefined : AuxiliaryDataHash.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Uses outdated slot number format.\n    * @param {number} validity_start_interval\n    */\n    set_validity_start_interval(validity_start_interval) {\n        wasm.transactionbody_set_validity_start_interval(this.__wbg_ptr, validity_start_interval);\n    }\n    /**\n    * @param {BigNum} validity_start_interval\n    */\n    set_validity_start_interval_bignum(validity_start_interval) {\n        _assertClass(validity_start_interval, BigNum);\n        wasm.transactionbody_set_validity_start_interval_bignum(this.__wbg_ptr, validity_start_interval.__wbg_ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    validity_start_interval_bignum() {\n        const ret = wasm.transactionbody_validity_start_interval_bignum(this.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Returns a Option<Slot32> (u32) value in case the underlying original Option<BigNum> (u64) value is within the limits.\n    * Otherwise will just raise an error.\n    * Use `.validity_start_interval_bignum` instead.\n    * @returns {number | undefined}\n    */\n    validity_start_interval() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbody_validity_start_interval(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Mint} mint\n    */\n    set_mint(mint) {\n        _assertClass(mint, Mint);\n        wasm.transactionbody_set_mint(this.__wbg_ptr, mint.__wbg_ptr);\n    }\n    /**\n    * @returns {Mint | undefined}\n    */\n    mint() {\n        const ret = wasm.transactionbody_mint(this.__wbg_ptr);\n        return ret === 0 ? undefined : Mint.__wrap(ret);\n    }\n    /**\n    * This function returns the mint value of the transaction\n    * Use `.mint()` instead.\n    * @returns {Mint | undefined}\n    */\n    multiassets() {\n        const ret = wasm.transactionbody_mint(this.__wbg_ptr);\n        return ret === 0 ? undefined : Mint.__wrap(ret);\n    }\n    /**\n    * @param {TransactionInputs} reference_inputs\n    */\n    set_reference_inputs(reference_inputs) {\n        _assertClass(reference_inputs, TransactionInputs);\n        wasm.transactionbody_set_reference_inputs(this.__wbg_ptr, reference_inputs.__wbg_ptr);\n    }\n    /**\n    * @returns {TransactionInputs | undefined}\n    */\n    reference_inputs() {\n        const ret = wasm.transactionbody_reference_inputs(this.__wbg_ptr);\n        return ret === 0 ? undefined : TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @param {ScriptDataHash} script_data_hash\n    */\n    set_script_data_hash(script_data_hash) {\n        _assertClass(script_data_hash, ScriptDataHash);\n        wasm.transactionbody_set_script_data_hash(this.__wbg_ptr, script_data_hash.__wbg_ptr);\n    }\n    /**\n    * @returns {ScriptDataHash | undefined}\n    */\n    script_data_hash() {\n        const ret = wasm.transactionbody_script_data_hash(this.__wbg_ptr);\n        return ret === 0 ? undefined : ScriptDataHash.__wrap(ret);\n    }\n    /**\n    * @param {TransactionInputs} collateral\n    */\n    set_collateral(collateral) {\n        _assertClass(collateral, TransactionInputs);\n        wasm.transactionbody_set_collateral(this.__wbg_ptr, collateral.__wbg_ptr);\n    }\n    /**\n    * @returns {TransactionInputs | undefined}\n    */\n    collateral() {\n        const ret = wasm.transactionbody_collateral(this.__wbg_ptr);\n        return ret === 0 ? undefined : TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @param {Ed25519KeyHashes} required_signers\n    */\n    set_required_signers(required_signers) {\n        _assertClass(required_signers, Ed25519KeyHashes);\n        wasm.transactionbody_set_required_signers(this.__wbg_ptr, required_signers.__wbg_ptr);\n    }\n    /**\n    * @returns {Ed25519KeyHashes | undefined}\n    */\n    required_signers() {\n        const ret = wasm.transactionbody_required_signers(this.__wbg_ptr);\n        return ret === 0 ? undefined : Ed25519KeyHashes.__wrap(ret);\n    }\n    /**\n    * @param {NetworkId} network_id\n    */\n    set_network_id(network_id) {\n        _assertClass(network_id, NetworkId);\n        wasm.transactionbody_set_network_id(this.__wbg_ptr, network_id.__wbg_ptr);\n    }\n    /**\n    * @returns {NetworkId | undefined}\n    */\n    network_id() {\n        const ret = wasm.transactionbody_network_id(this.__wbg_ptr);\n        return ret === 0 ? undefined : NetworkId.__wrap(ret);\n    }\n    /**\n    * @param {TransactionOutput} collateral_return\n    */\n    set_collateral_return(collateral_return) {\n        _assertClass(collateral_return, TransactionOutput);\n        wasm.transactionbody_set_collateral_return(this.__wbg_ptr, collateral_return.__wbg_ptr);\n    }\n    /**\n    * @returns {TransactionOutput | undefined}\n    */\n    collateral_return() {\n        const ret = wasm.transactionbody_collateral_return(this.__wbg_ptr);\n        return ret === 0 ? undefined : TransactionOutput.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} total_collateral\n    */\n    set_total_collateral(total_collateral) {\n        _assertClass(total_collateral, BigNum);\n        wasm.transactionbody_set_total_collateral(this.__wbg_ptr, total_collateral.__wbg_ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    total_collateral() {\n        const ret = wasm.transactionbody_total_collateral(this.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {VotingProcedures} voting_procedures\n    */\n    set_voting_procedures(voting_procedures) {\n        _assertClass(voting_procedures, VotingProcedures);\n        wasm.transactionbody_set_voting_procedures(this.__wbg_ptr, voting_procedures.__wbg_ptr);\n    }\n    /**\n    * @returns {VotingProcedures | undefined}\n    */\n    voting_procedures() {\n        const ret = wasm.transactionbody_voting_procedures(this.__wbg_ptr);\n        return ret === 0 ? undefined : VotingProcedures.__wrap(ret);\n    }\n    /**\n    * @param {VotingProposals} voting_proposals\n    */\n    set_voting_proposals(voting_proposals) {\n        _assertClass(voting_proposals, VotingProposals);\n        wasm.transactionbody_set_voting_proposals(this.__wbg_ptr, voting_proposals.__wbg_ptr);\n    }\n    /**\n    * @returns {VotingProposals | undefined}\n    */\n    voting_proposals() {\n        const ret = wasm.transactionbody_voting_proposals(this.__wbg_ptr);\n        return ret === 0 ? undefined : VotingProposals.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} donation\n    */\n    set_donation(donation) {\n        _assertClass(donation, BigNum);\n        wasm.transactionbody_set_donation(this.__wbg_ptr, donation.__wbg_ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    donation() {\n        const ret = wasm.transactionbody_donation(this.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} current_treasury_value\n    */\n    set_current_treasury_value(current_treasury_value) {\n        _assertClass(current_treasury_value, BigNum);\n        wasm.transactionbody_set_current_treasury_value(this.__wbg_ptr, current_treasury_value.__wbg_ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    current_treasury_value() {\n        const ret = wasm.transactionbody_current_treasury_value(this.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * This constructor uses outdated slot number format for the ttl value.\n    * Use `.new_tx_body` and then `.set_ttl` instead\n    * @param {TransactionInputs} inputs\n    * @param {TransactionOutputs} outputs\n    * @param {BigNum} fee\n    * @param {number | undefined} ttl\n    * @returns {TransactionBody}\n    */\n    static new(inputs, outputs, fee, ttl) {\n        _assertClass(inputs, TransactionInputs);\n        _assertClass(outputs, TransactionOutputs);\n        _assertClass(fee, BigNum);\n        const ret = wasm.transactionbody_new(inputs.__wbg_ptr, outputs.__wbg_ptr, fee.__wbg_ptr, !isLikeNone(ttl), isLikeNone(ttl) ? 0 : ttl);\n        return TransactionBody.__wrap(ret);\n    }\n    /**\n    * Returns a new TransactionBody.\n    * In the new version of \"new\" we removed optional ttl for support it by wasm_bingen.\n    * Your can use \"set_ttl\" and \"remove_ttl\" to set a new value for ttl or set it as None.\n    * @param {TransactionInputs} inputs\n    * @param {TransactionOutputs} outputs\n    * @param {BigNum} fee\n    * @returns {TransactionBody}\n    */\n    static new_tx_body(inputs, outputs, fee) {\n        _assertClass(inputs, TransactionInputs);\n        _assertClass(outputs, TransactionOutputs);\n        _assertClass(fee, BigNum);\n        const ret = wasm.transactionbody_new_tx_body(inputs.__wbg_ptr, outputs.__wbg_ptr, fee.__wbg_ptr);\n        return TransactionBody.__wrap(ret);\n    }\n}\n/**\n*/\nclass TransactionBuilder {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionBuilder.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionbuilder_free(ptr);\n    }\n    /**\n    * This automatically selects and adds inputs from {inputs} consisting of just enough to cover\n    * the outputs that have already been added.\n    * This should be called after adding all certs/outputs/etc and will be an error otherwise.\n    * Uses CIP2: https://github.com/cardano-foundation/CIPs/blob/master/CIP-0002/CIP-0002.md\n    * Adding a change output must be called after via TransactionBuilder::add_change_if_needed()\n    * This function, diverging from CIP2, takes into account fees and will attempt to add additional\n    * inputs to cover the minimum fees. This does not, however, set the txbuilder's fee.\n    * @param {TransactionUnspentOutputs} inputs\n    * @param {number} strategy\n    */\n    add_inputs_from(inputs, strategy) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(inputs, TransactionUnspentOutputs);\n            wasm.transactionbuilder_add_inputs_from(retptr, this.__wbg_ptr, inputs.__wbg_ptr, strategy);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {TxInputsBuilder} inputs\n    */\n    set_inputs(inputs) {\n        _assertClass(inputs, TxInputsBuilder);\n        wasm.transactionbuilder_set_inputs(this.__wbg_ptr, inputs.__wbg_ptr);\n    }\n    /**\n    * @param {TxInputsBuilder} collateral\n    */\n    set_collateral(collateral) {\n        _assertClass(collateral, TxInputsBuilder);\n        wasm.transactionbuilder_set_collateral(this.__wbg_ptr, collateral.__wbg_ptr);\n    }\n    /**\n    * @param {TransactionOutput} collateral_return\n    */\n    set_collateral_return(collateral_return) {\n        _assertClass(collateral_return, TransactionOutput);\n        wasm.transactionbuilder_set_collateral_return(this.__wbg_ptr, collateral_return.__wbg_ptr);\n    }\n    /**\n    * This function will set the collateral-return value and then auto-calculate and assign\n    * the total collateral coin value. Will raise an error in case no collateral inputs are set\n    * or in case the total collateral value will have any assets in it except coin.\n    * @param {TransactionOutput} collateral_return\n    */\n    set_collateral_return_and_total(collateral_return) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(collateral_return, TransactionOutput);\n            wasm.transactionbuilder_set_collateral_return_and_total(retptr, this.__wbg_ptr, collateral_return.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {BigNum} total_collateral\n    */\n    set_total_collateral(total_collateral) {\n        _assertClass(total_collateral, BigNum);\n        wasm.transactionbuilder_set_total_collateral(this.__wbg_ptr, total_collateral.__wbg_ptr);\n    }\n    /**\n    * This function will set the total-collateral coin and then auto-calculate and assign\n    * the collateral return value. Will raise an error in case no collateral inputs are set.\n    * The specified address will be the received of the collateral return\n    * @param {BigNum} total_collateral\n    * @param {Address} return_address\n    */\n    set_total_collateral_and_return(total_collateral, return_address) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(total_collateral, BigNum);\n            _assertClass(return_address, Address);\n            wasm.transactionbuilder_set_total_collateral_and_return(retptr, this.__wbg_ptr, total_collateral.__wbg_ptr, return_address.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {TransactionInput} reference_input\n    */\n    add_reference_input(reference_input) {\n        _assertClass(reference_input, TransactionInput);\n        wasm.transactionbuilder_add_reference_input(this.__wbg_ptr, reference_input.__wbg_ptr);\n    }\n    /**\n    * We have to know what kind of inputs these are to know what kind of mock witnesses to create since\n    * 1) mock witnesses have different lengths depending on the type which changes the expecting fee\n    * 2) Witnesses are a set so we need to get rid of duplicates to avoid over-estimating the fee\n    * @param {Ed25519KeyHash} hash\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_key_input(hash, input, amount) {\n        _assertClass(hash, Ed25519KeyHash);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.transactionbuilder_add_key_input(this.__wbg_ptr, hash.__wbg_ptr, input.__wbg_ptr, amount.__wbg_ptr);\n    }\n    /**\n    * This method adds the input to the builder BUT leaves a missing spot for the witness native script\n    *\n    * After adding the input with this method, use `.add_required_native_input_scripts`\n    * and `.add_required_plutus_input_scripts` to add the witness scripts\n    *\n    * Or instead use `.add_native_script_input` and `.add_plutus_script_input`\n    * to add inputs right along with the script, instead of the script hash\n    * @param {ScriptHash} hash\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_script_input(hash, input, amount) {\n        _assertClass(hash, ScriptHash);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.transactionbuilder_add_script_input(this.__wbg_ptr, hash.__wbg_ptr, input.__wbg_ptr, amount.__wbg_ptr);\n    }\n    /**\n    * This method will add the input to the builder and also register the required native script witness\n    * @param {NativeScript} script\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_native_script_input(script, input, amount) {\n        _assertClass(script, NativeScript);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.transactionbuilder_add_native_script_input(this.__wbg_ptr, script.__wbg_ptr, input.__wbg_ptr, amount.__wbg_ptr);\n    }\n    /**\n    * This method will add the input to the builder and also register the required plutus witness\n    * @param {PlutusWitness} witness\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_plutus_script_input(witness, input, amount) {\n        _assertClass(witness, PlutusWitness);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.transactionbuilder_add_plutus_script_input(this.__wbg_ptr, witness.__wbg_ptr, input.__wbg_ptr, amount.__wbg_ptr);\n    }\n    /**\n    * @param {ByronAddress} hash\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_bootstrap_input(hash, input, amount) {\n        _assertClass(hash, ByronAddress);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.transactionbuilder_add_bootstrap_input(this.__wbg_ptr, hash.__wbg_ptr, input.__wbg_ptr, amount.__wbg_ptr);\n    }\n    /**\n    * Note that for script inputs this method will use underlying generic `.add_script_input`\n    * which leaves a required empty spot for the script witness (or witnesses in case of Plutus).\n    * You can use `.add_native_script_input` or `.add_plutus_script_input` directly to register the input along with the witness.\n    * @param {Address} address\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_input(address, input, amount) {\n        _assertClass(address, Address);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.transactionbuilder_add_input(this.__wbg_ptr, address.__wbg_ptr, input.__wbg_ptr, amount.__wbg_ptr);\n    }\n    /**\n    * Returns the number of still missing input scripts (either native or plutus)\n    * Use `.add_required_native_input_scripts` or `.add_required_plutus_input_scripts` to add the missing scripts\n    * @returns {number}\n    */\n    count_missing_input_scripts() {\n        const ret = wasm.transactionbuilder_count_missing_input_scripts(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Try adding the specified scripts as witnesses for ALREADY ADDED script inputs\n    * Any scripts that don't match any of the previously added inputs will be ignored\n    * Returns the number of remaining required missing witness scripts\n    * Use `.count_missing_input_scripts` to find the number of still missing scripts\n    * @param {NativeScripts} scripts\n    * @returns {number}\n    */\n    add_required_native_input_scripts(scripts) {\n        _assertClass(scripts, NativeScripts);\n        const ret = wasm.transactionbuilder_add_required_native_input_scripts(this.__wbg_ptr, scripts.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Try adding the specified scripts as witnesses for ALREADY ADDED script inputs\n    * Any scripts that don't match any of the previously added inputs will be ignored\n    * Returns the number of remaining required missing witness scripts\n    * Use `.count_missing_input_scripts` to find the number of still missing scripts\n    * @param {PlutusWitnesses} scripts\n    * @returns {number}\n    */\n    add_required_plutus_input_scripts(scripts) {\n        _assertClass(scripts, PlutusWitnesses);\n        const ret = wasm.transactionbuilder_add_required_plutus_input_scripts(this.__wbg_ptr, scripts.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns a copy of the current script input witness scripts in the builder\n    * @returns {NativeScripts | undefined}\n    */\n    get_native_input_scripts() {\n        const ret = wasm.transactionbuilder_get_native_input_scripts(this.__wbg_ptr);\n        return ret === 0 ? undefined : NativeScripts.__wrap(ret);\n    }\n    /**\n    * Returns a copy of the current plutus input witness scripts in the builder.\n    * NOTE: each plutus witness will be cloned with a specific corresponding input index\n    * @returns {PlutusWitnesses | undefined}\n    */\n    get_plutus_input_scripts() {\n        const ret = wasm.transactionbuilder_get_plutus_input_scripts(this.__wbg_ptr);\n        return ret === 0 ? undefined : PlutusWitnesses.__wrap(ret);\n    }\n    /**\n    * calculates how much the fee would increase if you added a given output\n    * @param {Address} address\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    * @returns {BigNum}\n    */\n    fee_for_input(address, input, amount) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(address, Address);\n            _assertClass(input, TransactionInput);\n            _assertClass(amount, Value);\n            wasm.transactionbuilder_fee_for_input(retptr, this.__wbg_ptr, address.__wbg_ptr, input.__wbg_ptr, amount.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BigNum.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Add explicit output via a TransactionOutput object\n    * @param {TransactionOutput} output\n    */\n    add_output(output) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(output, TransactionOutput);\n            wasm.transactionbuilder_add_output(retptr, this.__wbg_ptr, output.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * calculates how much the fee would increase if you added a given output\n    * @param {TransactionOutput} output\n    * @returns {BigNum}\n    */\n    fee_for_output(output) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(output, TransactionOutput);\n            wasm.transactionbuilder_fee_for_output(retptr, this.__wbg_ptr, output.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BigNum.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {BigNum} fee\n    */\n    set_fee(fee) {\n        _assertClass(fee, BigNum);\n        wasm.transactionbuilder_set_fee(this.__wbg_ptr, fee.__wbg_ptr);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Set ttl value.\n    * @param {number} ttl\n    */\n    set_ttl(ttl) {\n        wasm.transactionbuilder_set_ttl(this.__wbg_ptr, ttl);\n    }\n    /**\n    * @param {BigNum} ttl\n    */\n    set_ttl_bignum(ttl) {\n        _assertClass(ttl, BigNum);\n        wasm.transactionbuilder_set_ttl_bignum(this.__wbg_ptr, ttl.__wbg_ptr);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Uses outdated slot number format.\n    * @param {number} validity_start_interval\n    */\n    set_validity_start_interval(validity_start_interval) {\n        wasm.transactionbuilder_set_validity_start_interval(this.__wbg_ptr, validity_start_interval);\n    }\n    /**\n    * @param {BigNum} validity_start_interval\n    */\n    set_validity_start_interval_bignum(validity_start_interval) {\n        _assertClass(validity_start_interval, BigNum);\n        var ptr0 = validity_start_interval.__destroy_into_raw();\n        wasm.transactionbuilder_set_validity_start_interval_bignum(this.__wbg_ptr, ptr0);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Can emit error if add a cert with script credential.\n    * Use set_certs_builder instead.\n    * @param {Certificates} certs\n    */\n    set_certs(certs) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(certs, Certificates);\n            wasm.transactionbuilder_set_certs(retptr, this.__wbg_ptr, certs.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {CertificatesBuilder} certs\n    */\n    set_certs_builder(certs) {\n        _assertClass(certs, CertificatesBuilder);\n        wasm.transactionbuilder_set_certs_builder(this.__wbg_ptr, certs.__wbg_ptr);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Can emit error if add a withdrawal with script credential.\n    * Use set_withdrawals_builder instead.\n    * @param {Withdrawals} withdrawals\n    */\n    set_withdrawals(withdrawals) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(withdrawals, Withdrawals);\n            wasm.transactionbuilder_set_withdrawals(retptr, this.__wbg_ptr, withdrawals.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {WithdrawalsBuilder} withdrawals\n    */\n    set_withdrawals_builder(withdrawals) {\n        _assertClass(withdrawals, WithdrawalsBuilder);\n        wasm.transactionbuilder_set_withdrawals_builder(this.__wbg_ptr, withdrawals.__wbg_ptr);\n    }\n    /**\n    * @param {VotingBuilder} voting_builder\n    */\n    set_voting_builder(voting_builder) {\n        _assertClass(voting_builder, VotingBuilder);\n        wasm.transactionbuilder_set_voting_builder(this.__wbg_ptr, voting_builder.__wbg_ptr);\n    }\n    /**\n    * @param {VotingProposalBuilder} voting_proposal_builder\n    */\n    set_voting_proposal_builder(voting_proposal_builder) {\n        _assertClass(voting_proposal_builder, VotingProposalBuilder);\n        wasm.transactionbuilder_set_voting_proposal_builder(this.__wbg_ptr, voting_proposal_builder.__wbg_ptr);\n    }\n    /**\n    * @returns {AuxiliaryData | undefined}\n    */\n    get_auxiliary_data() {\n        const ret = wasm.transactionbuilder_get_auxiliary_data(this.__wbg_ptr);\n        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * Set explicit auxiliary data via an AuxiliaryData object\n    * It might contain some metadata plus native or Plutus scripts\n    * @param {AuxiliaryData} auxiliary_data\n    */\n    set_auxiliary_data(auxiliary_data) {\n        _assertClass(auxiliary_data, AuxiliaryData);\n        wasm.transactionbuilder_set_auxiliary_data(this.__wbg_ptr, auxiliary_data.__wbg_ptr);\n    }\n    /**\n    * Set metadata using a GeneralTransactionMetadata object\n    * It will be set to the existing or new auxiliary data in this builder\n    * @param {GeneralTransactionMetadata} metadata\n    */\n    set_metadata(metadata) {\n        _assertClass(metadata, GeneralTransactionMetadata);\n        wasm.transactionbuilder_set_metadata(this.__wbg_ptr, metadata.__wbg_ptr);\n    }\n    /**\n    * Add a single metadatum using TransactionMetadatumLabel and TransactionMetadatum objects\n    * It will be securely added to existing or new metadata in this builder\n    * @param {BigNum} key\n    * @param {TransactionMetadatum} val\n    */\n    add_metadatum(key, val) {\n        _assertClass(key, BigNum);\n        _assertClass(val, TransactionMetadatum);\n        wasm.transactionbuilder_add_metadatum(this.__wbg_ptr, key.__wbg_ptr, val.__wbg_ptr);\n    }\n    /**\n    * Add a single JSON metadatum using a TransactionMetadatumLabel and a String\n    * It will be securely added to existing or new metadata in this builder\n    * @param {BigNum} key\n    * @param {string} val\n    */\n    add_json_metadatum(key, val) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(key, BigNum);\n            const ptr0 = passStringToWasm0(val, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionbuilder_add_json_metadatum(retptr, this.__wbg_ptr, key.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Add a single JSON metadatum using a TransactionMetadatumLabel, a String, and a MetadataJsonSchema object\n    * It will be securely added to existing or new metadata in this builder\n    * @param {BigNum} key\n    * @param {string} val\n    * @param {number} schema\n    */\n    add_json_metadatum_with_schema(key, val, schema) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(key, BigNum);\n            const ptr0 = passStringToWasm0(val, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionbuilder_add_json_metadatum_with_schema(retptr, this.__wbg_ptr, key.__wbg_ptr, ptr0, len0, schema);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {MintBuilder} mint_builder\n    */\n    set_mint_builder(mint_builder) {\n        _assertClass(mint_builder, MintBuilder);\n        wasm.transactionbuilder_set_mint_builder(this.__wbg_ptr, mint_builder.__wbg_ptr);\n    }\n    /**\n    * @returns {MintBuilder | undefined}\n    */\n    get_mint_builder() {\n        const ret = wasm.transactionbuilder_get_mint_builder(this.__wbg_ptr);\n        return ret === 0 ? undefined : MintBuilder.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Mints are defining by MintBuilder now.\n    * Use `.set_mint_builder()` and `MintBuilder` instead.\n    * Set explicit Mint object and the required witnesses to this builder\n    * it will replace any previously existing mint and mint scripts\n    * NOTE! Error will be returned in case a mint policy does not have a matching script\n    * @param {Mint} mint\n    * @param {NativeScripts} mint_scripts\n    */\n    set_mint(mint, mint_scripts) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(mint, Mint);\n            _assertClass(mint_scripts, NativeScripts);\n            wasm.transactionbuilder_set_mint(retptr, this.__wbg_ptr, mint.__wbg_ptr, mint_scripts.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Mints are defining by MintBuilder now.\n    * Use `.get_mint_builder()` and `.build()` instead.\n    * Returns a copy of the current mint state in the builder\n    * @returns {Mint | undefined}\n    */\n    get_mint() {\n        const ret = wasm.transactionbuilder_get_mint(this.__wbg_ptr);\n        return ret === 0 ? undefined : Mint.__wrap(ret);\n    }\n    /**\n    * Returns a copy of the current mint witness scripts in the builder\n    * @returns {NativeScripts | undefined}\n    */\n    get_mint_scripts() {\n        const ret = wasm.transactionbuilder_get_mint_scripts(this.__wbg_ptr);\n        return ret === 0 ? undefined : NativeScripts.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Mints are defining by MintBuilder now.\n    * Use `.set_mint_builder()` and `MintBuilder` instead.\n    * Add a mint entry to this builder using a PolicyID and MintAssets object\n    * It will be securely added to existing or new Mint in this builder\n    * It will replace any existing mint assets with the same PolicyID\n    * @param {NativeScript} policy_script\n    * @param {MintAssets} mint_assets\n    */\n    set_mint_asset(policy_script, mint_assets) {\n        _assertClass(policy_script, NativeScript);\n        _assertClass(mint_assets, MintAssets);\n        wasm.transactionbuilder_set_mint_asset(this.__wbg_ptr, policy_script.__wbg_ptr, mint_assets.__wbg_ptr);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Mints are defining by MintBuilder now.\n    * Use `.set_mint_builder()` and `MintBuilder` instead.\n    * Add a mint entry to this builder using a PolicyID, AssetName, and Int object for amount\n    * It will be securely added to existing or new Mint in this builder\n    * It will replace any previous existing amount same PolicyID and AssetName\n    * @param {NativeScript} policy_script\n    * @param {AssetName} asset_name\n    * @param {Int} amount\n    */\n    add_mint_asset(policy_script, asset_name, amount) {\n        _assertClass(policy_script, NativeScript);\n        _assertClass(asset_name, AssetName);\n        _assertClass(amount, Int);\n        wasm.transactionbuilder_add_mint_asset(this.__wbg_ptr, policy_script.__wbg_ptr, asset_name.__wbg_ptr, amount.__wbg_ptr);\n    }\n    /**\n    * Add a mint entry together with an output to this builder\n    * Using a PolicyID, AssetName, Int for amount, Address, and Coin (BigNum) objects\n    * The asset will be securely added to existing or new Mint in this builder\n    * A new output will be added with the specified Address, the Coin value, and the minted asset\n    * @param {NativeScript} policy_script\n    * @param {AssetName} asset_name\n    * @param {Int} amount\n    * @param {TransactionOutputAmountBuilder} output_builder\n    * @param {BigNum} output_coin\n    */\n    add_mint_asset_and_output(policy_script, asset_name, amount, output_builder, output_coin) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(policy_script, NativeScript);\n            _assertClass(asset_name, AssetName);\n            _assertClass(amount, Int);\n            _assertClass(output_builder, TransactionOutputAmountBuilder);\n            _assertClass(output_coin, BigNum);\n            wasm.transactionbuilder_add_mint_asset_and_output(retptr, this.__wbg_ptr, policy_script.__wbg_ptr, asset_name.__wbg_ptr, amount.__wbg_ptr, output_builder.__wbg_ptr, output_coin.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Add a mint entry together with an output to this builder\n    * Using a PolicyID, AssetName, Int for amount, and Address objects\n    * The asset will be securely added to existing or new Mint in this builder\n    * A new output will be added with the specified Address and the minted asset\n    * The output will be set to contain the minimum required amount of Coin\n    * @param {NativeScript} policy_script\n    * @param {AssetName} asset_name\n    * @param {Int} amount\n    * @param {TransactionOutputAmountBuilder} output_builder\n    */\n    add_mint_asset_and_output_min_required_coin(policy_script, asset_name, amount, output_builder) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(policy_script, NativeScript);\n            _assertClass(asset_name, AssetName);\n            _assertClass(amount, Int);\n            _assertClass(output_builder, TransactionOutputAmountBuilder);\n            wasm.transactionbuilder_add_mint_asset_and_output_min_required_coin(retptr, this.__wbg_ptr, policy_script.__wbg_ptr, asset_name.__wbg_ptr, amount.__wbg_ptr, output_builder.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {PlutusData} datum\n    */\n    add_extra_witness_datum(datum) {\n        _assertClass(datum, PlutusData);\n        wasm.transactionbuilder_add_extra_witness_datum(this.__wbg_ptr, datum.__wbg_ptr);\n    }\n    /**\n    * @returns {PlutusList | undefined}\n    */\n    get_extra_witness_datums() {\n        const ret = wasm.transactionbuilder_get_extra_witness_datums(this.__wbg_ptr);\n        return ret === 0 ? undefined : PlutusList.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} donation\n    */\n    set_donation(donation) {\n        _assertClass(donation, BigNum);\n        wasm.transactionbuilder_set_donation(this.__wbg_ptr, donation.__wbg_ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    get_donation() {\n        const ret = wasm.transactionbuilder_get_donation(this.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} current_treasury_value\n    */\n    set_current_treasury_value(current_treasury_value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(current_treasury_value, BigNum);\n            wasm.transactionbuilder_set_current_treasury_value(retptr, this.__wbg_ptr, current_treasury_value.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    get_current_treasury_value() {\n        const ret = wasm.transactionbuilder_get_current_treasury_value(this.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {TransactionBuilderConfig} cfg\n    * @returns {TransactionBuilder}\n    */\n    static new(cfg) {\n        _assertClass(cfg, TransactionBuilderConfig);\n        const ret = wasm.transactionbuilder_new(cfg.__wbg_ptr);\n        return TransactionBuilder.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInputs}\n    */\n    get_reference_inputs() {\n        const ret = wasm.transactionbuilder_get_reference_inputs(this.__wbg_ptr);\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * does not include refunds or withdrawals\n    * @returns {Value}\n    */\n    get_explicit_input() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbuilder_get_explicit_input(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Value.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * withdrawals and refunds\n    * @returns {Value}\n    */\n    get_implicit_input() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbuilder_get_implicit_input(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Value.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Return explicit input plus implicit input plus mint\n    * @returns {Value}\n    */\n    get_total_input() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbuilder_get_total_input(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Value.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Return explicit output plus deposit plus burn\n    * @returns {Value}\n    */\n    get_total_output() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbuilder_get_total_output(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Value.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * does not include fee\n    * @returns {Value}\n    */\n    get_explicit_output() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbuilder_get_explicit_output(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Value.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {BigNum}\n    */\n    get_deposit() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbuilder_get_deposit(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BigNum.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    get_fee_if_set() {\n        const ret = wasm.transactionbuilder_get_fee_if_set(this.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * Warning: this function will mutate the /fee/ field\n    * Make sure to call this function last after setting all other tx-body properties\n    * Editing inputs, outputs, mint, etc. after change been calculated\n    * might cause a mismatch in calculated fee versus the required fee\n    * @param {Address} address\n    * @returns {boolean}\n    */\n    add_change_if_needed(address) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(address, Address);\n            wasm.transactionbuilder_add_change_if_needed(retptr, this.__wbg_ptr, address.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 !== 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Address} address\n    * @param {OutputDatum} plutus_data\n    * @returns {boolean}\n    */\n    add_change_if_needed_with_datum(address, plutus_data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(address, Address);\n            _assertClass(plutus_data, OutputDatum);\n            wasm.transactionbuilder_add_change_if_needed_with_datum(retptr, this.__wbg_ptr, address.__wbg_ptr, plutus_data.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 !== 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * This method will calculate the script hash data\n    * using the plutus datums and redeemers already present in the builder\n    * along with the provided cost model, and will register the calculated value\n    * in the builder to be used when building the tx body.\n    * In case there are no plutus input witnesses present - nothing will change\n    * You can set specific hash value using `.set_script_data_hash`\n    * NOTE: this function will check which language versions are used in the present scripts\n    * and will assert and require for a corresponding cost-model to be present in the passed map.\n    * Only the cost-models for the present language versions will be used in the hash calculation.\n    * @param {Costmdls} cost_models\n    */\n    calc_script_data_hash(cost_models) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(cost_models, Costmdls);\n            wasm.transactionbuilder_calc_script_data_hash(retptr, this.__wbg_ptr, cost_models.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Sets the specified hash value.\n    * Alternatively you can use `.calc_script_data_hash` to calculate the hash automatically.\n    * Or use `.remove_script_data_hash` to delete the previously set value\n    * @param {ScriptDataHash} hash\n    */\n    set_script_data_hash(hash) {\n        _assertClass(hash, ScriptDataHash);\n        wasm.transactionbuilder_set_script_data_hash(this.__wbg_ptr, hash.__wbg_ptr);\n    }\n    /**\n    * Deletes any previously set plutus data hash value.\n    * Use `.set_script_data_hash` or `.calc_script_data_hash` to set it.\n    */\n    remove_script_data_hash() {\n        wasm.transactionbuilder_remove_script_data_hash(this.__wbg_ptr);\n    }\n    /**\n    * @param {Ed25519KeyHash} key\n    */\n    add_required_signer(key) {\n        _assertClass(key, Ed25519KeyHash);\n        wasm.transactionbuilder_add_required_signer(this.__wbg_ptr, key.__wbg_ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    full_size() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbuilder_full_size(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint32Array}\n    */\n    output_sizes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbuilder_output_sizes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns object the body of the new transaction\n    * Auxiliary data itself is not included\n    * You can use `get_auxiliary_data` or `build_tx`\n    * @returns {TransactionBody}\n    */\n    build() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbuilder_build(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionBody.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns full Transaction object with the body and the auxiliary data\n    * NOTE: witness_set will contain all mint_scripts if any been added or set\n    * NOTE: is_valid set to true\n    * NOTE: Will fail in case there are any script inputs added with no corresponding witness\n    * @returns {Transaction}\n    */\n    build_tx() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbuilder_build_tx(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Similar to `.build_tx()` but will NOT fail in case there are missing script witnesses\n    * @returns {Transaction}\n    */\n    build_tx_unsafe() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbuilder_build_tx_unsafe(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * warning: sum of all parts of a transaction must equal 0. You cannot just set the fee to the min value and forget about it\n    * warning: min_fee may be slightly larger than the actual minimum fee (ex: a few lovelaces)\n    * this is done to simplify the library code, but can be fixed later\n    * @returns {BigNum}\n    */\n    min_fee() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbuilder_min_fee(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BigNum.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass TransactionBuilderConfig {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionBuilderConfig.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionbuilderconfig_free(ptr);\n    }\n}\n/**\n*/\nclass TransactionBuilderConfigBuilder {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionBuilderConfigBuilder.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionbuilderconfigbuilder_free(ptr);\n    }\n    /**\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    static new() {\n        const ret = wasm.transactionbuilderconfigbuilder_new();\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {LinearFee} fee_algo\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    fee_algo(fee_algo) {\n        _assertClass(fee_algo, LinearFee);\n        const ret = wasm.transactionbuilderconfigbuilder_fee_algo(this.__wbg_ptr, fee_algo.__wbg_ptr);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Since babbage era cardano nodes use coins per byte. Use '.coins_per_utxo_byte' instead.\n    * @param {BigNum} coins_per_utxo_word\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    coins_per_utxo_word(coins_per_utxo_word) {\n        _assertClass(coins_per_utxo_word, BigNum);\n        const ret = wasm.transactionbuilderconfigbuilder_coins_per_utxo_word(this.__wbg_ptr, coins_per_utxo_word.__wbg_ptr);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coins_per_utxo_byte\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    coins_per_utxo_byte(coins_per_utxo_byte) {\n        _assertClass(coins_per_utxo_byte, BigNum);\n        const ret = wasm.transactionbuilderconfigbuilder_coins_per_utxo_byte(this.__wbg_ptr, coins_per_utxo_byte.__wbg_ptr);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {ExUnitPrices} ex_unit_prices\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    ex_unit_prices(ex_unit_prices) {\n        _assertClass(ex_unit_prices, ExUnitPrices);\n        const ret = wasm.transactionbuilderconfigbuilder_ex_unit_prices(this.__wbg_ptr, ex_unit_prices.__wbg_ptr);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} pool_deposit\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    pool_deposit(pool_deposit) {\n        _assertClass(pool_deposit, BigNum);\n        const ret = wasm.transactionbuilderconfigbuilder_pool_deposit(this.__wbg_ptr, pool_deposit.__wbg_ptr);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} key_deposit\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    key_deposit(key_deposit) {\n        _assertClass(key_deposit, BigNum);\n        const ret = wasm.transactionbuilderconfigbuilder_key_deposit(this.__wbg_ptr, key_deposit.__wbg_ptr);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {number} max_value_size\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    max_value_size(max_value_size) {\n        const ret = wasm.transactionbuilderconfigbuilder_max_value_size(this.__wbg_ptr, max_value_size);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {number} max_tx_size\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    max_tx_size(max_tx_size) {\n        const ret = wasm.transactionbuilderconfigbuilder_max_tx_size(this.__wbg_ptr, max_tx_size);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {boolean} prefer_pure_change\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    prefer_pure_change(prefer_pure_change) {\n        const ret = wasm.transactionbuilderconfigbuilder_prefer_pure_change(this.__wbg_ptr, prefer_pure_change);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} voting_proposal_deposit\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    voting_proposal_deposit(voting_proposal_deposit) {\n        _assertClass(voting_proposal_deposit, BigNum);\n        const ret = wasm.transactionbuilderconfigbuilder_voting_proposal_deposit(this.__wbg_ptr, voting_proposal_deposit.__wbg_ptr);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionBuilderConfig}\n    */\n    build() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbuilderconfigbuilder_build(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionBuilderConfig.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass TransactionHash {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionHash.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionhash_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionHash}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionhash_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchordatahash_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.anchordatahash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {TransactionHash}\n    */\n    static from_bech32(bech_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionhash_from_bech32(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchordatahash_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {TransactionHash}\n    */\n    static from_hex(hex) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionhash_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass TransactionInput {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionInput.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactioninput_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactioninput_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionInput}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactioninput_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionInput.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactioninput_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TransactionInput}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactioninput_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionInput.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactioninput_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactioninput_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {TransactionInput}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactioninput_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionInput.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {TransactionHash}\n    */\n    transaction_id() {\n        const ret = wasm.transactioninput_transaction_id(this.__wbg_ptr);\n        return TransactionHash.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    index() {\n        const ret = wasm.transactioninput_index(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {TransactionHash} transaction_id\n    * @param {number} index\n    * @returns {TransactionInput}\n    */\n    static new(transaction_id, index) {\n        _assertClass(transaction_id, TransactionHash);\n        const ret = wasm.transactioninput_new(transaction_id.__wbg_ptr, index);\n        return TransactionInput.__wrap(ret);\n    }\n}\n/**\n*/\nclass TransactionInputs {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionInputs.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactioninputs_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactioninputs_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionInputs}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactioninputs_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionInputs.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactioninputs_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TransactionInputs}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactioninputs_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionInputs.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactioninputs_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactioninputs_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {TransactionInputs}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactioninputs_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionInputs.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {TransactionInputs}\n    */\n    static new() {\n        const ret = wasm.assetnames_new();\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.assetnames_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionInput}\n    */\n    get(index) {\n        const ret = wasm.transactioninputs_get(this.__wbg_ptr, index);\n        return TransactionInput.__wrap(ret);\n    }\n    /**\n    * @param {TransactionInput} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionInput);\n        wasm.transactioninputs_add(this.__wbg_ptr, elem.__wbg_ptr);\n    }\n    /**\n    * @returns {TransactionInputs | undefined}\n    */\n    to_option() {\n        const ret = wasm.transactioninputs_to_option(this.__wbg_ptr);\n        return ret === 0 ? undefined : TransactionInputs.__wrap(ret);\n    }\n}\n/**\n*/\nclass TransactionMetadatum {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionMetadatum.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionmetadatum_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionmetadatum_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionMetadatum}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionmetadatum_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionMetadatum.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionmetadatum_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TransactionMetadatum}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionmetadatum_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionMetadatum.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {MetadataMap} map\n    * @returns {TransactionMetadatum}\n    */\n    static new_map(map) {\n        _assertClass(map, MetadataMap);\n        const ret = wasm.transactionmetadatum_new_map(map.__wbg_ptr);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {MetadataList} list\n    * @returns {TransactionMetadatum}\n    */\n    static new_list(list) {\n        _assertClass(list, MetadataList);\n        const ret = wasm.transactionmetadatum_new_list(list.__wbg_ptr);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {Int} int\n    * @returns {TransactionMetadatum}\n    */\n    static new_int(int) {\n        _assertClass(int, Int);\n        const ret = wasm.transactionmetadatum_new_int(int.__wbg_ptr);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionMetadatum}\n    */\n    static new_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionmetadatum_new_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionMetadatum.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} text\n    * @returns {TransactionMetadatum}\n    */\n    static new_text(text) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionmetadatum_new_text(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionMetadatum.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        const ret = wasm.transactionmetadatum_kind(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {MetadataMap}\n    */\n    as_map() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionmetadatum_as_map(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return MetadataMap.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {MetadataList}\n    */\n    as_list() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionmetadatum_as_list(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return MetadataList.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Int}\n    */\n    as_int() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionmetadatum_as_int(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Int.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionmetadatum_as_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    as_text() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionmetadatum_as_text(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n}\n/**\n*/\nclass TransactionMetadatumLabels {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionMetadatumLabels.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionmetadatumlabels_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionmetadatumlabels_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionMetadatumLabels}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionmetadatumlabels_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionMetadatumLabels.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionmetadatumlabels_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TransactionMetadatumLabels}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionmetadatumlabels_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionMetadatumLabels.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {TransactionMetadatumLabels}\n    */\n    static new() {\n        const ret = wasm.metadatalist_new();\n        return TransactionMetadatumLabels.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.metadatalist_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {BigNum}\n    */\n    get(index) {\n        const ret = wasm.transactionmetadatumlabels_get(this.__wbg_ptr, index);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} elem\n    */\n    add(elem) {\n        _assertClass(elem, BigNum);\n        wasm.transactionmetadatumlabels_add(this.__wbg_ptr, elem.__wbg_ptr);\n    }\n}\n/**\n*/\nclass TransactionOutput {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionOutput.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionoutput_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionoutput_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionOutput}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionoutput_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionOutput.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionoutput_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TransactionOutput}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionoutput_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionOutput.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionoutput_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionoutput_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {TransactionOutput}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionoutput_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionOutput.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Address}\n    */\n    address() {\n        const ret = wasm.transactionoutput_address(this.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @returns {Value}\n    */\n    amount() {\n        const ret = wasm.transactionoutput_amount(this.__wbg_ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @returns {DataHash | undefined}\n    */\n    data_hash() {\n        const ret = wasm.transactionoutput_data_hash(this.__wbg_ptr);\n        return ret === 0 ? undefined : DataHash.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusData | undefined}\n    */\n    plutus_data() {\n        const ret = wasm.transactionoutput_plutus_data(this.__wbg_ptr);\n        return ret === 0 ? undefined : PlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptRef | undefined}\n    */\n    script_ref() {\n        const ret = wasm.transactionoutput_script_ref(this.__wbg_ptr);\n        return ret === 0 ? undefined : ScriptRef.__wrap(ret);\n    }\n    /**\n    * @param {ScriptRef} script_ref\n    */\n    set_script_ref(script_ref) {\n        _assertClass(script_ref, ScriptRef);\n        wasm.transactionoutput_set_script_ref(this.__wbg_ptr, script_ref.__wbg_ptr);\n    }\n    /**\n    * @param {PlutusData} data\n    */\n    set_plutus_data(data) {\n        _assertClass(data, PlutusData);\n        wasm.transactionoutput_set_plutus_data(this.__wbg_ptr, data.__wbg_ptr);\n    }\n    /**\n    * @param {DataHash} data_hash\n    */\n    set_data_hash(data_hash) {\n        _assertClass(data_hash, DataHash);\n        wasm.transactionoutput_set_data_hash(this.__wbg_ptr, data_hash.__wbg_ptr);\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_plutus_data() {\n        const ret = wasm.transactionoutput_has_plutus_data(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_data_hash() {\n        const ret = wasm.transactionoutput_has_data_hash(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_script_ref() {\n        const ret = wasm.transactionoutput_has_script_ref(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {Address} address\n    * @param {Value} amount\n    * @returns {TransactionOutput}\n    */\n    static new(address, amount) {\n        _assertClass(address, Address);\n        _assertClass(amount, Value);\n        const ret = wasm.transactionoutput_new(address.__wbg_ptr, amount.__wbg_ptr);\n        return TransactionOutput.__wrap(ret);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    serialization_format() {\n        const ret = wasm.transactionoutput_serialization_format(this.__wbg_ptr);\n        return ret === 2 ? undefined : ret;\n    }\n}\n/**\n*/\nclass TransactionOutputAmountBuilder {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionOutputAmountBuilder.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionoutputamountbuilder_free(ptr);\n    }\n    /**\n    * @param {Value} amount\n    * @returns {TransactionOutputAmountBuilder}\n    */\n    with_value(amount) {\n        _assertClass(amount, Value);\n        const ret = wasm.transactionoutputamountbuilder_with_value(this.__wbg_ptr, amount.__wbg_ptr);\n        return TransactionOutputAmountBuilder.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coin\n    * @returns {TransactionOutputAmountBuilder}\n    */\n    with_coin(coin) {\n        _assertClass(coin, BigNum);\n        const ret = wasm.transactionoutputamountbuilder_with_coin(this.__wbg_ptr, coin.__wbg_ptr);\n        return TransactionOutputAmountBuilder.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coin\n    * @param {MultiAsset} multiasset\n    * @returns {TransactionOutputAmountBuilder}\n    */\n    with_coin_and_asset(coin, multiasset) {\n        _assertClass(coin, BigNum);\n        _assertClass(multiasset, MultiAsset);\n        const ret = wasm.transactionoutputamountbuilder_with_coin_and_asset(this.__wbg_ptr, coin.__wbg_ptr, multiasset.__wbg_ptr);\n        return TransactionOutputAmountBuilder.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Since babbage era cardano nodes use coins per byte. Use '.with_asset_and_min_required_coin_by_utxo_cost' instead.\n    * @param {MultiAsset} multiasset\n    * @param {BigNum} coins_per_utxo_word\n    * @returns {TransactionOutputAmountBuilder}\n    */\n    with_asset_and_min_required_coin(multiasset, coins_per_utxo_word) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(multiasset, MultiAsset);\n            _assertClass(coins_per_utxo_word, BigNum);\n            wasm.transactionoutputamountbuilder_with_asset_and_min_required_coin(retptr, this.__wbg_ptr, multiasset.__wbg_ptr, coins_per_utxo_word.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionOutputAmountBuilder.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {MultiAsset} multiasset\n    * @param {DataCost} data_cost\n    * @returns {TransactionOutputAmountBuilder}\n    */\n    with_asset_and_min_required_coin_by_utxo_cost(multiasset, data_cost) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(multiasset, MultiAsset);\n            _assertClass(data_cost, DataCost);\n            wasm.transactionoutputamountbuilder_with_asset_and_min_required_coin_by_utxo_cost(retptr, this.__wbg_ptr, multiasset.__wbg_ptr, data_cost.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionOutputAmountBuilder.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {TransactionOutput}\n    */\n    build() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionoutputamountbuilder_build(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionOutput.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* We introduce a builder-pattern format for creating transaction outputs\n* This is because:\n* 1. Some fields (i.e. data hash) are optional, and we can't easily expose Option<> in WASM\n* 2. Some fields like amounts have many ways it could be set (some depending on other field values being known)\n* 3. Easier to adapt as the output format gets more complicated in future Cardano releases\n*/\nclass TransactionOutputBuilder {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionOutputBuilder.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionoutputbuilder_free(ptr);\n    }\n    /**\n    * @returns {TransactionOutputBuilder}\n    */\n    static new() {\n        const ret = wasm.transactionoutputbuilder_new();\n        return TransactionOutputBuilder.__wrap(ret);\n    }\n    /**\n    * @param {Address} address\n    * @returns {TransactionOutputBuilder}\n    */\n    with_address(address) {\n        _assertClass(address, Address);\n        const ret = wasm.transactionoutputbuilder_with_address(this.__wbg_ptr, address.__wbg_ptr);\n        return TransactionOutputBuilder.__wrap(ret);\n    }\n    /**\n    * @param {DataHash} data_hash\n    * @returns {TransactionOutputBuilder}\n    */\n    with_data_hash(data_hash) {\n        _assertClass(data_hash, DataHash);\n        const ret = wasm.transactionoutputbuilder_with_data_hash(this.__wbg_ptr, data_hash.__wbg_ptr);\n        return TransactionOutputBuilder.__wrap(ret);\n    }\n    /**\n    * @param {PlutusData} data\n    * @returns {TransactionOutputBuilder}\n    */\n    with_plutus_data(data) {\n        _assertClass(data, PlutusData);\n        const ret = wasm.transactionoutputbuilder_with_plutus_data(this.__wbg_ptr, data.__wbg_ptr);\n        return TransactionOutputBuilder.__wrap(ret);\n    }\n    /**\n    * @param {ScriptRef} script_ref\n    * @returns {TransactionOutputBuilder}\n    */\n    with_script_ref(script_ref) {\n        _assertClass(script_ref, ScriptRef);\n        const ret = wasm.transactionoutputbuilder_with_script_ref(this.__wbg_ptr, script_ref.__wbg_ptr);\n        return TransactionOutputBuilder.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionOutputAmountBuilder}\n    */\n    next() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionoutputbuilder_next(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionOutputAmountBuilder.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass TransactionOutputs {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionOutputs.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionoutputs_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionoutputs_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionOutputs}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionoutputs_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionOutputs.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionoutputs_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TransactionOutputs}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionoutputs_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionOutputs.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionoutputs_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionoutputs_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {TransactionOutputs}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionoutputs_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionOutputs.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {TransactionOutputs}\n    */\n    static new() {\n        const ret = wasm.nativescripts_new();\n        return TransactionOutputs.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.assetnames_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionOutput}\n    */\n    get(index) {\n        const ret = wasm.transactionoutputs_get(this.__wbg_ptr, index);\n        return TransactionOutput.__wrap(ret);\n    }\n    /**\n    * @param {TransactionOutput} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionOutput);\n        wasm.transactionoutputs_add(this.__wbg_ptr, elem.__wbg_ptr);\n    }\n}\n/**\n*/\nclass TransactionUnspentOutput {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionUnspentOutput.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionunspentoutput_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionunspentoutput_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionUnspentOutput}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionunspentoutput_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionUnspentOutput.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionunspentoutput_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TransactionUnspentOutput}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionunspentoutput_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionUnspentOutput.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionunspentoutput_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionunspentoutput_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {TransactionUnspentOutput}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionunspentoutput_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionUnspentOutput.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {TransactionInput} input\n    * @param {TransactionOutput} output\n    * @returns {TransactionUnspentOutput}\n    */\n    static new(input, output) {\n        _assertClass(input, TransactionInput);\n        _assertClass(output, TransactionOutput);\n        const ret = wasm.transactionunspentoutput_new(input.__wbg_ptr, output.__wbg_ptr);\n        return TransactionUnspentOutput.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInput}\n    */\n    input() {\n        const ret = wasm.transactionunspentoutput_input(this.__wbg_ptr);\n        return TransactionInput.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionOutput}\n    */\n    output() {\n        const ret = wasm.transactionunspentoutput_output(this.__wbg_ptr);\n        return TransactionOutput.__wrap(ret);\n    }\n}\n/**\n*/\nclass TransactionUnspentOutputs {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionUnspentOutputs.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionunspentoutputs_free(ptr);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionunspentoutputs_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionunspentoutputs_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {TransactionUnspentOutputs}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionunspentoutputs_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionUnspentOutputs.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {TransactionUnspentOutputs}\n    */\n    static new() {\n        const ret = wasm.inputswithscriptwitness_new();\n        return TransactionUnspentOutputs.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.inputswithscriptwitness_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionUnspentOutput}\n    */\n    get(index) {\n        const ret = wasm.transactionunspentoutputs_get(this.__wbg_ptr, index);\n        return TransactionUnspentOutput.__wrap(ret);\n    }\n    /**\n    * @param {TransactionUnspentOutput} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionUnspentOutput);\n        wasm.transactionunspentoutputs_add(this.__wbg_ptr, elem.__wbg_ptr);\n    }\n}\n/**\n*/\nclass TransactionWitnessSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionWitnessSet.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionwitnessset_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionwitnessset_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionWitnessSet}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionwitnessset_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionWitnessSet.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionwitnessset_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TransactionWitnessSet}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionwitnessset_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionWitnessSet.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionwitnessset_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionwitnessset_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {TransactionWitnessSet}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionwitnessset_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionWitnessSet.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Vkeywitnesses} vkeys\n    */\n    set_vkeys(vkeys) {\n        _assertClass(vkeys, Vkeywitnesses);\n        wasm.transactionwitnessset_set_vkeys(this.__wbg_ptr, vkeys.__wbg_ptr);\n    }\n    /**\n    * @returns {Vkeywitnesses | undefined}\n    */\n    vkeys() {\n        const ret = wasm.transactionwitnessset_vkeys(this.__wbg_ptr);\n        return ret === 0 ? undefined : Vkeywitnesses.__wrap(ret);\n    }\n    /**\n    * @param {NativeScripts} native_scripts\n    */\n    set_native_scripts(native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        wasm.transactionwitnessset_set_native_scripts(this.__wbg_ptr, native_scripts.__wbg_ptr);\n    }\n    /**\n    * @returns {NativeScripts | undefined}\n    */\n    native_scripts() {\n        const ret = wasm.transactionwitnessset_native_scripts(this.__wbg_ptr);\n        return ret === 0 ? undefined : NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {BootstrapWitnesses} bootstraps\n    */\n    set_bootstraps(bootstraps) {\n        _assertClass(bootstraps, BootstrapWitnesses);\n        wasm.transactionwitnessset_set_bootstraps(this.__wbg_ptr, bootstraps.__wbg_ptr);\n    }\n    /**\n    * @returns {BootstrapWitnesses | undefined}\n    */\n    bootstraps() {\n        const ret = wasm.transactionwitnessset_bootstraps(this.__wbg_ptr);\n        return ret === 0 ? undefined : BootstrapWitnesses.__wrap(ret);\n    }\n    /**\n    * @param {PlutusScripts} plutus_scripts\n    */\n    set_plutus_scripts(plutus_scripts) {\n        _assertClass(plutus_scripts, PlutusScripts);\n        wasm.transactionwitnessset_set_plutus_scripts(this.__wbg_ptr, plutus_scripts.__wbg_ptr);\n    }\n    /**\n    * @returns {PlutusScripts | undefined}\n    */\n    plutus_scripts() {\n        const ret = wasm.transactionwitnessset_plutus_scripts(this.__wbg_ptr);\n        return ret === 0 ? undefined : PlutusScripts.__wrap(ret);\n    }\n    /**\n    * @param {PlutusList} plutus_data\n    */\n    set_plutus_data(plutus_data) {\n        _assertClass(plutus_data, PlutusList);\n        wasm.transactionwitnessset_set_plutus_data(this.__wbg_ptr, plutus_data.__wbg_ptr);\n    }\n    /**\n    * @returns {PlutusList | undefined}\n    */\n    plutus_data() {\n        const ret = wasm.transactionwitnessset_plutus_data(this.__wbg_ptr);\n        return ret === 0 ? undefined : PlutusList.__wrap(ret);\n    }\n    /**\n    * @param {Redeemers} redeemers\n    */\n    set_redeemers(redeemers) {\n        _assertClass(redeemers, Redeemers);\n        wasm.transactionwitnessset_set_redeemers(this.__wbg_ptr, redeemers.__wbg_ptr);\n    }\n    /**\n    * @returns {Redeemers | undefined}\n    */\n    redeemers() {\n        const ret = wasm.transactionwitnessset_redeemers(this.__wbg_ptr);\n        return ret === 0 ? undefined : Redeemers.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionWitnessSet}\n    */\n    static new() {\n        const ret = wasm.transactionwitnessset_new();\n        return TransactionWitnessSet.__wrap(ret);\n    }\n}\n/**\n*/\nclass TransactionWitnessSets {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionWitnessSets.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionwitnesssets_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionwitnesssets_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionWitnessSets}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionwitnesssets_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionWitnessSets.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionwitnesssets_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TransactionWitnessSets}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionwitnesssets_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionWitnessSets.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionwitnesssets_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionwitnesssets_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {TransactionWitnessSets}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transactionwitnesssets_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionWitnessSets.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {TransactionWitnessSets}\n    */\n    static new() {\n        const ret = wasm.assetnames_new();\n        return TransactionWitnessSets.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.assetnames_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionWitnessSet}\n    */\n    get(index) {\n        const ret = wasm.transactionwitnesssets_get(this.__wbg_ptr, index);\n        return TransactionWitnessSet.__wrap(ret);\n    }\n    /**\n    * @param {TransactionWitnessSet} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionWitnessSet);\n        wasm.transactionwitnesssets_add(this.__wbg_ptr, elem.__wbg_ptr);\n    }\n}\n/**\n*/\nclass TreasuryWithdrawals {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TreasuryWithdrawals.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_treasurywithdrawals_free(ptr);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.treasurywithdrawals_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.treasurywithdrawals_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {TreasuryWithdrawals}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.treasurywithdrawals_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TreasuryWithdrawals.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {TreasuryWithdrawals}\n    */\n    static new() {\n        const ret = wasm.treasurywithdrawals_new();\n        return TreasuryWithdrawals.__wrap(ret);\n    }\n    /**\n    * @param {RewardAddress} key\n    * @returns {BigNum | undefined}\n    */\n    get(key) {\n        _assertClass(key, RewardAddress);\n        const ret = wasm.treasurywithdrawals_get(this.__wbg_ptr, key.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {RewardAddress} key\n    * @param {BigNum} value\n    */\n    insert(key, value) {\n        _assertClass(key, RewardAddress);\n        _assertClass(value, BigNum);\n        wasm.treasurywithdrawals_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);\n    }\n    /**\n    * @returns {RewardAddresses}\n    */\n    keys() {\n        const ret = wasm.treasurywithdrawals_keys(this.__wbg_ptr);\n        return RewardAddresses.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.treasurywithdrawals_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nclass TreasuryWithdrawalsProposal {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TreasuryWithdrawalsProposal.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_treasurywithdrawalsproposal_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.treasurywithdrawalsproposal_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TreasuryWithdrawalsProposal}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.treasurywithdrawalsproposal_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TreasuryWithdrawalsProposal.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.treasurywithdrawalsproposal_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TreasuryWithdrawalsProposal}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.treasurywithdrawalsproposal_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TreasuryWithdrawalsProposal.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.treasurywithdrawalsproposal_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.treasurywithdrawalsproposal_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {TreasuryWithdrawalsProposal}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.treasurywithdrawalsproposal_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TreasuryWithdrawalsProposal.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {TreasuryWithdrawals}\n    */\n    withdrawals() {\n        const ret = wasm.treasurywithdrawalsproposal_withdrawals(this.__wbg_ptr);\n        return TreasuryWithdrawals.__wrap(ret);\n    }\n    /**\n    * @param {TreasuryWithdrawals} withdrawals\n    * @returns {TreasuryWithdrawalsProposal}\n    */\n    static new(withdrawals) {\n        _assertClass(withdrawals, TreasuryWithdrawals);\n        const ret = wasm.treasurywithdrawalsproposal_new(withdrawals.__wbg_ptr);\n        return TreasuryWithdrawalsProposal.__wrap(ret);\n    }\n}\n/**\n*/\nclass TxBuilderConstants {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_txbuilderconstants_free(ptr);\n    }\n    /**\n    * @returns {Costmdls}\n    */\n    static plutus_default_cost_models() {\n        const ret = wasm.txbuilderconstants_plutus_default_cost_models();\n        return Costmdls.__wrap(ret);\n    }\n    /**\n    * @returns {Costmdls}\n    */\n    static plutus_alonzo_cost_models() {\n        const ret = wasm.txbuilderconstants_plutus_alonzo_cost_models();\n        return Costmdls.__wrap(ret);\n    }\n    /**\n    * @returns {Costmdls}\n    */\n    static plutus_vasil_cost_models() {\n        const ret = wasm.txbuilderconstants_plutus_default_cost_models();\n        return Costmdls.__wrap(ret);\n    }\n}\n/**\n*/\nclass TxInputsBuilder {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TxInputsBuilder.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_txinputsbuilder_free(ptr);\n    }\n    /**\n    * @returns {TxInputsBuilder}\n    */\n    static new() {\n        const ret = wasm.txinputsbuilder_new();\n        return TxInputsBuilder.__wrap(ret);\n    }\n    /**\n    * We have to know what kind of inputs these are to know what kind of mock witnesses to create since\n    * 1) mock witnesses have different lengths depending on the type which changes the expecting fee\n    * 2) Witnesses are a set so we need to get rid of duplicates to avoid over-estimating the fee\n    * @param {Ed25519KeyHash} hash\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_key_input(hash, input, amount) {\n        _assertClass(hash, Ed25519KeyHash);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.txinputsbuilder_add_key_input(this.__wbg_ptr, hash.__wbg_ptr, input.__wbg_ptr, amount.__wbg_ptr);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * This function can make a mistake in choosing right input index. Use `.add_native_script_input` or `.add_plutus_script_input` instead.\n    * This method adds the input to the builder BUT leaves a missing spot for the witness native script\n    *\n    * After adding the input with this method, use `.add_required_native_input_scripts`\n    * and `.add_required_plutus_input_scripts` to add the witness scripts\n    *\n    * Or instead use `.add_native_script_input` and `.add_plutus_script_input`\n    * to add inputs right along with the script, instead of the script hash\n    * @param {ScriptHash} hash\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_script_input(hash, input, amount) {\n        _assertClass(hash, ScriptHash);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.txinputsbuilder_add_script_input(this.__wbg_ptr, hash.__wbg_ptr, input.__wbg_ptr, amount.__wbg_ptr);\n    }\n    /**\n    * This method will add the input to the builder and also register the required native script witness\n    * @param {NativeScript} script\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_native_script_input(script, input, amount) {\n        _assertClass(script, NativeScript);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.txinputsbuilder_add_native_script_input(this.__wbg_ptr, script.__wbg_ptr, input.__wbg_ptr, amount.__wbg_ptr);\n    }\n    /**\n    * This method will add the input to the builder and also register the required plutus witness\n    * @param {PlutusWitness} witness\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_plutus_script_input(witness, input, amount) {\n        _assertClass(witness, PlutusWitness);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.txinputsbuilder_add_plutus_script_input(this.__wbg_ptr, witness.__wbg_ptr, input.__wbg_ptr, amount.__wbg_ptr);\n    }\n    /**\n    * @param {ByronAddress} hash\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_bootstrap_input(hash, input, amount) {\n        _assertClass(hash, ByronAddress);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.txinputsbuilder_add_bootstrap_input(this.__wbg_ptr, hash.__wbg_ptr, input.__wbg_ptr, amount.__wbg_ptr);\n    }\n    /**\n    * Note that for script inputs this method will use underlying generic `.add_script_input`\n    * which leaves a required empty spot for the script witness (or witnesses in case of Plutus).\n    * You can use `.add_native_script_input` or `.add_plutus_script_input` directly to register the input along with the witness.\n    * @param {Address} address\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_input(address, input, amount) {\n        _assertClass(address, Address);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.txinputsbuilder_add_input(this.__wbg_ptr, address.__wbg_ptr, input.__wbg_ptr, amount.__wbg_ptr);\n    }\n    /**\n    * Returns the number of still missing input scripts (either native or plutus)\n    * Use `.add_required_native_input_scripts` or `.add_required_plutus_input_scripts` to add the missing scripts\n    * @returns {number}\n    */\n    count_missing_input_scripts() {\n        const ret = wasm.txinputsbuilder_count_missing_input_scripts(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Try adding the specified scripts as witnesses for ALREADY ADDED script inputs\n    * Any scripts that don't match any of the previously added inputs will be ignored\n    * Returns the number of remaining required missing witness scripts\n    * Use `.count_missing_input_scripts` to find the number of still missing scripts\n    * @param {NativeScripts} scripts\n    * @returns {number}\n    */\n    add_required_native_input_scripts(scripts) {\n        _assertClass(scripts, NativeScripts);\n        const ret = wasm.txinputsbuilder_add_required_native_input_scripts(this.__wbg_ptr, scripts.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * This function can make a mistake in choosing right input index. Use `.add_required_script_input_witnesses` instead.\n    * Try adding the specified scripts as witnesses for ALREADY ADDED script inputs\n    * Any scripts that don't match any of the previously added inputs will be ignored\n    * Returns the number of remaining required missing witness scripts\n    * Use `.count_missing_input_scripts` to find the number of still missing scripts\n    * @param {PlutusWitnesses} scripts\n    * @returns {number}\n    */\n    add_required_plutus_input_scripts(scripts) {\n        _assertClass(scripts, PlutusWitnesses);\n        const ret = wasm.txinputsbuilder_add_required_plutus_input_scripts(this.__wbg_ptr, scripts.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Try adding the specified scripts as witnesses for ALREADY ADDED script inputs\n    * Any scripts that don't match any of the previously added inputs will be ignored\n    * Returns the number of remaining required missing witness scripts\n    * Use `.count_missing_input_scripts` to find the number of still missing scripts\n    * @param {InputsWithScriptWitness} inputs_with_wit\n    * @returns {number}\n    */\n    add_required_script_input_witnesses(inputs_with_wit) {\n        _assertClass(inputs_with_wit, InputsWithScriptWitness);\n        const ret = wasm.txinputsbuilder_add_required_script_input_witnesses(this.__wbg_ptr, inputs_with_wit.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {TransactionInputs}\n    */\n    get_ref_inputs() {\n        const ret = wasm.txinputsbuilder_get_ref_inputs(this.__wbg_ptr);\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * Returns a copy of the current script input witness scripts in the builder\n    * @returns {NativeScripts | undefined}\n    */\n    get_native_input_scripts() {\n        const ret = wasm.txinputsbuilder_get_native_input_scripts(this.__wbg_ptr);\n        return ret === 0 ? undefined : NativeScripts.__wrap(ret);\n    }\n    /**\n    * Returns a copy of the current plutus input witness scripts in the builder.\n    * NOTE: each plutus witness will be cloned with a specific corresponding input index\n    * @returns {PlutusWitnesses | undefined}\n    */\n    get_plutus_input_scripts() {\n        const ret = wasm.txinputsbuilder_get_plutus_input_scripts(this.__wbg_ptr);\n        return ret === 0 ? undefined : PlutusWitnesses.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.txinputsbuilder_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {Ed25519KeyHash} key\n    */\n    add_required_signer(key) {\n        _assertClass(key, Ed25519KeyHash);\n        wasm.txinputsbuilder_add_required_signer(this.__wbg_ptr, key.__wbg_ptr);\n    }\n    /**\n    * @param {Ed25519KeyHashes} keys\n    */\n    add_required_signers(keys) {\n        _assertClass(keys, Ed25519KeyHashes);\n        wasm.txinputsbuilder_add_required_signers(this.__wbg_ptr, keys.__wbg_ptr);\n    }\n    /**\n    * @returns {Value}\n    */\n    total_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.txinputsbuilder_total_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Value.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {TransactionInputs}\n    */\n    inputs() {\n        const ret = wasm.txinputsbuilder_inputs(this.__wbg_ptr);\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInputs | undefined}\n    */\n    inputs_option() {\n        const ret = wasm.txinputsbuilder_inputs_option(this.__wbg_ptr);\n        return ret === 0 ? undefined : TransactionInputs.__wrap(ret);\n    }\n}\n/**\n*/\nclass URL {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(URL.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_url_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.url_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {URL}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.url_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return URL.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.url_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {URL}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.url_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return URL.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordaoraaaa_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordaoraaaa_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {URL}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.url_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return URL.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} url\n    * @returns {URL}\n    */\n    static new(url) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.url_new(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return URL.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    url() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordaoraaaa_record(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n/**\n*/\nclass UnitInterval {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(UnitInterval.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_unitinterval_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unitinterval_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {UnitInterval}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.unitinterval_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return UnitInterval.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unitinterval_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {UnitInterval}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.unitinterval_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return UnitInterval.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unitinterval_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unitinterval_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {UnitInterval}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.unitinterval_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return UnitInterval.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {BigNum}\n    */\n    numerator() {\n        const ret = wasm.timelockexpiry_slot_bignum(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    denominator() {\n        const ret = wasm.unitinterval_denominator(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} numerator\n    * @param {BigNum} denominator\n    * @returns {UnitInterval}\n    */\n    static new(numerator, denominator) {\n        _assertClass(numerator, BigNum);\n        _assertClass(denominator, BigNum);\n        const ret = wasm.unitinterval_new(numerator.__wbg_ptr, denominator.__wbg_ptr);\n        return UnitInterval.__wrap(ret);\n    }\n}\n/**\n*/\nclass Update {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Update.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_update_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.update_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Update}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.update_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Update.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.update_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Update}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.update_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Update.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.update_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.update_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Update}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.update_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Update.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {ProposedProtocolParameterUpdates}\n    */\n    proposed_protocol_parameter_updates() {\n        const ret = wasm.update_proposed_protocol_parameter_updates(this.__wbg_ptr);\n        return ProposedProtocolParameterUpdates.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    epoch() {\n        const ret = wasm.update_epoch(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {ProposedProtocolParameterUpdates} proposed_protocol_parameter_updates\n    * @param {number} epoch\n    * @returns {Update}\n    */\n    static new(proposed_protocol_parameter_updates, epoch) {\n        _assertClass(proposed_protocol_parameter_updates, ProposedProtocolParameterUpdates);\n        const ret = wasm.update_new(proposed_protocol_parameter_updates.__wbg_ptr, epoch);\n        return Update.__wrap(ret);\n    }\n}\n/**\n*/\nclass UpdateCommitteeProposal {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(UpdateCommitteeProposal.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_updatecommitteeproposal_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.updatecommitteeproposal_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {UpdateCommitteeProposal}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.updatecommitteeproposal_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return UpdateCommitteeProposal.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.updatecommitteeproposal_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {UpdateCommitteeProposal}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.updatecommitteeproposal_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return UpdateCommitteeProposal.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.updatecommitteeproposal_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.updatecommitteeproposal_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {UpdateCommitteeProposal}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.updatecommitteeproposal_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return UpdateCommitteeProposal.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {GovernanceActionId | undefined}\n    */\n    gov_action_id() {\n        const ret = wasm.updatecommitteeproposal_gov_action_id(this.__wbg_ptr);\n        return ret === 0 ? undefined : GovernanceActionId.__wrap(ret);\n    }\n    /**\n    * @returns {Committee}\n    */\n    committee() {\n        const ret = wasm.updatecommitteeproposal_committee(this.__wbg_ptr);\n        return Committee.__wrap(ret);\n    }\n    /**\n    * @returns {Credentials}\n    */\n    members_to_remove() {\n        const ret = wasm.updatecommitteeproposal_members_to_remove(this.__wbg_ptr);\n        return Credentials.__wrap(ret);\n    }\n    /**\n    * @param {Committee} committee\n    * @param {Credentials} members_to_remove\n    * @returns {UpdateCommitteeProposal}\n    */\n    static new(committee, members_to_remove) {\n        _assertClass(committee, Committee);\n        _assertClass(members_to_remove, Credentials);\n        const ret = wasm.updatecommitteeproposal_new(committee.__wbg_ptr, members_to_remove.__wbg_ptr);\n        return UpdateCommitteeProposal.__wrap(ret);\n    }\n    /**\n    * @param {GovernanceActionId} gov_action_id\n    * @param {Committee} committee\n    * @param {Credentials} members_to_remove\n    * @returns {UpdateCommitteeProposal}\n    */\n    static new_with_action_id(gov_action_id, committee, members_to_remove) {\n        _assertClass(gov_action_id, GovernanceActionId);\n        _assertClass(committee, Committee);\n        _assertClass(members_to_remove, Credentials);\n        const ret = wasm.updatecommitteeproposal_new_with_action_id(gov_action_id.__wbg_ptr, committee.__wbg_ptr, members_to_remove.__wbg_ptr);\n        return UpdateCommitteeProposal.__wrap(ret);\n    }\n}\n/**\n*/\nclass VRFCert {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(VRFCert.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vrfcert_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfcert_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {VRFCert}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.vrfcert_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VRFCert.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfcert_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {VRFCert}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.vrfcert_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VRFCert.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfcert_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfcert_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {VRFCert}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.vrfcert_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VRFCert.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    output() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.kessignature_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    proof() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfcert_proof(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} output\n    * @param {Uint8Array} proof\n    * @returns {VRFCert}\n    */\n    static new(output, proof) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(output, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passArray8ToWasm0(proof, wasm.__wbindgen_malloc);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.vrfcert_new(retptr, ptr0, len0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VRFCert.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass VRFKeyHash {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(VRFKeyHash.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vrfkeyhash_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {VRFKeyHash}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.vrfkeyhash_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VRFKeyHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchordatahash_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.anchordatahash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {VRFKeyHash}\n    */\n    static from_bech32(bech_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.vrfkeyhash_from_bech32(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VRFKeyHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchordatahash_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {VRFKeyHash}\n    */\n    static from_hex(hex) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.vrfkeyhash_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VRFKeyHash.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass VRFVKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(VRFVKey.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vrfvkey_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {VRFVKey}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.vrfvkey_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VRFVKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchordatahash_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.anchordatahash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {VRFVKey}\n    */\n    static from_bech32(bech_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.vrfvkey_from_bech32(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VRFVKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.anchordatahash_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {VRFVKey}\n    */\n    static from_hex(hex) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.vrfvkey_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VRFVKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass Value {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Value.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_value_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.value_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Value}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.value_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Value.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.value_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Value}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.value_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Value.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.value_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.value_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Value}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.value_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Value.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {BigNum} coin\n    * @returns {Value}\n    */\n    static new(coin) {\n        _assertClass(coin, BigNum);\n        const ret = wasm.value_new(coin.__wbg_ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @param {MultiAsset} multiasset\n    * @returns {Value}\n    */\n    static new_from_assets(multiasset) {\n        _assertClass(multiasset, MultiAsset);\n        const ret = wasm.value_new_from_assets(multiasset.__wbg_ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coin\n    * @param {MultiAsset} multiasset\n    * @returns {Value}\n    */\n    static new_with_assets(coin, multiasset) {\n        _assertClass(coin, BigNum);\n        _assertClass(multiasset, MultiAsset);\n        const ret = wasm.value_new_with_assets(coin.__wbg_ptr, multiasset.__wbg_ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @returns {Value}\n    */\n    static zero() {\n        const ret = wasm.value_zero();\n        return Value.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_zero() {\n        const ret = wasm.value_is_zero(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {BigNum}\n    */\n    coin() {\n        const ret = wasm.pointer_cert_index_bignum(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coin\n    */\n    set_coin(coin) {\n        _assertClass(coin, BigNum);\n        wasm.value_set_coin(this.__wbg_ptr, coin.__wbg_ptr);\n    }\n    /**\n    * @returns {MultiAsset | undefined}\n    */\n    multiasset() {\n        const ret = wasm.value_multiasset(this.__wbg_ptr);\n        return ret === 0 ? undefined : MultiAsset.__wrap(ret);\n    }\n    /**\n    * @param {MultiAsset} multiasset\n    */\n    set_multiasset(multiasset) {\n        _assertClass(multiasset, MultiAsset);\n        wasm.value_set_multiasset(this.__wbg_ptr, multiasset.__wbg_ptr);\n    }\n    /**\n    * @param {Value} rhs\n    * @returns {Value}\n    */\n    checked_add(rhs) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(rhs, Value);\n            wasm.value_checked_add(retptr, this.__wbg_ptr, rhs.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Value.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Value} rhs_value\n    * @returns {Value}\n    */\n    checked_sub(rhs_value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(rhs_value, Value);\n            wasm.value_checked_sub(retptr, this.__wbg_ptr, rhs_value.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Value.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Value} rhs_value\n    * @returns {Value}\n    */\n    clamped_sub(rhs_value) {\n        _assertClass(rhs_value, Value);\n        const ret = wasm.value_clamped_sub(this.__wbg_ptr, rhs_value.__wbg_ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * note: values are only partially comparable\n    * @param {Value} rhs_value\n    * @returns {number | undefined}\n    */\n    compare(rhs_value) {\n        _assertClass(rhs_value, Value);\n        const ret = wasm.value_compare(this.__wbg_ptr, rhs_value.__wbg_ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n}\n/**\n*/\nclass Vkey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Vkey.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vkey_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vkey_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Vkey}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.vkey_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Vkey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vkey_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Vkey}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.vkey_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Vkey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vkey_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vkey_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Vkey}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.vkey_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Vkey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {PublicKey} pk\n    * @returns {Vkey}\n    */\n    static new(pk) {\n        _assertClass(pk, PublicKey);\n        const ret = wasm.vkey_new(pk.__wbg_ptr);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @returns {PublicKey}\n    */\n    public_key() {\n        const ret = wasm.vkey_public_key(this.__wbg_ptr);\n        return PublicKey.__wrap(ret);\n    }\n}\n/**\n*/\nclass Vkeys {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Vkeys.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vkeys_free(ptr);\n    }\n    /**\n    * @returns {Vkeys}\n    */\n    static new() {\n        const ret = wasm.publickeys_new();\n        return Vkeys.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.bootstrapwitnesses_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Vkey}\n    */\n    get(index) {\n        const ret = wasm.vkeys_get(this.__wbg_ptr, index);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @param {Vkey} elem\n    */\n    add(elem) {\n        _assertClass(elem, Vkey);\n        wasm.vkeys_add(this.__wbg_ptr, elem.__wbg_ptr);\n    }\n}\n/**\n*/\nclass Vkeywitness {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Vkeywitness.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vkeywitness_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vkeywitness_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Vkeywitness}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.vkeywitness_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Vkeywitness.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vkeywitness_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Vkeywitness}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.vkeywitness_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Vkeywitness.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vkeywitness_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vkeywitness_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Vkeywitness}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.vkeywitness_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Vkeywitness.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Vkey} vkey\n    * @param {Ed25519Signature} signature\n    * @returns {Vkeywitness}\n    */\n    static new(vkey, signature) {\n        _assertClass(vkey, Vkey);\n        _assertClass(signature, Ed25519Signature);\n        const ret = wasm.vkeywitness_new(vkey.__wbg_ptr, signature.__wbg_ptr);\n        return Vkeywitness.__wrap(ret);\n    }\n    /**\n    * @returns {Vkey}\n    */\n    vkey() {\n        const ret = wasm.bootstrapwitness_vkey(this.__wbg_ptr);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519Signature}\n    */\n    signature() {\n        const ret = wasm.bootstrapwitness_signature(this.__wbg_ptr);\n        return Ed25519Signature.__wrap(ret);\n    }\n}\n/**\n*/\nclass Vkeywitnesses {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Vkeywitnesses.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vkeywitnesses_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vkeywitnesses_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Vkeywitnesses}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.vkeywitnesses_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Vkeywitnesses.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vkeywitnesses_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Vkeywitnesses}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.vkeywitnesses_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Vkeywitnesses.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vkeywitnesses_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vkeywitnesses_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Vkeywitnesses}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.vkeywitnesses_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Vkeywitnesses.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Vkeywitnesses}\n    */\n    static new() {\n        const ret = wasm.publickeys_new();\n        return Vkeywitnesses.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.bootstrapwitnesses_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Vkeywitness}\n    */\n    get(index) {\n        const ret = wasm.vkeywitnesses_get(this.__wbg_ptr, index);\n        return Vkeywitness.__wrap(ret);\n    }\n    /**\n    * @param {Vkeywitness} elem\n    */\n    add(elem) {\n        _assertClass(elem, Vkeywitness);\n        wasm.vkeywitnesses_add(this.__wbg_ptr, elem.__wbg_ptr);\n    }\n}\n/**\n*/\nclass VoteDelegation {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(VoteDelegation.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_votedelegation_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.votedelegation_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {VoteDelegation}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.votedelegation_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VoteDelegation.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.votedelegation_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {VoteDelegation}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.votedelegation_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VoteDelegation.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.votedelegation_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.votedelegation_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {VoteDelegation}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.votedelegation_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VoteDelegation.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Credential}\n    */\n    stake_credential() {\n        const ret = wasm.committeehotauth_committee_hot_key(this.__wbg_ptr);\n        return Credential.__wrap(ret);\n    }\n    /**\n    * @returns {DRep}\n    */\n    drep() {\n        const ret = wasm.votedelegation_drep(this.__wbg_ptr);\n        return DRep.__wrap(ret);\n    }\n    /**\n    * @param {Credential} stake_credential\n    * @param {DRep} drep\n    * @returns {VoteDelegation}\n    */\n    static new(stake_credential, drep) {\n        _assertClass(stake_credential, Credential);\n        _assertClass(drep, DRep);\n        const ret = wasm.votedelegation_new(stake_credential.__wbg_ptr, drep.__wbg_ptr);\n        return VoteDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_script_credentials() {\n        const ret = wasm.votedelegation_has_script_credentials(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nclass VoteRegistrationAndDelegation {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(VoteRegistrationAndDelegation.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_voteregistrationanddelegation_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.voteregistrationanddelegation_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {VoteRegistrationAndDelegation}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.voteregistrationanddelegation_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VoteRegistrationAndDelegation.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.voteregistrationanddelegation_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {VoteRegistrationAndDelegation}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.voteregistrationanddelegation_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VoteRegistrationAndDelegation.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.voteregistrationanddelegation_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.voteregistrationanddelegation_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {VoteRegistrationAndDelegation}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.voteregistrationanddelegation_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VoteRegistrationAndDelegation.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Credential}\n    */\n    stake_credential() {\n        const ret = wasm.voteregistrationanddelegation_stake_credential(this.__wbg_ptr);\n        return Credential.__wrap(ret);\n    }\n    /**\n    * @returns {DRep}\n    */\n    drep() {\n        const ret = wasm.voteregistrationanddelegation_drep(this.__wbg_ptr);\n        return DRep.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    coin() {\n        const ret = wasm.drepregistration_coin(this.__wbg_ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {Credential} stake_credential\n    * @param {DRep} drep\n    * @param {BigNum} coin\n    * @returns {VoteRegistrationAndDelegation}\n    */\n    static new(stake_credential, drep, coin) {\n        _assertClass(stake_credential, Credential);\n        _assertClass(drep, DRep);\n        _assertClass(coin, BigNum);\n        const ret = wasm.voteregistrationanddelegation_new(stake_credential.__wbg_ptr, drep.__wbg_ptr, coin.__wbg_ptr);\n        return VoteRegistrationAndDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_script_credentials() {\n        const ret = wasm.voteregistrationanddelegation_has_script_credentials(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nclass Voter {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Voter.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_voter_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.voter_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Voter}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.voter_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Voter.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.voter_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Voter}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.voter_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Voter.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.voter_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.voter_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Voter}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.voter_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Voter.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Credential} cred\n    * @returns {Voter}\n    */\n    static new_constitutional_committee_hot_key(cred) {\n        _assertClass(cred, Credential);\n        const ret = wasm.voter_new_constitutional_committee_hot_key(cred.__wbg_ptr);\n        return Voter.__wrap(ret);\n    }\n    /**\n    * @param {Credential} cred\n    * @returns {Voter}\n    */\n    static new_drep(cred) {\n        _assertClass(cred, Credential);\n        const ret = wasm.voter_new_drep(cred.__wbg_ptr);\n        return Voter.__wrap(ret);\n    }\n    /**\n    * @param {Ed25519KeyHash} key_hash\n    * @returns {Voter}\n    */\n    static new_staking_pool(key_hash) {\n        _assertClass(key_hash, Ed25519KeyHash);\n        const ret = wasm.voter_new_staking_pool(key_hash.__wbg_ptr);\n        return Voter.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        const ret = wasm.voter_kind(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Credential | undefined}\n    */\n    to_constitutional_committee_hot_cred() {\n        const ret = wasm.voter_to_constitutional_committee_hot_cred(this.__wbg_ptr);\n        return ret === 0 ? undefined : Credential.__wrap(ret);\n    }\n    /**\n    * @returns {Credential | undefined}\n    */\n    to_drep_cred() {\n        const ret = wasm.voter_to_drep_cred(this.__wbg_ptr);\n        return ret === 0 ? undefined : Credential.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash | undefined}\n    */\n    to_staking_pool_key_hash() {\n        const ret = wasm.voter_to_staking_pool_key_hash(this.__wbg_ptr);\n        return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_script_credentials() {\n        const ret = wasm.voter_has_script_credentials(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {Ed25519KeyHash | undefined}\n    */\n    to_key_hash() {\n        const ret = wasm.voter_to_key_hash(this.__wbg_ptr);\n        return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);\n    }\n}\n/**\n*/\nclass Voters {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Voters.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_voters_free(ptr);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.voters_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.voters_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Voters}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.voters_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Voters.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Voters}\n    */\n    static new() {\n        const ret = wasm.voters_new();\n        return Voters.__wrap(ret);\n    }\n    /**\n    * @param {Voter} voter\n    */\n    add(voter) {\n        _assertClass(voter, Voter);\n        wasm.voters_add(this.__wbg_ptr, voter.__wbg_ptr);\n    }\n    /**\n    * @param {number} index\n    * @returns {Voter | undefined}\n    */\n    get(index) {\n        const ret = wasm.voters_get(this.__wbg_ptr, index);\n        return ret === 0 ? undefined : Voter.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.certificates_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nclass VotingBuilder {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(VotingBuilder.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_votingbuilder_free(ptr);\n    }\n    /**\n    * @returns {VotingBuilder}\n    */\n    static new() {\n        const ret = wasm.votingbuilder_new();\n        return VotingBuilder.__wrap(ret);\n    }\n    /**\n    * @param {Voter} voter\n    * @param {GovernanceActionId} gov_action_id\n    * @param {VotingProcedure} voting_procedure\n    */\n    add(voter, gov_action_id, voting_procedure) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(voter, Voter);\n            _assertClass(gov_action_id, GovernanceActionId);\n            _assertClass(voting_procedure, VotingProcedure);\n            wasm.votingbuilder_add(retptr, this.__wbg_ptr, voter.__wbg_ptr, gov_action_id.__wbg_ptr, voting_procedure.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Voter} voter\n    * @param {GovernanceActionId} gov_action_id\n    * @param {VotingProcedure} voting_procedure\n    * @param {PlutusWitness} witness\n    */\n    add_with_plutus_witness(voter, gov_action_id, voting_procedure, witness) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(voter, Voter);\n            _assertClass(gov_action_id, GovernanceActionId);\n            _assertClass(voting_procedure, VotingProcedure);\n            _assertClass(witness, PlutusWitness);\n            wasm.votingbuilder_add_with_plutus_witness(retptr, this.__wbg_ptr, voter.__wbg_ptr, gov_action_id.__wbg_ptr, voting_procedure.__wbg_ptr, witness.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Voter} voter\n    * @param {GovernanceActionId} gov_action_id\n    * @param {VotingProcedure} voting_procedure\n    * @param {NativeScriptSource} native_script_source\n    */\n    add_with_native_script(voter, gov_action_id, voting_procedure, native_script_source) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(voter, Voter);\n            _assertClass(gov_action_id, GovernanceActionId);\n            _assertClass(voting_procedure, VotingProcedure);\n            _assertClass(native_script_source, NativeScriptSource);\n            wasm.votingbuilder_add_with_native_script(retptr, this.__wbg_ptr, voter.__wbg_ptr, gov_action_id.__wbg_ptr, voting_procedure.__wbg_ptr, native_script_source.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {PlutusWitnesses}\n    */\n    get_plutus_witnesses() {\n        const ret = wasm.votingbuilder_get_plutus_witnesses(this.__wbg_ptr);\n        return PlutusWitnesses.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInputs}\n    */\n    get_ref_inputs() {\n        const ret = wasm.votingbuilder_get_ref_inputs(this.__wbg_ptr);\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    get_native_scripts() {\n        const ret = wasm.votingbuilder_get_native_scripts(this.__wbg_ptr);\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_plutus_scripts() {\n        const ret = wasm.votingbuilder_has_plutus_scripts(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {VotingProcedures}\n    */\n    build() {\n        const ret = wasm.votingbuilder_build(this.__wbg_ptr);\n        return VotingProcedures.__wrap(ret);\n    }\n}\n/**\n*/\nclass VotingProcedure {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(VotingProcedure.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_votingprocedure_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.votingprocedure_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {VotingProcedure}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.votingprocedure_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VotingProcedure.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.votingprocedure_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {VotingProcedure}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.votingprocedure_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VotingProcedure.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.votingprocedure_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.votingprocedure_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {VotingProcedure}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.votingprocedure_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VotingProcedure.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} vote\n    * @returns {VotingProcedure}\n    */\n    static new(vote) {\n        const ret = wasm.votingprocedure_new(vote);\n        return VotingProcedure.__wrap(ret);\n    }\n    /**\n    * @param {number} vote\n    * @param {Anchor} anchor\n    * @returns {VotingProcedure}\n    */\n    static new_with_anchor(vote, anchor) {\n        _assertClass(anchor, Anchor);\n        const ret = wasm.votingprocedure_new_with_anchor(vote, anchor.__wbg_ptr);\n        return VotingProcedure.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    vote_kind() {\n        const ret = wasm.votingprocedure_vote_kind(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Anchor | undefined}\n    */\n    anchor() {\n        const ret = wasm.votingprocedure_anchor(this.__wbg_ptr);\n        return ret === 0 ? undefined : Anchor.__wrap(ret);\n    }\n}\n/**\n*/\nclass VotingProcedures {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(VotingProcedures.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_votingprocedures_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.votingprocedures_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {VotingProcedures}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.votingprocedures_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VotingProcedures.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.votingprocedures_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {VotingProcedures}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.votingprocedures_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VotingProcedures.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.votingprocedures_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.votingprocedures_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {VotingProcedures}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.votingprocedures_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VotingProcedures.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {VotingProcedures}\n    */\n    static new() {\n        const ret = wasm.mintbuilder_new();\n        return VotingProcedures.__wrap(ret);\n    }\n    /**\n    * @param {Voter} voter\n    * @param {GovernanceActionId} governance_action_id\n    * @param {VotingProcedure} voting_procedure\n    */\n    insert(voter, governance_action_id, voting_procedure) {\n        _assertClass(voter, Voter);\n        _assertClass(governance_action_id, GovernanceActionId);\n        _assertClass(voting_procedure, VotingProcedure);\n        wasm.votingprocedures_insert(this.__wbg_ptr, voter.__wbg_ptr, governance_action_id.__wbg_ptr, voting_procedure.__wbg_ptr);\n    }\n    /**\n    * @param {Voter} voter\n    * @param {GovernanceActionId} governance_action_id\n    * @returns {VotingProcedure | undefined}\n    */\n    get(voter, governance_action_id) {\n        _assertClass(voter, Voter);\n        _assertClass(governance_action_id, GovernanceActionId);\n        const ret = wasm.votingprocedures_get(this.__wbg_ptr, voter.__wbg_ptr, governance_action_id.__wbg_ptr);\n        return ret === 0 ? undefined : VotingProcedure.__wrap(ret);\n    }\n    /**\n    * @returns {Voters}\n    */\n    get_voters() {\n        const ret = wasm.votingprocedures_get_voters(this.__wbg_ptr);\n        return Voters.__wrap(ret);\n    }\n    /**\n    * @param {Voter} voter\n    * @returns {GovernanceActionIds}\n    */\n    get_governance_action_ids_by_voter(voter) {\n        _assertClass(voter, Voter);\n        const ret = wasm.votingprocedures_get_governance_action_ids_by_voter(this.__wbg_ptr, voter.__wbg_ptr);\n        return GovernanceActionIds.__wrap(ret);\n    }\n}\n/**\n*/\nclass VotingProposal {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(VotingProposal.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_votingproposal_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.votingproposal_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {VotingProposal}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.votingproposal_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VotingProposal.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.votingproposal_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {VotingProposal}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.votingproposal_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VotingProposal.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.votingproposal_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.votingproposal_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {VotingProposal}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.votingproposal_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VotingProposal.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {ParameterChangeProposal} parameter_change_proposal\n    * @returns {VotingProposal}\n    */\n    static new_parameter_change_proposal(parameter_change_proposal) {\n        _assertClass(parameter_change_proposal, ParameterChangeProposal);\n        const ret = wasm.votingproposal_new_parameter_change_proposal(parameter_change_proposal.__wbg_ptr);\n        return VotingProposal.__wrap(ret);\n    }\n    /**\n    * @param {HardForkInitiationProposal} hard_fork_initiation_proposal\n    * @returns {VotingProposal}\n    */\n    static new_hard_fork_initiation_proposal(hard_fork_initiation_proposal) {\n        _assertClass(hard_fork_initiation_proposal, HardForkInitiationProposal);\n        const ret = wasm.votingproposal_new_hard_fork_initiation_proposal(hard_fork_initiation_proposal.__wbg_ptr);\n        return VotingProposal.__wrap(ret);\n    }\n    /**\n    * @param {TreasuryWithdrawalsProposal} treasury_withdrawals_proposal\n    * @returns {VotingProposal}\n    */\n    static new_treasury_withdrawals_proposal(treasury_withdrawals_proposal) {\n        _assertClass(treasury_withdrawals_proposal, TreasuryWithdrawalsProposal);\n        const ret = wasm.votingproposal_new_treasury_withdrawals_proposal(treasury_withdrawals_proposal.__wbg_ptr);\n        return VotingProposal.__wrap(ret);\n    }\n    /**\n    * @param {NoConfidenceProposal} no_confidence_proposal\n    * @returns {VotingProposal}\n    */\n    static new_no_confidence_proposal(no_confidence_proposal) {\n        _assertClass(no_confidence_proposal, NoConfidenceProposal);\n        const ret = wasm.votingproposal_new_no_confidence_proposal(no_confidence_proposal.__wbg_ptr);\n        return VotingProposal.__wrap(ret);\n    }\n    /**\n    * @param {UpdateCommitteeProposal} new_committee_proposal\n    * @returns {VotingProposal}\n    */\n    static new_new_committee_proposal(new_committee_proposal) {\n        _assertClass(new_committee_proposal, UpdateCommitteeProposal);\n        const ret = wasm.votingproposal_new_new_committee_proposal(new_committee_proposal.__wbg_ptr);\n        return VotingProposal.__wrap(ret);\n    }\n    /**\n    * @param {NewConstitutionProposal} new_constitution_proposal\n    * @returns {VotingProposal}\n    */\n    static new_new_constitution_proposal(new_constitution_proposal) {\n        _assertClass(new_constitution_proposal, NewConstitutionProposal);\n        const ret = wasm.votingproposal_new_new_constitution_proposal(new_constitution_proposal.__wbg_ptr);\n        return VotingProposal.__wrap(ret);\n    }\n    /**\n    * @param {InfoProposal} info_proposal\n    * @returns {VotingProposal}\n    */\n    static new_info_proposal(info_proposal) {\n        _assertClass(info_proposal, InfoProposal);\n        const ret = wasm.votingproposal_new_info_proposal(info_proposal.__wbg_ptr);\n        return VotingProposal.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        const ret = wasm.votingproposal_kind(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {ParameterChangeProposal | undefined}\n    */\n    as_parameter_change_proposal() {\n        const ret = wasm.votingproposal_as_parameter_change_proposal(this.__wbg_ptr);\n        return ret === 0 ? undefined : ParameterChangeProposal.__wrap(ret);\n    }\n    /**\n    * @returns {HardForkInitiationProposal | undefined}\n    */\n    as_hard_fork_initiation_proposal() {\n        const ret = wasm.votingproposal_as_hard_fork_initiation_proposal(this.__wbg_ptr);\n        return ret === 0 ? undefined : HardForkInitiationProposal.__wrap(ret);\n    }\n    /**\n    * @returns {TreasuryWithdrawalsProposal | undefined}\n    */\n    as_treasury_withdrawals_proposal() {\n        const ret = wasm.votingproposal_as_treasury_withdrawals_proposal(this.__wbg_ptr);\n        return ret === 0 ? undefined : TreasuryWithdrawalsProposal.__wrap(ret);\n    }\n    /**\n    * @returns {NoConfidenceProposal | undefined}\n    */\n    as_no_confidence_proposal() {\n        const ret = wasm.votingproposal_as_no_confidence_proposal(this.__wbg_ptr);\n        return ret === 0 ? undefined : NoConfidenceProposal.__wrap(ret);\n    }\n    /**\n    * @returns {UpdateCommitteeProposal | undefined}\n    */\n    as_new_committee_proposal() {\n        const ret = wasm.votingproposal_as_new_committee_proposal(this.__wbg_ptr);\n        return ret === 0 ? undefined : UpdateCommitteeProposal.__wrap(ret);\n    }\n    /**\n    * @returns {NewConstitutionProposal | undefined}\n    */\n    as_new_constitution_proposal() {\n        const ret = wasm.votingproposal_as_new_constitution_proposal(this.__wbg_ptr);\n        return ret === 0 ? undefined : NewConstitutionProposal.__wrap(ret);\n    }\n    /**\n    * @returns {InfoProposal | undefined}\n    */\n    as_info_proposal() {\n        const ret = wasm.votingproposal_as_info_proposal(this.__wbg_ptr);\n        return ret === 0 ? undefined : InfoProposal.__wrap(ret);\n    }\n}\n/**\n*/\nclass VotingProposalBuilder {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(VotingProposalBuilder.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_votingproposalbuilder_free(ptr);\n    }\n    /**\n    * @returns {VotingProposalBuilder}\n    */\n    static new() {\n        const ret = wasm.votingproposalbuilder_new();\n        return VotingProposalBuilder.__wrap(ret);\n    }\n    /**\n    * @param {VotingProposal} proposal\n    */\n    add(proposal) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(proposal, VotingProposal);\n            wasm.votingproposalbuilder_add(retptr, this.__wbg_ptr, proposal.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {VotingProposal} proposal\n    * @param {PlutusWitness} witness\n    */\n    add_with_plutus_witness(proposal, witness) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(proposal, VotingProposal);\n            _assertClass(witness, PlutusWitness);\n            wasm.votingproposalbuilder_add_with_plutus_witness(retptr, this.__wbg_ptr, proposal.__wbg_ptr, witness.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {PlutusWitnesses}\n    */\n    get_plutus_witnesses() {\n        const ret = wasm.votingproposalbuilder_get_plutus_witnesses(this.__wbg_ptr);\n        return PlutusWitnesses.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInputs}\n    */\n    get_ref_inputs() {\n        const ret = wasm.votingproposalbuilder_get_ref_inputs(this.__wbg_ptr);\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_plutus_scripts() {\n        const ret = wasm.votingproposalbuilder_has_plutus_scripts(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {VotingProposals}\n    */\n    build() {\n        const ret = wasm.votingproposalbuilder_build(this.__wbg_ptr);\n        return VotingProposals.__wrap(ret);\n    }\n}\n/**\n*/\nclass VotingProposals {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(VotingProposals.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_votingproposals_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.votingproposals_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {VotingProposals}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.votingproposals_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VotingProposals.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.votingproposals_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {VotingProposals}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.votingproposals_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VotingProposals.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.votingproposals_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.votingproposals_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {VotingProposals}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.votingproposals_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VotingProposals.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {VotingProposals}\n    */\n    static new() {\n        const ret = wasm.certificates_new();\n        return VotingProposals.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.certificates_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {VotingProposal}\n    */\n    get(index) {\n        const ret = wasm.votingproposals_get(this.__wbg_ptr, index);\n        return VotingProposal.__wrap(ret);\n    }\n    /**\n    * @param {VotingProposal} proposal\n    */\n    add(proposal) {\n        _assertClass(proposal, VotingProposal);\n        wasm.votingproposals_add(this.__wbg_ptr, proposal.__wbg_ptr);\n    }\n}\n/**\n*/\nclass Withdrawals {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Withdrawals.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_withdrawals_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.withdrawals_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Withdrawals}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.withdrawals_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Withdrawals.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.withdrawals_to_hex(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Withdrawals}\n    */\n    static from_hex(hex_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.withdrawals_from_hex(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Withdrawals.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.withdrawals_to_json(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.withdrawals_to_js_value(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} json\n    * @returns {Withdrawals}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.withdrawals_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Withdrawals.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Withdrawals}\n    */\n    static new() {\n        const ret = wasm.auxiliarydataset_new();\n        return Withdrawals.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.auxiliarydataset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {RewardAddress} key\n    * @param {BigNum} value\n    * @returns {BigNum | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, RewardAddress);\n        _assertClass(value, BigNum);\n        const ret = wasm.withdrawals_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {RewardAddress} key\n    * @returns {BigNum | undefined}\n    */\n    get(key) {\n        _assertClass(key, RewardAddress);\n        const ret = wasm.withdrawals_get(this.__wbg_ptr, key.__wbg_ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {RewardAddresses}\n    */\n    keys() {\n        const ret = wasm.withdrawals_keys(this.__wbg_ptr);\n        return RewardAddresses.__wrap(ret);\n    }\n}\n/**\n*/\nclass WithdrawalsBuilder {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(WithdrawalsBuilder.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_withdrawalsbuilder_free(ptr);\n    }\n    /**\n    * @returns {WithdrawalsBuilder}\n    */\n    static new() {\n        const ret = wasm.withdrawalsbuilder_new();\n        return WithdrawalsBuilder.__wrap(ret);\n    }\n    /**\n    * @param {RewardAddress} address\n    * @param {BigNum} coin\n    */\n    add(address, coin) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(address, RewardAddress);\n            _assertClass(coin, BigNum);\n            wasm.withdrawalsbuilder_add(retptr, this.__wbg_ptr, address.__wbg_ptr, coin.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {RewardAddress} address\n    * @param {BigNum} coin\n    * @param {PlutusWitness} witness\n    */\n    add_with_plutus_witness(address, coin, witness) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(address, RewardAddress);\n            _assertClass(coin, BigNum);\n            _assertClass(witness, PlutusWitness);\n            wasm.withdrawalsbuilder_add_with_plutus_witness(retptr, this.__wbg_ptr, address.__wbg_ptr, coin.__wbg_ptr, witness.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {RewardAddress} address\n    * @param {BigNum} coin\n    * @param {NativeScriptSource} native_script_source\n    */\n    add_with_native_script(address, coin, native_script_source) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(address, RewardAddress);\n            _assertClass(coin, BigNum);\n            _assertClass(native_script_source, NativeScriptSource);\n            wasm.withdrawalsbuilder_add_with_native_script(retptr, this.__wbg_ptr, address.__wbg_ptr, coin.__wbg_ptr, native_script_source.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {PlutusWitnesses}\n    */\n    get_plutus_witnesses() {\n        const ret = wasm.withdrawalsbuilder_get_plutus_witnesses(this.__wbg_ptr);\n        return PlutusWitnesses.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInputs}\n    */\n    get_ref_inputs() {\n        const ret = wasm.withdrawalsbuilder_get_ref_inputs(this.__wbg_ptr);\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    get_native_scripts() {\n        const ret = wasm.withdrawalsbuilder_get_native_scripts(this.__wbg_ptr);\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @returns {Value}\n    */\n    get_total_withdrawals() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.withdrawalsbuilder_get_total_withdrawals(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Value.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_plutus_scripts() {\n        const ret = wasm.withdrawalsbuilder_has_plutus_scripts(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {Withdrawals}\n    */\n    build() {\n        const ret = wasm.withdrawalsbuilder_build(this.__wbg_ptr);\n        return Withdrawals.__wrap(ret);\n    }\n}\n\nfunction __wbindgen_string_new(arg0, arg1) {\n    const ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nfunction __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nfunction __wbindgen_string_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    const ret = typeof(obj) === 'string' ? obj : undefined;\n    var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len1 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len1;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n};\n\nfunction __wbindgen_error_new(arg0, arg1) {\n    const ret = new Error(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nfunction __wbindgen_number_new(arg0) {\n    const ret = arg0;\n    return addHeapObject(ret);\n};\n\nfunction __wbindgen_object_clone_ref(arg0) {\n    const ret = getObject(arg0);\n    return addHeapObject(ret);\n};\n\nfunction __wbindgen_is_object(arg0) {\n    const val = getObject(arg0);\n    const ret = typeof(val) === 'object' && val !== null;\n    return ret;\n};\n\nfunction __wbg_set_20cbc34131e76824(arg0, arg1, arg2) {\n    getObject(arg0)[takeObject(arg1)] = takeObject(arg2);\n};\n\nfunction __wbg_String_91fba7ded13ba54c(arg0, arg1) {\n    const ret = String(getObject(arg1));\n    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len1;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n};\n\nfunction __wbg_randomFillSync_dc1e9a60c158336d() { return handleError(function (arg0, arg1) {\n    getObject(arg0).randomFillSync(takeObject(arg1));\n}, arguments) };\n\nfunction __wbg_getRandomValues_37fa2ca9e4e07fab() { return handleError(function (arg0, arg1) {\n    getObject(arg0).getRandomValues(getObject(arg1));\n}, arguments) };\n\nfunction __wbg_crypto_c48a774b022d20ac(arg0) {\n    const ret = getObject(arg0).crypto;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_process_298734cf255a885d(arg0) {\n    const ret = getObject(arg0).process;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_versions_e2e78e134e3e5d01(arg0) {\n    const ret = getObject(arg0).versions;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_node_1cd7a5d853dbea79(arg0) {\n    const ret = getObject(arg0).node;\n    return addHeapObject(ret);\n};\n\nfunction __wbindgen_is_string(arg0) {\n    const ret = typeof(getObject(arg0)) === 'string';\n    return ret;\n};\n\nfunction __wbg_require_8f08ceecec0f4fee() { return handleError(function () {\n    const ret = module.require;\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_msCrypto_bcb970640f50a1e8(arg0) {\n    const ret = getObject(arg0).msCrypto;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_new_1d9a920c6bfc44a8() {\n    const ret = new Array();\n    return addHeapObject(ret);\n};\n\nfunction __wbindgen_is_function(arg0) {\n    const ret = typeof(getObject(arg0)) === 'function';\n    return ret;\n};\n\nfunction __wbg_newnoargs_b5b063fc6c2f0376(arg0, arg1) {\n    const ret = new Function(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_new_268f7b7dd3430798() {\n    const ret = new Map();\n    return addHeapObject(ret);\n};\n\nfunction __wbg_call_97ae9d8645dc388b() { return handleError(function (arg0, arg1) {\n    const ret = getObject(arg0).call(getObject(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_new_0b9bfdd97583284e() {\n    const ret = new Object();\n    return addHeapObject(ret);\n};\n\nfunction __wbg_self_6d479506f72c6a71() { return handleError(function () {\n    const ret = self.self;\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_window_f2557cc78490aceb() { return handleError(function () {\n    const ret = window.window;\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_globalThis_7f206bda628d5286() { return handleError(function () {\n    const ret = globalThis.globalThis;\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_global_ba75c50d1cf384f4() { return handleError(function () {\n    const ret = global.global;\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbindgen_is_undefined(arg0) {\n    const ret = getObject(arg0) === undefined;\n    return ret;\n};\n\nfunction __wbg_set_a68214f35c417fa9(arg0, arg1, arg2) {\n    getObject(arg0)[arg1 >>> 0] = takeObject(arg2);\n};\n\nfunction __wbg_call_168da88779e35f61() { return handleError(function (arg0, arg1, arg2) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_set_933729cf5b66ac11(arg0, arg1, arg2) {\n    const ret = getObject(arg0).set(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_buffer_3f3d764d4747d564(arg0) {\n    const ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_newwithbyteoffsetandlength_d9aa266703cb98be(arg0, arg1, arg2) {\n    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nfunction __wbg_new_8c3f0052272a457a(arg0) {\n    const ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_set_83db9690f9353e79(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nfunction __wbg_newwithlength_f5933855e4f48a19(arg0) {\n    const ret = new Uint8Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nfunction __wbg_subarray_58ad4efbb5bcb886(arg0, arg1, arg2) {\n    const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nfunction __wbg_new_d87f272aec784ec0(arg0, arg1) {\n    const ret = new Function(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_call_eae29933372a39be(arg0, arg1) {\n    const ret = getObject(arg0).call(getObject(arg1));\n    return addHeapObject(ret);\n};\n\nfunction __wbindgen_jsval_eq(arg0, arg1) {\n    const ret = getObject(arg0) === getObject(arg1);\n    return ret;\n};\n\nfunction __wbg_self_e0b3266d2d9eba1a(arg0) {\n    const ret = getObject(arg0).self;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_crypto_e95a6e54c5c2e37f(arg0) {\n    const ret = getObject(arg0).crypto;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_getRandomValues_dc67302a7bd1aec5(arg0) {\n    const ret = getObject(arg0).getRandomValues;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_require_0993fe224bf8e202(arg0, arg1) {\n    const ret = __webpack_require__(\"./node_modules/@emurgo/cardano-serialization-lib-browser sync recursive\")(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_randomFillSync_dd2297de5917c74e(arg0, arg1, arg2) {\n    getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n};\n\nfunction __wbg_getRandomValues_02639197c8166a96(arg0, arg1, arg2) {\n    getObject(arg0).getRandomValues(getArrayU8FromWasm0(arg1, arg2));\n};\n\nfunction __wbindgen_debug_string(arg0, arg1) {\n    const ret = debugString(getObject(arg1));\n    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len1;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n};\n\nfunction __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nfunction __wbindgen_memory() {\n    const ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module), __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib_bg.js?");

/***/ }),

/***/ "./node_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib_bg.wasm":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib_bg.wasm ***!
  \**************************************************************************************************/
/*! exports provided: memory, __wbg_plutusscriptsource_free, plutusscriptsource_new, plutusscriptsource_new_ref_input, plutusscriptsource_new_ref_input_with_lang_ver, __wbg_datumsource_free, datumsource_new, datumsource_new_ref_input, __wbg_nativescriptsource_free, nativescriptsource_new, nativescriptsource_new_ref_input, __wbg_plutuswitness_free, plutuswitness_new, plutuswitness_new_with_ref, plutuswitness_new_without_datum, plutuswitness_new_with_ref_without_datum, plutuswitness_script, plutuswitness_datum, plutuswitness_redeemer, __wbg_plutuswitnesses_free, plutuswitnesses_new, plutuswitnesses_get, plutuswitnesses_add, __wbg_committeecoldresign_free, committeecoldresign_to_bytes, committeecoldresign_from_bytes, committeecoldresign_to_hex, committeecoldresign_from_hex, committeecoldresign_to_json, committeecoldresign_to_js_value, committeecoldresign_from_json, committeecoldresign_committee_cold_key, committeecoldresign_new, committeecoldresign_has_script_credentials, __wbg_governanceactionids_free, governanceactionids_to_json, governanceactionids_to_js_value, governanceactionids_from_json, governanceactionids_new, governanceactionids_add, governanceactionids_get, governanceactionids_len, __wbg_treasurywithdrawalsproposal_free, treasurywithdrawalsproposal_to_bytes, treasurywithdrawalsproposal_from_bytes, treasurywithdrawalsproposal_to_hex, treasurywithdrawalsproposal_from_hex, treasurywithdrawalsproposal_to_json, treasurywithdrawalsproposal_to_js_value, treasurywithdrawalsproposal_from_json, treasurywithdrawalsproposal_withdrawals, treasurywithdrawalsproposal_new, __wbg_noconfidenceproposal_free, noconfidenceproposal_to_bytes, noconfidenceproposal_from_bytes, noconfidenceproposal_to_hex, noconfidenceproposal_from_hex, noconfidenceproposal_to_json, noconfidenceproposal_to_js_value, noconfidenceproposal_from_json, noconfidenceproposal_gov_action_id, noconfidenceproposal_new, noconfidenceproposal_new_with_action_id, __wbg_committee_free, committee_to_bytes, committee_from_bytes, committee_to_hex, committee_from_hex, committee_to_json, committee_to_js_value, committee_from_json, committee_new, committee_members_keys, committee_quorum_threshold, committee_add_member, committee_get_member_epoch, plutuswitnesses_len, __wbg_certificatesbuilder_free, certificatesbuilder_add, certificatesbuilder_add_with_plutus_witness, certificatesbuilder_add_with_native_script, certificatesbuilder_get_plutus_witnesses, certificatesbuilder_get_ref_inputs, certificatesbuilder_get_native_scripts, certificatesbuilder_get_certificates_refund, certificatesbuilder_get_certificates_deposit, certificatesbuilder_has_plutus_scripts, certificatesbuilder_build, __wbg_mintwitness_free, mintwitness_new_native_script, mintwitness_new_plutus_script, __wbg_mintbuilder_free, mintbuilder_new, mintbuilder_add_asset, mintbuilder_set_asset, mintbuilder_build, mintbuilder_get_native_scripts, mintbuilder_get_plutus_witnesses, mintbuilder_get_ref_inputs, mintbuilder_get_redeeemers, mintbuilder_has_plutus_scripts, mintbuilder_has_native_scripts, __wbg_transactionbatchlist_free, transactionbatchlist_get, __wbg_transactionbatch_free, transactionbatch_get, create_send_all, __wbg_linearfee_free, linearfee_constant, linearfee_coefficient, linearfee_new, min_fee, calculate_ex_units_ceil_cost, min_script_fee, __wbg_certificates_free, certificates_to_bytes, certificates_from_bytes, certificates_to_hex, certificates_from_hex, certificates_to_json, certificates_to_js_value, certificates_from_json, certificates_new, certificates_len, certificates_get, certificates_add, __wbg_voter_free, voter_to_bytes, voter_from_bytes, voter_to_hex, voter_from_hex, voter_to_json, voter_to_js_value, voter_from_json, voter_new_constitutional_committee_hot_key, voter_new_drep, voter_new_staking_pool, voter_kind, voter_to_constitutional_committee_hot_cred, voter_to_drep_cred, voter_to_staking_pool_key_hash, voter_has_script_credentials, voter_to_key_hash, __wbg_voters_free, voters_to_json, voters_to_js_value, voters_from_json, voters_new, voters_add, voters_get, __wbg_votingprocedures_free, votingprocedures_to_bytes, votingprocedures_from_bytes, votingprocedures_to_hex, votingprocedures_from_hex, votingprocedures_to_json, votingprocedures_to_js_value, votingprocedures_from_json, votingprocedures_insert, votingprocedures_get, votingprocedures_get_voters, votingprocedures_get_governance_action_ids_by_voter, __wbg_infoproposal_free, infoproposal_new, __wbg_votingproposals_free, votingproposals_to_bytes, votingproposals_from_bytes, votingproposals_to_hex, votingproposals_from_hex, votingproposals_to_json, votingproposals_to_js_value, votingproposals_from_json, votingproposals_get, votingproposals_add, transactionbatchlist_len, transactionbatch_len, voters_len, votingproposals_len, certificatesbuilder_new, votingprocedures_new, votingproposals_new, __wbg_networkinfo_free, networkinfo_new, networkinfo_network_id, networkinfo_protocol_magic, networkinfo_testnet_preview, networkinfo_testnet_preprod, networkinfo_testnet, networkinfo_mainnet, __wbg_credential_free, credential_from_keyhash, credential_from_scripthash, credential_to_keyhash, credential_to_scripthash, credential_has_script_hash, credential_to_bytes, credential_from_bytes, credential_to_hex, credential_from_hex, credential_to_json, credential_to_js_value, credential_from_json, __wbg_byronaddress_free, byronaddress_to_base58, byronaddress_to_bytes, byronaddress_from_bytes, byronaddress_byron_protocol_magic, byronaddress_attributes, byronaddress_network_id, byronaddress_from_base58, byronaddress_icarus_from_key, byronaddress_is_valid, byronaddress_to_address, byronaddress_from_address, __wbg_address_free, address_from_bytes, address_to_json, address_to_js_value, address_from_json, address_to_hex, address_from_hex, address_to_bytes, address_to_bech32, address_from_bech32, address_network_id, __wbg_baseaddress_free, baseaddress_new, baseaddress_payment_cred, baseaddress_stake_cred, baseaddress_to_address, baseaddress_from_address, __wbg_enterpriseaddress_free, enterpriseaddress_new, enterpriseaddress_to_address, enterpriseaddress_from_address, rewardaddress_to_address, rewardaddress_from_address, __wbg_pointer_free, pointer_new, pointer_new_pointer, pointer_slot, pointer_tx_index, pointer_cert_index, pointer_slot_bignum, pointer_tx_index_bignum, pointer_cert_index_bignum, __wbg_pointeraddress_free, pointeraddress_new, pointeraddress_payment_cred, pointeraddress_stake_pointer, pointeraddress_to_address, pointeraddress_from_address, __wbg_inputwithscriptwitness_free, inputwithscriptwitness_new_with_native_script_witness, inputwithscriptwitness_new_with_plutus_witness, inputwithscriptwitness_input, __wbg_inputswithscriptwitness_free, inputswithscriptwitness_new, inputswithscriptwitness_add, inputswithscriptwitness_get, inputswithscriptwitness_len, __wbg_txinputsbuilder_free, txinputsbuilder_new, txinputsbuilder_add_key_input, txinputsbuilder_add_script_input, txinputsbuilder_add_native_script_input, txinputsbuilder_add_plutus_script_input, txinputsbuilder_add_bootstrap_input, txinputsbuilder_add_input, txinputsbuilder_count_missing_input_scripts, txinputsbuilder_add_required_native_input_scripts, txinputsbuilder_add_required_plutus_input_scripts, txinputsbuilder_add_required_script_input_witnesses, txinputsbuilder_get_ref_inputs, txinputsbuilder_get_native_input_scripts, txinputsbuilder_get_plutus_input_scripts, txinputsbuilder_len, txinputsbuilder_add_required_signer, txinputsbuilder_add_required_signers, txinputsbuilder_total_value, txinputsbuilder_inputs, txinputsbuilder_inputs_option, __wbg_votingproposalbuilder_free, votingproposalbuilder_new, votingproposalbuilder_add, votingproposalbuilder_add_with_plutus_witness, votingproposalbuilder_get_plutus_witnesses, votingproposalbuilder_get_ref_inputs, votingproposalbuilder_has_plutus_scripts, votingproposalbuilder_build, encrypt_with_password, decrypt_with_password, __wbg_fixedtransaction_free, fixedtransaction_to_bytes, fixedtransaction_from_bytes, fixedtransaction_to_hex, fixedtransaction_from_hex, fixedtransaction_new, fixedtransaction_new_with_auxiliary, fixedtransaction_body, fixedtransaction_raw_body, fixedtransaction_set_body, fixedtransaction_set_witness_set, fixedtransaction_witness_set, fixedtransaction_raw_witness_set, fixedtransaction_set_is_valid, fixedtransaction_is_valid, fixedtransaction_set_auxiliary_data, fixedtransaction_auxiliary_data, fixedtransaction_raw_auxiliary_data, __wbg_stakevoteregistrationanddelegation_free, stakevoteregistrationanddelegation_to_bytes, stakevoteregistrationanddelegation_from_bytes, stakevoteregistrationanddelegation_to_hex, stakevoteregistrationanddelegation_from_hex, stakevoteregistrationanddelegation_to_json, stakevoteregistrationanddelegation_to_js_value, stakevoteregistrationanddelegation_from_json, stakevoteregistrationanddelegation_stake_credential, stakevoteregistrationanddelegation_pool_keyhash, stakevoteregistrationanddelegation_drep, stakevoteregistrationanddelegation_new, stakevoteregistrationanddelegation_has_script_credentials, drep_to_bytes, drep_from_bytes, drep_to_hex, drep_from_hex, drep_to_json, drep_to_js_value, drep_from_json, drep_new_always_abstain, drep_new_always_no_confidence, drep_kind, drep_to_key_hash, drep_to_script_hash, __wbg_updatecommitteeproposal_free, updatecommitteeproposal_to_bytes, updatecommitteeproposal_from_bytes, updatecommitteeproposal_to_hex, updatecommitteeproposal_from_hex, updatecommitteeproposal_to_json, updatecommitteeproposal_to_js_value, updatecommitteeproposal_from_json, updatecommitteeproposal_gov_action_id, updatecommitteeproposal_committee, updatecommitteeproposal_members_to_remove, updatecommitteeproposal_new, updatecommitteeproposal_new_with_action_id, __wbg_poolvotingthresholds_free, poolvotingthresholds_to_bytes, poolvotingthresholds_from_bytes, poolvotingthresholds_to_hex, poolvotingthresholds_from_hex, poolvotingthresholds_to_json, poolvotingthresholds_to_js_value, poolvotingthresholds_from_json, poolvotingthresholds_new, __wbg_drepvotingthresholds_free, drepvotingthresholds_to_bytes, drepvotingthresholds_from_bytes, drepvotingthresholds_to_hex, drepvotingthresholds_from_hex, drepvotingthresholds_to_json, drepvotingthresholds_to_js_value, drepvotingthresholds_from_json, drepvotingthresholds_new, drepvotingthresholds_new_default, drepvotingthresholds_set_motion_no_confidence, drepvotingthresholds_set_committee_normal, drepvotingthresholds_set_committee_no_confidence, drepvotingthresholds_set_update_constitution, drepvotingthresholds_set_hard_fork_initiation, drepvotingthresholds_set_pp_network_group, drepvotingthresholds_set_pp_economic_group, drepvotingthresholds_set_pp_technical_group, drepvotingthresholds_set_pp_governance_group, drepvotingthresholds_set_treasury_withdrawal, drepvotingthresholds_motion_no_confidence, drepvotingthresholds_committee_normal, drepvotingthresholds_committee_no_confidence, drepvotingthresholds_update_constitution, drepvotingthresholds_hard_fork_initiation, drepvotingthresholds_pp_network_group, drepvotingthresholds_pp_economic_group, drepvotingthresholds_pp_technical_group, drepvotingthresholds_pp_governance_group, drepvotingthresholds_treasury_withdrawal, __wbg_protocolparamupdate_free, protocolparamupdate_to_bytes, protocolparamupdate_from_bytes, protocolparamupdate_to_hex, protocolparamupdate_from_hex, protocolparamupdate_to_json, protocolparamupdate_to_js_value, protocolparamupdate_from_json, protocolparamupdate_set_minfee_a, protocolparamupdate_minfee_a, protocolparamupdate_set_minfee_b, protocolparamupdate_minfee_b, protocolparamupdate_set_max_block_body_size, protocolparamupdate_max_block_body_size, protocolparamupdate_set_max_tx_size, protocolparamupdate_max_tx_size, protocolparamupdate_set_max_block_header_size, protocolparamupdate_max_block_header_size, protocolparamupdate_set_key_deposit, protocolparamupdate_key_deposit, protocolparamupdate_set_pool_deposit, protocolparamupdate_pool_deposit, protocolparamupdate_set_max_epoch, protocolparamupdate_max_epoch, protocolparamupdate_set_n_opt, protocolparamupdate_n_opt, protocolparamupdate_set_pool_pledge_influence, protocolparamupdate_pool_pledge_influence, protocolparamupdate_set_expansion_rate, protocolparamupdate_expansion_rate, protocolparamupdate_set_treasury_growth_rate, protocolparamupdate_treasury_growth_rate, protocolparamupdate_d, protocolparamupdate_extra_entropy, protocolparamupdate_set_protocol_version, protocolparamupdate_protocol_version, protocolparamupdate_set_min_pool_cost, protocolparamupdate_min_pool_cost, protocolparamupdate_set_ada_per_utxo_byte, protocolparamupdate_ada_per_utxo_byte, protocolparamupdate_set_cost_models, protocolparamupdate_cost_models, protocolparamupdate_set_execution_costs, protocolparamupdate_execution_costs, protocolparamupdate_set_max_tx_ex_units, protocolparamupdate_max_tx_ex_units, protocolparamupdate_set_max_block_ex_units, protocolparamupdate_max_block_ex_units, protocolparamupdate_set_max_value_size, protocolparamupdate_max_value_size, protocolparamupdate_set_collateral_percentage, protocolparamupdate_collateral_percentage, protocolparamupdate_set_max_collateral_inputs, protocolparamupdate_max_collateral_inputs, protocolparamupdate_set_pool_voting_thresholds, protocolparamupdate_pool_voting_thresholds, protocolparamupdate_set_drep_voting_thresholds, protocolparamupdate_drep_voting_thresholds, protocolparamupdate_set_min_committee_size, protocolparamupdate_min_committee_size, protocolparamupdate_set_committee_term_limit, protocolparamupdate_committee_term_limit, protocolparamupdate_set_governance_action_validity_period, protocolparamupdate_governance_action_validity_period, protocolparamupdate_set_governance_action_deposit, protocolparamupdate_governance_action_deposit, protocolparamupdate_set_drep_deposit, protocolparamupdate_drep_deposit, protocolparamupdate_set_drep_inactivity_period, protocolparamupdate_drep_inactivity_period, protocolparamupdate_new, __wbg_transactionunspentoutput_free, transactionunspentoutput_to_bytes, transactionunspentoutput_from_bytes, transactionunspentoutput_to_hex, transactionunspentoutput_from_hex, transactionunspentoutput_to_json, transactionunspentoutput_to_js_value, transactionunspentoutput_from_json, transactionunspentoutput_new, transactionunspentoutput_input, transactionunspentoutput_output, __wbg_transactionunspentoutputs_free, transactionunspentoutputs_to_json, transactionunspentoutputs_to_js_value, transactionunspentoutputs_from_json, transactionunspentoutputs_get, transactionunspentoutputs_add, __wbg_bignum_free, bignum_to_bytes, bignum_from_bytes, bignum_to_hex, bignum_from_hex, bignum_to_json, bignum_to_js_value, bignum_from_json, bignum_from_str, bignum_to_str, bignum_zero, bignum_one, bignum_is_zero, bignum_div_floor, bignum_checked_mul, bignum_checked_add, bignum_checked_sub, bignum_clamped_sub, bignum_compare, bignum_less_than, bignum_max_value, bignum_max, __wbg_value_free, value_to_bytes, value_from_bytes, value_to_hex, value_from_hex, value_to_json, value_to_js_value, value_from_json, value_new, value_new_from_assets, value_new_with_assets, value_zero, value_is_zero, value_set_coin, value_multiasset, value_set_multiasset, value_checked_add, value_checked_sub, value_clamped_sub, value_compare, __wbg_int_free, int_to_bytes, int_from_bytes, int_to_hex, int_from_hex, int_to_json, int_to_js_value, int_from_json, int_new, int_new_negative, int_new_i32, int_is_positive, int_as_positive, int_as_negative, int_as_i32, int_as_i32_or_fail, int_to_str, int_from_str, __wbg_bigint_free, bigint_to_bytes, bigint_from_bytes, bigint_to_hex, bigint_from_hex, bigint_to_json, bigint_to_js_value, bigint_from_json, bigint_is_zero, bigint_as_u64, bigint_as_int, bigint_from_str, bigint_to_str, bigint_add, bigint_mul, bigint_one, bigint_increment, bigint_div_ceil, make_daedalus_bootstrap_witness, make_icarus_bootstrap_witness, make_vkey_witness, hash_auxiliary_data, hash_transaction, hash_plutus_data, hash_script_data, get_implicit_input, get_deposit, min_ada_for_output, min_ada_required, encode_json_str_to_native_script, int_as_i32_or_nothing, credential_kind, transactionunspentoutputs_len, stakevoteregistrationanddelegation_coin, value_coin, enterpriseaddress_payment_cred, rewardaddress_payment_cred, poolvotingthresholds_motion_no_confidence, poolvotingthresholds_committee_normal, poolvotingthresholds_committee_no_confidence, poolvotingthresholds_hard_fork_initiation, rewardaddress_new, drep_new_script_hash, drep_new_key_hash, transactionunspentoutputs_new, __wbg_rewardaddress_free, __wbg_drep_free, unitinterval_to_bytes, unitinterval_from_bytes, unitinterval_to_hex, unitinterval_from_hex, unitinterval_to_json, unitinterval_to_js_value, unitinterval_from_json, unitinterval_denominator, unitinterval_new, __wbg_transaction_free, transaction_to_bytes, transaction_from_bytes, transaction_to_hex, transaction_from_hex, transaction_to_json, transaction_to_js_value, transaction_from_json, transaction_body, transaction_witness_set, transaction_is_valid, transaction_auxiliary_data, transaction_set_is_valid, transaction_new, __wbg_transactioninputs_free, transactioninputs_to_bytes, transactioninputs_from_bytes, transactioninputs_to_hex, transactioninputs_from_hex, transactioninputs_to_json, transactioninputs_to_js_value, transactioninputs_from_json, transactioninputs_get, transactioninputs_add, transactioninputs_to_option, __wbg_transactionoutputs_free, transactionoutputs_to_bytes, transactionoutputs_from_bytes, transactionoutputs_to_hex, transactionoutputs_from_hex, transactionoutputs_to_json, transactionoutputs_to_js_value, transactionoutputs_from_json, transactionoutputs_get, transactionoutputs_add, __wbg_datacost_free, datacost_new_coins_per_word, datacost_new_coins_per_byte, datacost_coins_per_byte, __wbg_transactioninput_free, transactioninput_to_bytes, transactioninput_from_bytes, transactioninput_to_hex, transactioninput_from_hex, transactioninput_to_json, transactioninput_to_js_value, transactioninput_from_json, transactioninput_transaction_id, transactioninput_index, transactioninput_new, __wbg_transactionoutput_free, transactionoutput_to_bytes, transactionoutput_from_bytes, transactionoutput_to_hex, transactionoutput_from_hex, transactionoutput_to_json, transactionoutput_to_js_value, transactionoutput_from_json, transactionoutput_address, transactionoutput_amount, transactionoutput_data_hash, transactionoutput_plutus_data, transactionoutput_script_ref, transactionoutput_set_script_ref, transactionoutput_set_plutus_data, transactionoutput_set_data_hash, transactionoutput_has_plutus_data, transactionoutput_has_data_hash, transactionoutput_has_script_ref, transactionoutput_new, transactionoutput_serialization_format, __wbg_ed25519keyhashes_free, ed25519keyhashes_to_bytes, ed25519keyhashes_from_bytes, ed25519keyhashes_to_hex, ed25519keyhashes_from_hex, ed25519keyhashes_to_json, ed25519keyhashes_to_js_value, ed25519keyhashes_from_json, ed25519keyhashes_get, ed25519keyhashes_add, ed25519keyhashes_to_option, __wbg_ipv4_free, ipv4_to_bytes, ipv4_from_bytes, ipv4_to_hex, ipv4_from_hex, ipv4_to_json, ipv4_to_js_value, ipv4_from_json, ipv4_new, ipv4_ip, __wbg_ipv6_free, ipv6_to_bytes, ipv6_from_bytes, ipv6_to_hex, ipv6_from_hex, ipv6_to_json, ipv6_to_js_value, ipv6_from_json, ipv6_new, ipv6_ip, url_to_bytes, url_from_bytes, url_to_hex, url_from_hex, url_from_json, url_new, __wbg_dnsrecordaoraaaa_free, dnsrecordaoraaaa_to_bytes, dnsrecordaoraaaa_from_bytes, dnsrecordaoraaaa_to_hex, dnsrecordaoraaaa_from_hex, dnsrecordaoraaaa_to_json, dnsrecordaoraaaa_to_js_value, dnsrecordaoraaaa_from_json, dnsrecordaoraaaa_new, dnsrecordaoraaaa_record, dnsrecordsrv_to_bytes, dnsrecordsrv_from_bytes, dnsrecordsrv_to_hex, dnsrecordsrv_from_hex, dnsrecordsrv_from_json, dnsrecordsrv_new, __wbg_singlehostaddr_free, singlehostaddr_to_bytes, singlehostaddr_from_bytes, singlehostaddr_to_hex, singlehostaddr_from_hex, singlehostaddr_to_json, singlehostaddr_to_js_value, singlehostaddr_from_json, singlehostaddr_port, singlehostaddr_ipv4, singlehostaddr_ipv6, singlehostaddr_new, __wbg_singlehostname_free, singlehostname_to_bytes, singlehostname_from_bytes, singlehostname_to_hex, singlehostname_from_hex, singlehostname_to_json, singlehostname_to_js_value, singlehostname_from_json, singlehostname_port, singlehostname_new, __wbg_multihostname_free, multihostname_to_bytes, multihostname_from_bytes, multihostname_to_hex, multihostname_from_hex, multihostname_to_json, multihostname_to_js_value, multihostname_from_json, multihostname_dns_name, multihostname_new, __wbg_relay_free, relay_to_bytes, relay_from_bytes, relay_to_hex, relay_from_hex, relay_to_json, relay_to_js_value, relay_from_json, relay_new_single_host_addr, relay_new_single_host_name, relay_new_multi_host_name, relay_kind, relay_as_single_host_addr, relay_as_single_host_name, relay_as_multi_host_name, __wbg_poolmetadata_free, poolmetadata_to_bytes, poolmetadata_from_bytes, poolmetadata_to_hex, poolmetadata_from_hex, poolmetadata_to_json, poolmetadata_to_js_value, poolmetadata_from_json, poolmetadata_url, poolmetadata_pool_metadata_hash, poolmetadata_new, __wbg_credentials_free, credentials_to_bytes, credentials_from_bytes, credentials_to_hex, credentials_from_hex, credentials_to_json, credentials_to_js_value, credentials_from_json, credentials_new, credentials_get, credentials_add, __wbg_rewardaddresses_free, rewardaddresses_to_bytes, rewardaddresses_from_bytes, rewardaddresses_to_hex, rewardaddresses_from_hex, rewardaddresses_to_json, rewardaddresses_to_js_value, rewardaddresses_from_json, rewardaddresses_get, rewardaddresses_add, __wbg_withdrawals_free, withdrawals_to_bytes, withdrawals_from_bytes, withdrawals_to_hex, withdrawals_from_hex, withdrawals_to_json, withdrawals_to_js_value, withdrawals_from_json, withdrawals_insert, withdrawals_get, withdrawals_keys, __wbg_transactionwitnessset_free, transactionwitnessset_to_bytes, transactionwitnessset_from_bytes, transactionwitnessset_to_hex, transactionwitnessset_from_hex, transactionwitnessset_to_json, transactionwitnessset_to_js_value, transactionwitnessset_from_json, transactionwitnessset_set_vkeys, transactionwitnessset_vkeys, transactionwitnessset_set_native_scripts, transactionwitnessset_native_scripts, transactionwitnessset_set_bootstraps, transactionwitnessset_bootstraps, transactionwitnessset_set_plutus_scripts, transactionwitnessset_plutus_scripts, transactionwitnessset_set_plutus_data, transactionwitnessset_plutus_data, transactionwitnessset_set_redeemers, transactionwitnessset_redeemers, transactionwitnessset_new, __wbg_scriptpubkey_free, scriptpubkey_to_bytes, scriptpubkey_from_bytes, scriptpubkey_to_hex, scriptpubkey_from_hex, scriptpubkey_to_json, scriptpubkey_to_js_value, scriptpubkey_from_json, scriptpubkey_addr_keyhash, scriptpubkey_new, __wbg_scriptall_free, scriptall_to_bytes, scriptall_from_bytes, scriptall_to_hex, scriptall_from_hex, scriptall_to_json, scriptall_to_js_value, scriptall_from_json, scriptall_native_scripts, scriptall_new, scriptany_to_bytes, scriptany_from_bytes, scriptany_to_hex, scriptany_from_hex, scriptany_to_js_value, scriptany_from_json, __wbg_scriptnofk_free, scriptnofk_to_bytes, scriptnofk_from_bytes, scriptnofk_to_hex, scriptnofk_from_hex, scriptnofk_to_json, scriptnofk_to_js_value, scriptnofk_from_json, scriptnofk_native_scripts, scriptnofk_new, timelockstart_to_bytes, timelockstart_from_bytes, timelockstart_to_hex, timelockstart_from_hex, timelockstart_to_js_value, timelockstart_from_json, __wbg_timelockexpiry_free, timelockexpiry_to_bytes, timelockexpiry_from_bytes, timelockexpiry_to_hex, timelockexpiry_from_hex, timelockexpiry_to_json, timelockexpiry_to_js_value, timelockexpiry_from_json, timelockexpiry_slot, timelockexpiry_slot_bignum, timelockexpiry_new, timelockexpiry_new_timelockexpiry, __wbg_scriptref_free, scriptref_to_bytes, scriptref_from_bytes, scriptref_to_hex, scriptref_from_hex, scriptref_to_json, scriptref_to_js_value, scriptref_from_json, scriptref_new_native_script, scriptref_new_plutus_script, scriptref_is_native_script, scriptref_is_plutus_script, scriptref_native_script, scriptref_plutus_script, __wbg_outputdatum_free, outputdatum_new_data_hash, outputdatum_new_data, outputdatum_data_hash, outputdatum_data, __wbg_nativescript_free, nativescript_to_bytes, nativescript_from_bytes, nativescript_to_hex, nativescript_from_hex, nativescript_to_json, nativescript_to_js_value, nativescript_from_json, nativescript_hash, nativescript_new_script_pubkey, nativescript_new_script_all, nativescript_new_script_any, nativescript_new_script_n_of_k, nativescript_new_timelock_start, nativescript_new_timelock_expiry, nativescript_kind, nativescript_as_script_pubkey, nativescript_as_script_all, nativescript_as_script_any, nativescript_as_script_n_of_k, nativescript_as_timelock_start, nativescript_as_timelock_expiry, nativescript_get_required_signers, __wbg_nativescripts_free, nativescripts_new, nativescripts_get, nativescripts_add, __wbg_update_free, update_to_bytes, update_from_bytes, update_to_hex, update_from_hex, update_to_json, update_to_js_value, update_from_json, update_proposed_protocol_parameter_updates, update_epoch, update_new, __wbg_genesishashes_free, genesishashes_to_bytes, genesishashes_from_bytes, genesishashes_to_hex, genesishashes_from_hex, genesishashes_to_json, genesishashes_to_js_value, genesishashes_from_json, genesishashes_get, genesishashes_add, __wbg_scripthashes_free, scripthashes_to_bytes, scripthashes_from_bytes, scripthashes_to_hex, scripthashes_from_hex, scripthashes_to_json, scripthashes_to_js_value, scripthashes_from_json, scripthashes_get, scripthashes_add, __wbg_proposedprotocolparameterupdates_free, proposedprotocolparameterupdates_to_bytes, proposedprotocolparameterupdates_from_bytes, proposedprotocolparameterupdates_to_hex, proposedprotocolparameterupdates_from_hex, proposedprotocolparameterupdates_to_json, proposedprotocolparameterupdates_to_js_value, proposedprotocolparameterupdates_from_json, proposedprotocolparameterupdates_insert, proposedprotocolparameterupdates_get, proposedprotocolparameterupdates_keys, __wbg_protocolversion_free, protocolversion_to_bytes, protocolversion_from_bytes, protocolversion_to_hex, protocolversion_from_hex, protocolversion_to_json, protocolversion_to_js_value, protocolversion_from_json, protocolversion_major, protocolversion_minor, protocolversion_new, __wbg_transactionbodies_free, transactionbodies_to_bytes, transactionbodies_from_bytes, transactionbodies_to_hex, transactionbodies_from_hex, transactionbodies_to_json, transactionbodies_to_js_value, transactionbodies_from_json, transactionbodies_get, transactionbodies_add, __wbg_transactionwitnesssets_free, transactionwitnesssets_to_bytes, transactionwitnesssets_from_bytes, transactionwitnesssets_to_hex, transactionwitnesssets_from_hex, transactionwitnesssets_to_json, transactionwitnesssets_to_js_value, transactionwitnesssets_from_json, transactionwitnesssets_get, transactionwitnesssets_add, __wbg_auxiliarydataset_free, auxiliarydataset_new, auxiliarydataset_len, auxiliarydataset_insert, auxiliarydataset_get, auxiliarydataset_indices, __wbg_block_free, block_to_bytes, block_from_bytes, block_to_hex, block_from_hex, block_to_json, block_to_js_value, block_from_json, block_header, block_transaction_bodies, block_transaction_witness_sets, block_auxiliary_data_set, block_invalid_transactions, block_new, __wbg_header_free, header_to_bytes, header_from_bytes, header_to_hex, header_from_hex, header_to_json, header_to_js_value, header_from_json, header_header_body, header_body_signature, header_new, __wbg_operationalcert_free, operationalcert_to_bytes, operationalcert_from_bytes, operationalcert_to_hex, operationalcert_from_hex, operationalcert_to_json, operationalcert_to_js_value, operationalcert_from_json, operationalcert_hot_vkey, operationalcert_sequence_number, operationalcert_kes_period, operationalcert_sigma, operationalcert_new, __wbg_headerbody_free, headerbody_to_bytes, headerbody_from_bytes, headerbody_to_hex, headerbody_from_hex, headerbody_to_json, headerbody_to_js_value, headerbody_from_json, headerbody_block_number, headerbody_slot, headerbody_slot_bignum, headerbody_prev_hash, headerbody_issuer_vkey, headerbody_vrf_vkey, headerbody_has_nonce_and_leader_vrf, headerbody_nonce_vrf_or_nothing, headerbody_leader_vrf_or_nothing, headerbody_has_vrf_result, headerbody_vrf_result_or_nothing, headerbody_block_body_size, headerbody_block_body_hash, headerbody_operational_cert, headerbody_protocol_version, headerbody_new, headerbody_new_headerbody, __wbg_assetname_free, assetname_to_bytes, assetname_from_bytes, assetname_to_hex, assetname_from_hex, assetname_to_json, assetname_to_js_value, assetname_from_json, assetname_new, assetname_name, __wbg_assetnames_free, assetnames_to_bytes, assetnames_from_bytes, assetnames_to_hex, assetnames_from_hex, assetnames_to_json, assetnames_to_js_value, assetnames_from_json, assetnames_new, assetnames_len, assetnames_get, assetnames_add, __wbg_assets_free, assets_to_bytes, assets_from_bytes, assets_to_hex, assets_from_hex, assets_to_json, assets_to_js_value, assets_from_json, assets_new, assets_insert, assets_get, assets_keys, __wbg_multiasset_free, multiasset_to_bytes, multiasset_from_bytes, multiasset_to_hex, multiasset_from_hex, multiasset_to_json, multiasset_to_js_value, multiasset_from_json, multiasset_insert, multiasset_get, multiasset_set_asset, multiasset_get_asset, multiasset_keys, multiasset_sub, __wbg_mintsassets_free, __wbg_mintassets_free, mintassets_new_from_entry, mintassets_insert, mintassets_get, mintassets_keys, __wbg_mint_free, mint_to_bytes, mint_from_bytes, mint_to_hex, mint_from_hex, mint_to_json, mint_to_js_value, mint_from_json, mint_new_from_entry, mint_insert, mint_get, mint_get_all, mint_keys, mint_as_positive_multiasset, mint_as_negative_multiasset, __wbg_networkid_free, networkid_to_bytes, networkid_from_bytes, networkid_to_hex, networkid_from_hex, networkid_to_json, networkid_to_js_value, networkid_from_json, networkid_testnet, networkid_mainnet, networkid_kind, __wbg_unitinterval_free, transactionoutputs_len, transactioninputs_len, ed25519keyhashes_len, rewardaddresses_len, nativescripts_len, genesishashes_len, scripthashes_len, withdrawals_len, scriptnofk_n, transactionbodies_len, transactionwitnesssets_len, proposedprotocolparameterupdates_len, credentials_len, assets_len, multiasset_len, mintassets_len, mint_len, scriptany_native_scripts, unitinterval_numerator, timelockstart_slot_bignum, timelockstart_slot, url_url, dnsrecordsrv_record, url_to_js_value, dnsrecordsrv_to_js_value, __wbg_url_free, __wbg_dnsrecordsrv_free, __wbg_scriptany_free, timelockstart_new, __wbg_timelockstart_free, withdrawals_new, proposedprotocolparameterupdates_new, timelockstart_new_timelockstart, transactioninputs_new, singlehostname_dns_name, rewardaddresses_new, scriptany_new, transactionoutputs_new, genesishashes_new, scripthashes_new, transactionbodies_new, transactionwitnesssets_new, ed25519keyhashes_new, multiasset_new, mintassets_new, mint_new, scriptany_to_json, timelockstart_to_json, url_to_json, dnsrecordsrv_to_json, __wbg_transactionoutputbuilder_free, transactionoutputbuilder_new, transactionoutputbuilder_with_address, transactionoutputbuilder_with_data_hash, transactionoutputbuilder_with_plutus_data, transactionoutputbuilder_with_script_ref, transactionoutputbuilder_next, __wbg_transactionoutputamountbuilder_free, transactionoutputamountbuilder_with_value, transactionoutputamountbuilder_with_coin, transactionoutputamountbuilder_with_coin_and_asset, transactionoutputamountbuilder_with_asset_and_min_required_coin, transactionoutputamountbuilder_with_asset_and_min_required_coin_by_utxo_cost, transactionoutputamountbuilder_build, __wbg_stakeregistrationanddelegation_free, stakeregistrationanddelegation_to_bytes, stakeregistrationanddelegation_from_bytes, stakeregistrationanddelegation_to_hex, stakeregistrationanddelegation_from_hex, stakeregistrationanddelegation_to_json, stakeregistrationanddelegation_to_js_value, stakeregistrationanddelegation_from_json, stakeregistrationanddelegation_stake_credential, stakeregistrationanddelegation_pool_keyhash, stakeregistrationanddelegation_new, stakeregistrationanddelegation_has_script_credentials, __wbg_voteregistrationanddelegation_free, voteregistrationanddelegation_to_bytes, voteregistrationanddelegation_from_bytes, voteregistrationanddelegation_to_hex, voteregistrationanddelegation_from_hex, voteregistrationanddelegation_to_json, voteregistrationanddelegation_to_js_value, voteregistrationanddelegation_from_json, voteregistrationanddelegation_stake_credential, voteregistrationanddelegation_drep, voteregistrationanddelegation_new, voteregistrationanddelegation_has_script_credentials, __wbg_drepregistration_free, drepregistration_to_bytes, drepregistration_from_bytes, drepregistration_to_hex, drepregistration_from_hex, drepregistration_to_json, drepregistration_to_js_value, drepregistration_from_json, drepregistration_voting_credential, drepregistration_coin, drepregistration_anchor, drepregistration_new, drepregistration_new_with_anchor, __wbg_votingprocedure_free, votingprocedure_to_bytes, votingprocedure_from_bytes, votingprocedure_to_hex, votingprocedure_from_hex, votingprocedure_to_json, votingprocedure_to_js_value, votingprocedure_from_json, votingprocedure_new, votingprocedure_new_with_anchor, votingprocedure_vote_kind, votingprocedure_anchor, __wbg_treasurywithdrawals_free, treasurywithdrawals_to_json, treasurywithdrawals_to_js_value, treasurywithdrawals_from_json, treasurywithdrawals_new, treasurywithdrawals_get, treasurywithdrawals_insert, treasurywithdrawals_keys, treasurywithdrawals_len, __wbg_transactionbody_free, transactionbody_to_bytes, transactionbody_from_bytes, transactionbody_to_hex, transactionbody_from_hex, transactionbody_to_json, transactionbody_to_js_value, transactionbody_from_json, transactionbody_inputs, transactionbody_outputs, transactionbody_fee, transactionbody_ttl, transactionbody_ttl_bignum, transactionbody_set_ttl, transactionbody_remove_ttl, transactionbody_set_certs, transactionbody_certs, transactionbody_set_withdrawals, transactionbody_withdrawals, transactionbody_set_update, transactionbody_update, transactionbody_set_auxiliary_data_hash, transactionbody_auxiliary_data_hash, transactionbody_set_validity_start_interval, transactionbody_set_validity_start_interval_bignum, transactionbody_validity_start_interval_bignum, transactionbody_validity_start_interval, transactionbody_set_mint, transactionbody_mint, transactionbody_set_reference_inputs, transactionbody_reference_inputs, transactionbody_set_script_data_hash, transactionbody_script_data_hash, transactionbody_set_collateral, transactionbody_collateral, transactionbody_set_required_signers, transactionbody_required_signers, transactionbody_set_network_id, transactionbody_network_id, transactionbody_set_collateral_return, transactionbody_collateral_return, transactionbody_set_total_collateral, transactionbody_total_collateral, transactionbody_set_voting_procedures, transactionbody_voting_procedures, transactionbody_set_voting_proposals, transactionbody_voting_proposals, transactionbody_set_donation, transactionbody_donation, transactionbody_set_current_treasury_value, transactionbody_current_treasury_value, transactionbody_new, transactionbody_new_tx_body, voteregistrationanddelegation_coin, stakeregistrationanddelegation_coin, transactionbody_multiassets, __wbg_bip32privatekey_free, bip32privatekey_derive, bip32privatekey_from_128_xprv, bip32privatekey_to_128_xprv, bip32privatekey_generate_ed25519_bip32, bip32privatekey_to_raw_key, bip32privatekey_to_public, bip32privatekey_from_bytes, bip32privatekey_as_bytes, bip32privatekey_from_bech32, bip32privatekey_to_bech32, bip32privatekey_from_bip39_entropy, bip32privatekey_chaincode, bip32privatekey_to_hex, bip32privatekey_from_hex, __wbg_bip32publickey_free, bip32publickey_derive, bip32publickey_to_raw_key, bip32publickey_from_bytes, bip32publickey_as_bytes, bip32publickey_from_bech32, bip32publickey_to_bech32, bip32publickey_chaincode, bip32publickey_to_hex, bip32publickey_from_hex, __wbg_privatekey_free, privatekey_to_public, privatekey_generate_ed25519, privatekey_generate_ed25519extended, privatekey_from_bech32, privatekey_to_bech32, privatekey_as_bytes, privatekey_from_extended_bytes, privatekey_from_normal_bytes, privatekey_sign, privatekey_to_hex, privatekey_from_hex, __wbg_publickey_free, publickey_from_bech32, publickey_to_bech32, publickey_from_bytes, publickey_verify, publickey_hash, publickey_to_hex, publickey_from_hex, __wbg_vkey_free, vkey_to_bytes, vkey_from_bytes, vkey_to_hex, vkey_from_hex, vkey_to_json, vkey_to_js_value, vkey_from_json, vkey_new, vkey_public_key, __wbg_vkeys_free, vkeys_get, vkeys_add, __wbg_vkeywitness_free, vkeywitness_to_bytes, vkeywitness_from_bytes, vkeywitness_to_hex, vkeywitness_from_hex, vkeywitness_to_json, vkeywitness_to_js_value, vkeywitness_from_json, vkeywitness_new, __wbg_vkeywitnesses_free, vkeywitnesses_to_bytes, vkeywitnesses_from_bytes, vkeywitnesses_to_hex, vkeywitnesses_from_hex, vkeywitnesses_to_json, vkeywitnesses_to_js_value, vkeywitnesses_from_json, vkeywitnesses_get, vkeywitnesses_add, __wbg_bootstrapwitness_free, bootstrapwitness_to_bytes, bootstrapwitness_from_bytes, bootstrapwitness_to_hex, bootstrapwitness_from_hex, bootstrapwitness_to_json, bootstrapwitness_to_js_value, bootstrapwitness_from_json, bootstrapwitness_vkey, bootstrapwitness_signature, bootstrapwitness_chain_code, bootstrapwitness_attributes, bootstrapwitness_new, __wbg_bootstrapwitnesses_free, bootstrapwitnesses_new, bootstrapwitnesses_len, bootstrapwitnesses_get, bootstrapwitnesses_add, __wbg_publickeys_free, publickeys_new, publickeys_get, publickeys_add, __wbg_ed25519signature_free, ed25519signature_to_bytes, ed25519signature_to_bech32, ed25519signature_to_hex, ed25519signature_from_bech32, ed25519signature_from_hex, ed25519signature_from_bytes, __wbg_legacydaedalusprivatekey_free, legacydaedalusprivatekey_from_bytes, legacydaedalusprivatekey_as_bytes, legacydaedalusprivatekey_chaincode, __wbg_ed25519keyhash_free, ed25519keyhash_from_bytes, ed25519keyhash_to_bytes, ed25519keyhash_to_bech32, ed25519keyhash_from_bech32, ed25519keyhash_to_hex, ed25519keyhash_from_hex, scripthash_from_bytes, scripthash_from_bech32, scripthash_from_hex, __wbg_anchordatahash_free, anchordatahash_from_bytes, anchordatahash_to_bytes, anchordatahash_to_bech32, anchordatahash_from_bech32, anchordatahash_to_hex, anchordatahash_from_hex, transactionhash_from_bytes, transactionhash_from_bech32, transactionhash_from_hex, genesisdelegatehash_from_bytes, genesisdelegatehash_from_bech32, genesisdelegatehash_from_hex, genesishash_from_bytes, genesishash_from_bech32, genesishash_from_hex, auxiliarydatahash_from_bytes, auxiliarydatahash_from_bech32, auxiliarydatahash_from_hex, poolmetadatahash_from_bytes, poolmetadatahash_from_bech32, poolmetadatahash_from_hex, vrfkeyhash_from_bytes, vrfkeyhash_from_bech32, vrfkeyhash_from_hex, blockhash_from_bytes, blockhash_from_bech32, blockhash_from_hex, datahash_from_bytes, datahash_from_bech32, datahash_from_hex, scriptdatahash_from_bytes, scriptdatahash_from_bech32, scriptdatahash_from_hex, vrfvkey_from_bytes, vrfvkey_from_bech32, vrfvkey_from_hex, kesvkey_from_bytes, kesvkey_from_bech32, kesvkey_from_hex, __wbg_kessignature_free, kessignature_to_bytes, kessignature_from_bytes, __wbg_nonce_free, nonce_to_bytes, nonce_from_bytes, nonce_to_hex, nonce_from_hex, nonce_to_json, nonce_to_js_value, nonce_from_json, nonce_new_identity, nonce_new_from_hash, nonce_get_hash, __wbg_vrfcert_free, vrfcert_to_bytes, vrfcert_from_bytes, vrfcert_to_hex, vrfcert_from_hex, vrfcert_to_json, vrfcert_to_js_value, vrfcert_from_json, vrfcert_proof, vrfcert_new, vkeywitnesses_len, vkeys_len, publickeys_size, vrfcert_output, scripthash_to_hex, transactionhash_to_hex, genesisdelegatehash_to_hex, genesishash_to_hex, auxiliarydatahash_to_hex, poolmetadatahash_to_hex, vrfkeyhash_to_hex, blockhash_to_hex, datahash_to_hex, scriptdatahash_to_hex, vrfvkey_to_hex, kesvkey_to_hex, vkeywitness_vkey, vkeywitness_signature, scripthash_to_bech32, transactionhash_to_bech32, genesisdelegatehash_to_bech32, genesishash_to_bech32, auxiliarydatahash_to_bech32, poolmetadatahash_to_bech32, vrfkeyhash_to_bech32, blockhash_to_bech32, datahash_to_bech32, scriptdatahash_to_bech32, vrfvkey_to_bech32, kesvkey_to_bech32, scripthash_to_bytes, publickey_as_bytes, transactionhash_to_bytes, genesisdelegatehash_to_bytes, genesishash_to_bytes, auxiliarydatahash_to_bytes, poolmetadatahash_to_bytes, vrfkeyhash_to_bytes, blockhash_to_bytes, datahash_to_bytes, scriptdatahash_to_bytes, vrfvkey_to_bytes, kesvkey_to_bytes, vkeywitnesses_new, vkeys_new, __wbg_scripthash_free, __wbg_transactionhash_free, __wbg_genesisdelegatehash_free, __wbg_genesishash_free, __wbg_kesvkey_free, __wbg_poolmetadatahash_free, __wbg_auxiliarydatahash_free, __wbg_vrfkeyhash_free, __wbg_blockhash_free, __wbg_scriptdatahash_free, __wbg_datahash_free, __wbg_vrfvkey_free, __wbg_votingbuilder_free, votingbuilder_new, votingbuilder_add, votingbuilder_add_with_plutus_witness, votingbuilder_add_with_native_script, votingbuilder_get_plutus_witnesses, votingbuilder_get_ref_inputs, votingbuilder_get_native_scripts, votingbuilder_has_plutus_scripts, votingbuilder_build, __wbg_withdrawalsbuilder_free, withdrawalsbuilder_new, withdrawalsbuilder_add, withdrawalsbuilder_add_with_plutus_witness, withdrawalsbuilder_add_with_native_script, withdrawalsbuilder_get_plutus_witnesses, withdrawalsbuilder_get_ref_inputs, withdrawalsbuilder_get_native_scripts, withdrawalsbuilder_get_total_withdrawals, withdrawalsbuilder_has_plutus_scripts, withdrawalsbuilder_build, __wbg_certificate_free, certificate_to_bytes, certificate_from_bytes, certificate_to_hex, certificate_from_hex, certificate_to_json, certificate_to_js_value, certificate_from_json, certificate_new_stake_registration, certificate_new_stake_deregistration, certificate_new_stake_delegation, certificate_new_pool_registration, certificate_new_pool_retirement, certificate_new_genesis_key_delegation, certificate_new_move_instantaneous_rewards_cert, certificate_new_committee_hot_key_registration, certificate_new_committee_hot_key_deregistration, certificate_new_drep_deregistration, certificate_new_drep_registration, certificate_new_drep_update, certificate_new_stake_and_vote_delegation, certificate_new_stake_registration_and_delegation, certificate_new_stake_vote_registration_and_delegation, certificate_new_vote_delegation, certificate_new_vote_registration_and_delegation, certificate_kind, certificate_as_stake_registration, certificate_as_stake_deregistration, certificate_as_stake_delegation, certificate_as_pool_registration, certificate_as_pool_retirement, certificate_as_genesis_key_delegation, certificate_as_move_instantaneous_rewards_cert, certificate_as_committee_hot_key_registration, certificate_as_committee_hot_key_deregistration, certificate_as_drep_deregistration, certificate_as_drep_registration, certificate_as_drep_update, certificate_as_stake_and_vote_delegation, certificate_as_stake_registration_and_delegation, certificate_as_stake_vote_registration_and_delegation, certificate_as_vote_delegation, certificate_as_vote_registration_and_delegation, certificate_has_required_script_witness, __wbg_genesiskeydelegation_free, genesiskeydelegation_to_bytes, genesiskeydelegation_from_bytes, genesiskeydelegation_to_hex, genesiskeydelegation_from_hex, genesiskeydelegation_to_json, genesiskeydelegation_to_js_value, genesiskeydelegation_from_json, genesiskeydelegation_genesishash, genesiskeydelegation_genesis_delegate_hash, genesiskeydelegation_vrf_keyhash, genesiskeydelegation_new, __wbg_stakedelegation_free, stakedelegation_to_bytes, stakedelegation_from_bytes, stakedelegation_to_hex, stakedelegation_from_hex, stakedelegation_to_json, stakedelegation_to_js_value, stakedelegation_from_json, stakedelegation_stake_credential, stakedelegation_new, stakedelegation_has_script_credentials, __wbg_stakeandvotedelegation_free, stakeandvotedelegation_to_bytes, stakeandvotedelegation_from_bytes, stakeandvotedelegation_to_hex, stakeandvotedelegation_from_hex, stakeandvotedelegation_to_json, stakeandvotedelegation_to_js_value, stakeandvotedelegation_from_json, stakeandvotedelegation_stake_credential, stakeandvotedelegation_pool_keyhash, stakeandvotedelegation_drep, stakeandvotedelegation_new, stakeandvotedelegation_has_script_credentials, __wbg_drepderegistration_free, drepderegistration_to_bytes, drepderegistration_from_bytes, drepderegistration_to_hex, drepderegistration_from_hex, drepderegistration_to_json, drepderegistration_to_js_value, drepderegistration_from_json, drepderegistration_voting_credential, drepderegistration_coin, drepderegistration_new, drepderegistration_has_script_credentials, __wbg_drepupdate_free, drepupdate_to_bytes, drepupdate_from_bytes, drepupdate_to_hex, drepupdate_from_hex, drepupdate_to_json, drepupdate_to_js_value, drepupdate_from_json, drepupdate_voting_credential, drepupdate_anchor, drepupdate_new, drepupdate_new_with_anchor, drepupdate_has_script_credentials, __wbg_parameterchangeproposal_free, parameterchangeproposal_to_bytes, parameterchangeproposal_from_bytes, parameterchangeproposal_to_hex, parameterchangeproposal_from_hex, parameterchangeproposal_to_json, parameterchangeproposal_to_js_value, parameterchangeproposal_from_json, parameterchangeproposal_gov_action_id, parameterchangeproposal_protocol_param_updates, parameterchangeproposal_new, parameterchangeproposal_new_with_action_id, __wbg_hardforkinitiationproposal_free, hardforkinitiationproposal_to_bytes, hardforkinitiationproposal_from_bytes, hardforkinitiationproposal_to_hex, hardforkinitiationproposal_from_hex, hardforkinitiationproposal_to_json, hardforkinitiationproposal_to_js_value, hardforkinitiationproposal_from_json, hardforkinitiationproposal_gov_action_id, hardforkinitiationproposal_protocol_version, hardforkinitiationproposal_new, hardforkinitiationproposal_new_with_action_id, __wbg_newconstitutionproposal_free, newconstitutionproposal_to_bytes, newconstitutionproposal_from_bytes, newconstitutionproposal_to_hex, newconstitutionproposal_from_hex, newconstitutionproposal_to_json, newconstitutionproposal_to_js_value, newconstitutionproposal_from_json, newconstitutionproposal_gov_action_id, newconstitutionproposal_constitution, newconstitutionproposal_new, newconstitutionproposal_new_with_action_id, __wbg_votingproposal_free, votingproposal_to_bytes, votingproposal_from_bytes, votingproposal_to_hex, votingproposal_from_hex, votingproposal_to_json, votingproposal_to_js_value, votingproposal_from_json, votingproposal_new_parameter_change_proposal, votingproposal_new_hard_fork_initiation_proposal, votingproposal_new_treasury_withdrawals_proposal, votingproposal_new_no_confidence_proposal, votingproposal_new_new_committee_proposal, votingproposal_new_new_constitution_proposal, votingproposal_new_info_proposal, votingproposal_kind, votingproposal_as_parameter_change_proposal, votingproposal_as_hard_fork_initiation_proposal, votingproposal_as_treasury_withdrawals_proposal, votingproposal_as_no_confidence_proposal, votingproposal_as_new_committee_proposal, votingproposal_as_new_constitution_proposal, votingproposal_as_info_proposal, stakedelegation_pool_keyhash, __wbg_plutusscript_free, plutusscript_to_bytes, plutusscript_from_bytes, plutusscript_to_hex, plutusscript_from_hex, plutusscript_new, plutusscript_new_v2, plutusscript_new_v3, plutusscript_new_with_version, plutusscript_bytes, plutusscript_from_bytes_v2, plutusscript_from_bytes_v3, plutusscript_from_bytes_with_version, plutusscript_from_hex_with_version, plutusscript_hash, plutusscript_language_version, __wbg_plutusscripts_free, plutusscripts_to_bytes, plutusscripts_from_bytes, plutusscripts_to_hex, plutusscripts_from_hex, plutusscripts_to_json, plutusscripts_to_js_value, plutusscripts_from_json, plutusscripts_new, plutusscripts_get, plutusscripts_add, __wbg_constrplutusdata_free, constrplutusdata_to_bytes, constrplutusdata_from_bytes, constrplutusdata_to_hex, constrplutusdata_from_hex, constrplutusdata_alternative, constrplutusdata_data, constrplutusdata_new, __wbg_costmodel_free, costmodel_to_bytes, costmodel_from_bytes, costmodel_to_hex, costmodel_from_hex, costmodel_to_json, costmodel_to_js_value, costmodel_from_json, costmodel_new, costmodel_set, costmodel_get, __wbg_costmdls_free, costmdls_to_bytes, costmdls_from_bytes, costmdls_to_hex, costmdls_from_hex, costmdls_to_json, costmdls_to_js_value, costmdls_from_json, costmdls_new, costmdls_len, costmdls_insert, costmdls_get, costmdls_keys, costmdls_retain_language_versions, __wbg_exunitprices_free, exunitprices_to_bytes, exunitprices_from_bytes, exunitprices_to_hex, exunitprices_from_hex, exunitprices_to_json, exunitprices_to_js_value, exunitprices_from_json, exunitprices_mem_price, exunitprices_step_price, exunitprices_new, __wbg_exunits_free, exunits_to_bytes, exunits_from_bytes, exunits_to_hex, exunits_from_hex, exunits_to_json, exunits_to_js_value, exunits_from_json, exunits_mem, exunits_steps, exunits_new, __wbg_language_free, language_to_bytes, language_from_bytes, language_to_hex, language_from_hex, language_to_json, language_to_js_value, language_from_json, language_new_plutus_v1, language_new_plutus_v2, language_new_plutus_v3, language_kind, __wbg_languages_free, languages_new, languages_get, languages_add, languages_list, __wbg_plutusmap_free, plutusmap_to_bytes, plutusmap_from_bytes, plutusmap_to_hex, plutusmap_from_hex, plutusmap_new, plutusmap_len, plutusmap_insert, plutusmap_get, plutusmap_keys, __wbg_plutusdata_free, plutusdata_to_bytes, plutusdata_from_bytes, plutusdata_to_hex, plutusdata_from_hex, plutusdata_new_constr_plutus_data, plutusdata_new_empty_constr_plutus_data, plutusdata_new_single_value_constr_plutus_data, plutusdata_new_map, plutusdata_new_list, plutusdata_new_integer, plutusdata_new_bytes, plutusdata_kind, plutusdata_as_constr_plutus_data, plutusdata_as_map, plutusdata_as_list, plutusdata_as_integer, plutusdata_as_bytes, plutusdata_from_address, __wbg_plutuslist_free, plutuslist_to_bytes, plutuslist_from_bytes, plutuslist_to_hex, plutuslist_from_hex, plutuslist_new, plutuslist_get, plutuslist_add, __wbg_redeemer_free, redeemer_to_bytes, redeemer_from_bytes, redeemer_to_hex, redeemer_from_hex, redeemer_to_json, redeemer_to_js_value, redeemer_from_json, redeemer_tag, redeemer_index, redeemer_data, redeemer_ex_units, redeemer_new, __wbg_redeemertag_free, redeemertag_to_bytes, redeemertag_from_bytes, redeemertag_to_hex, redeemertag_from_hex, redeemertag_to_json, redeemertag_to_js_value, redeemertag_from_json, redeemertag_new_reward, redeemertag_new_vote, redeemertag_new_voting_proposal, redeemertag_kind, __wbg_redeemers_free, redeemers_to_bytes, redeemers_from_bytes, redeemers_to_hex, redeemers_from_hex, redeemers_to_json, redeemers_to_js_value, redeemers_from_json, redeemers_get, redeemers_add, redeemers_total_ex_units, __wbg_strings_free, strings_get, strings_add, encode_json_str_to_plutus_datum, decode_plutus_datum_to_json_str, plutusdata_to_json, plutusdata_from_json, plutusscripts_len, costmodel_len, languages_len, plutuslist_len, redeemers_len, strings_len, redeemertag_new_cert, redeemertag_new_mint, redeemertag_new_spend, strings_new, redeemers_new, __wbg_txbuilderconstants_free, txbuilderconstants_plutus_default_cost_models, txbuilderconstants_plutus_alonzo_cost_models, __wbg_poolretirement_free, poolretirement_to_bytes, poolretirement_from_bytes, poolretirement_to_hex, poolretirement_from_hex, poolretirement_to_json, poolretirement_to_js_value, poolretirement_from_json, poolretirement_pool_keyhash, poolretirement_epoch, poolretirement_new, __wbg_stakederegistration_free, stakederegistration_to_bytes, stakederegistration_from_bytes, stakederegistration_to_hex, stakederegistration_from_hex, stakederegistration_to_json, stakederegistration_to_js_value, stakederegistration_from_json, stakederegistration_stake_credential, stakederegistration_coin, stakederegistration_new, stakederegistration_new_with_coin, stakederegistration_has_script_credentials, stakeregistration_to_bytes, stakeregistration_from_bytes, stakeregistration_to_hex, stakeregistration_from_hex, stakeregistration_to_js_value, stakeregistration_from_json, votedelegation_to_bytes, votedelegation_from_bytes, votedelegation_to_hex, votedelegation_from_hex, votedelegation_to_json, votedelegation_to_js_value, votedelegation_from_json, votedelegation_drep, votedelegation_new, votedelegation_has_script_credentials, __wbg_committeehotauth_free, committeehotauth_to_bytes, committeehotauth_from_bytes, committeehotauth_to_hex, committeehotauth_from_hex, committeehotauth_to_json, committeehotauth_to_js_value, committeehotauth_from_json, committeehotauth_committee_cold_key, committeehotauth_committee_hot_key, committeehotauth_new, committeehotauth_has_script_credentials, __wbg_anchor_free, anchor_to_bytes, anchor_from_bytes, anchor_to_hex, anchor_from_hex, anchor_to_json, anchor_to_js_value, anchor_from_json, anchor_url, anchor_anchor_data_hash, anchor_new, __wbg_governanceactionid_free, governanceactionid_to_bytes, governanceactionid_from_bytes, governanceactionid_to_hex, governanceactionid_from_hex, governanceactionid_to_json, governanceactionid_to_js_value, governanceactionid_from_json, governanceactionid_transaction_id, governanceactionid_index, governanceactionid_new, __wbg_constitution_free, constitution_to_bytes, constitution_from_bytes, constitution_to_hex, constitution_from_hex, constitution_to_json, constitution_to_js_value, constitution_from_json, constitution_anchor, constitution_script_hash, constitution_new, constitution_new_with_script_hash, __wbg_metadatamap_free, metadatamap_to_bytes, metadatamap_from_bytes, metadatamap_to_hex, metadatamap_from_hex, metadatamap_insert, metadatamap_insert_str, metadatamap_insert_i32, metadatamap_get, metadatamap_get_str, metadatamap_get_i32, metadatamap_has, metadatamap_keys, __wbg_metadatalist_free, metadatalist_to_bytes, metadatalist_from_bytes, metadatalist_to_hex, metadatalist_from_hex, metadatalist_new, metadatalist_len, metadatalist_get, metadatalist_add, __wbg_transactionmetadatum_free, transactionmetadatum_to_bytes, transactionmetadatum_from_bytes, transactionmetadatum_to_hex, transactionmetadatum_from_hex, transactionmetadatum_new_map, transactionmetadatum_new_list, transactionmetadatum_new_int, transactionmetadatum_new_bytes, transactionmetadatum_new_text, transactionmetadatum_kind, transactionmetadatum_as_map, transactionmetadatum_as_list, transactionmetadatum_as_int, transactionmetadatum_as_bytes, transactionmetadatum_as_text, __wbg_transactionmetadatumlabels_free, transactionmetadatumlabels_to_bytes, transactionmetadatumlabels_from_bytes, transactionmetadatumlabels_to_hex, transactionmetadatumlabels_from_hex, transactionmetadatumlabels_get, transactionmetadatumlabels_add, __wbg_generaltransactionmetadata_free, generaltransactionmetadata_to_bytes, generaltransactionmetadata_from_bytes, generaltransactionmetadata_to_hex, generaltransactionmetadata_from_hex, generaltransactionmetadata_to_json, generaltransactionmetadata_to_js_value, generaltransactionmetadata_from_json, generaltransactionmetadata_new, generaltransactionmetadata_len, generaltransactionmetadata_insert, generaltransactionmetadata_get, generaltransactionmetadata_keys, __wbg_auxiliarydata_free, auxiliarydata_to_bytes, auxiliarydata_from_bytes, auxiliarydata_to_hex, auxiliarydata_from_hex, auxiliarydata_to_json, auxiliarydata_to_js_value, auxiliarydata_from_json, auxiliarydata_new, auxiliarydata_metadata, auxiliarydata_set_metadata, auxiliarydata_native_scripts, auxiliarydata_set_native_scripts, auxiliarydata_plutus_scripts, auxiliarydata_set_plutus_scripts, auxiliarydata_prefer_alonzo_format, auxiliarydata_set_prefer_alonzo_format, encode_arbitrary_bytes_as_metadatum, decode_arbitrary_bytes_from_metadatum, encode_json_str_to_metadatum, decode_metadatum_to_json_str, transactionmetadatumlabels_len, metadatamap_len, stakeregistration_coin, stakeregistration_stake_credential, votedelegation_stake_credential, stakeregistration_new_with_coin, txbuilderconstants_plutus_vasil_cost_models, stakeregistration_new, metadatamap_new, transactionmetadatumlabels_new, __wbg_stakeregistration_free, __wbg_votedelegation_free, stakeregistration_to_json, __wbg_transactionbuilderconfig_free, __wbg_transactionbuilderconfigbuilder_free, transactionbuilderconfigbuilder_new, transactionbuilderconfigbuilder_fee_algo, transactionbuilderconfigbuilder_coins_per_utxo_word, transactionbuilderconfigbuilder_coins_per_utxo_byte, transactionbuilderconfigbuilder_ex_unit_prices, transactionbuilderconfigbuilder_pool_deposit, transactionbuilderconfigbuilder_key_deposit, transactionbuilderconfigbuilder_max_value_size, transactionbuilderconfigbuilder_max_tx_size, transactionbuilderconfigbuilder_prefer_pure_change, transactionbuilderconfigbuilder_voting_proposal_deposit, transactionbuilderconfigbuilder_build, __wbg_transactionbuilder_free, transactionbuilder_add_inputs_from, transactionbuilder_set_inputs, transactionbuilder_set_collateral, transactionbuilder_set_collateral_return, transactionbuilder_set_collateral_return_and_total, transactionbuilder_set_total_collateral, transactionbuilder_set_total_collateral_and_return, transactionbuilder_add_reference_input, transactionbuilder_add_key_input, transactionbuilder_add_script_input, transactionbuilder_add_native_script_input, transactionbuilder_add_plutus_script_input, transactionbuilder_add_bootstrap_input, transactionbuilder_add_input, transactionbuilder_count_missing_input_scripts, transactionbuilder_add_required_native_input_scripts, transactionbuilder_add_required_plutus_input_scripts, transactionbuilder_get_native_input_scripts, transactionbuilder_get_plutus_input_scripts, transactionbuilder_fee_for_input, transactionbuilder_add_output, transactionbuilder_fee_for_output, transactionbuilder_set_fee, transactionbuilder_set_ttl, transactionbuilder_set_ttl_bignum, transactionbuilder_set_validity_start_interval, transactionbuilder_set_validity_start_interval_bignum, transactionbuilder_set_certs, transactionbuilder_set_certs_builder, transactionbuilder_set_withdrawals, transactionbuilder_set_withdrawals_builder, transactionbuilder_set_voting_builder, transactionbuilder_set_voting_proposal_builder, transactionbuilder_get_auxiliary_data, transactionbuilder_set_auxiliary_data, transactionbuilder_set_metadata, transactionbuilder_add_metadatum, transactionbuilder_add_json_metadatum, transactionbuilder_add_json_metadatum_with_schema, transactionbuilder_set_mint_builder, transactionbuilder_get_mint_builder, transactionbuilder_set_mint, transactionbuilder_get_mint, transactionbuilder_get_mint_scripts, transactionbuilder_set_mint_asset, transactionbuilder_add_mint_asset, transactionbuilder_add_mint_asset_and_output, transactionbuilder_add_mint_asset_and_output_min_required_coin, transactionbuilder_add_extra_witness_datum, transactionbuilder_get_extra_witness_datums, transactionbuilder_set_donation, transactionbuilder_get_donation, transactionbuilder_set_current_treasury_value, transactionbuilder_get_current_treasury_value, transactionbuilder_new, transactionbuilder_get_reference_inputs, transactionbuilder_get_explicit_input, transactionbuilder_get_implicit_input, transactionbuilder_get_total_input, transactionbuilder_get_total_output, transactionbuilder_get_explicit_output, transactionbuilder_get_deposit, transactionbuilder_get_fee_if_set, transactionbuilder_add_change_if_needed, transactionbuilder_add_change_if_needed_with_datum, transactionbuilder_calc_script_data_hash, transactionbuilder_set_script_data_hash, transactionbuilder_remove_script_data_hash, transactionbuilder_add_required_signer, transactionbuilder_full_size, transactionbuilder_output_sizes, transactionbuilder_build, transactionbuilder_build_tx, transactionbuilder_build_tx_unsafe, transactionbuilder_min_fee, __wbg_moveinstantaneousrewardscert_free, moveinstantaneousrewardscert_to_bytes, moveinstantaneousrewardscert_from_bytes, moveinstantaneousrewardscert_to_hex, moveinstantaneousrewardscert_from_hex, moveinstantaneousrewardscert_to_json, moveinstantaneousrewardscert_to_js_value, moveinstantaneousrewardscert_from_json, moveinstantaneousrewardscert_move_instantaneous_reward, moveinstantaneousrewardscert_new, __wbg_mirtostakecredentials_free, mirtostakecredentials_to_bytes, mirtostakecredentials_from_bytes, mirtostakecredentials_to_hex, mirtostakecredentials_from_hex, mirtostakecredentials_to_json, mirtostakecredentials_to_js_value, mirtostakecredentials_from_json, mirtostakecredentials_new, mirtostakecredentials_len, mirtostakecredentials_insert, mirtostakecredentials_get, mirtostakecredentials_keys, __wbg_moveinstantaneousreward_free, moveinstantaneousreward_to_bytes, moveinstantaneousreward_from_bytes, moveinstantaneousreward_to_hex, moveinstantaneousreward_from_hex, moveinstantaneousreward_to_json, moveinstantaneousreward_to_js_value, moveinstantaneousreward_from_json, moveinstantaneousreward_new_to_other_pot, moveinstantaneousreward_new_to_stake_creds, moveinstantaneousreward_pot, moveinstantaneousreward_kind, moveinstantaneousreward_as_to_other_pot, moveinstantaneousreward_as_to_stake_creds, __wbg_poolregistration_free, poolregistration_to_bytes, poolregistration_from_bytes, poolregistration_to_hex, poolregistration_from_hex, poolregistration_to_json, poolregistration_to_js_value, poolregistration_from_json, poolregistration_pool_params, poolregistration_new, __wbg_relays_free, relays_to_bytes, relays_from_bytes, relays_to_hex, relays_from_hex, relays_to_json, relays_to_js_value, relays_from_json, relays_new, relays_len, relays_get, relays_add, __wbg_poolparams_free, poolparams_to_bytes, poolparams_from_bytes, poolparams_to_hex, poolparams_from_hex, poolparams_to_json, poolparams_to_js_value, poolparams_from_json, poolparams_operator, poolparams_vrf_keyhash, poolparams_pledge, poolparams_cost, poolparams_margin, poolparams_reward_account, poolparams_pool_owners, poolparams_relays, poolparams_pool_metadata, poolparams_new, __wbindgen_malloc, __wbindgen_realloc, __wbindgen_add_to_stack_pointer, __wbindgen_free, __wbindgen_exn_store */
/***/ (function(module, exports, __webpack_require__) {

eval("\"use strict\";\n// Instantiate WebAssembly module\nvar wasmExports = __webpack_require__.w[module.i];\n__webpack_require__.r(exports);\n// export exports from WebAssembly module\nfor(var name in wasmExports) if(name != \"__webpack_init__\") exports[name] = wasmExports[name];\n// exec imports from WebAssembly module (for esm order)\n/* harmony import */ var m0 = __webpack_require__(/*! ./cardano_serialization_lib_bg.js */ \"./node_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib_bg.js\");\n\n\n// exec wasm module\nwasmExports[\"__webpack_init__\"]()\n\n//# sourceURL=webpack:///./node_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib_bg.wasm?");

/***/ }),

/***/ "./node_modules/@emurgo/cip4-js/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@emurgo/cip4-js/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst blake2b_1 = __importDefault(__webpack_require__(/*! blake2b */ \"./node_modules/blake2b/index.js\"));\nconst buffer_crc32_1 = __importDefault(__webpack_require__(/*! buffer-crc32 */ \"./node_modules/buffer-crc32/index.js\"));\nconst fnv_plus_1 = __webpack_require__(/*! fnv-plus */ \"./node_modules/fnv-plus/index.js\");\nconst ALPHA = `ABCDEJHKLNOPSTXZ`;\nfunction textPartFromBytes([a, b, c, d]) {\n    const letters = (x) => `${ALPHA[Math.floor(x / 16)]}${ALPHA[x % 16]}`;\n    const numbers = `${((c << 8) + d) % 10000}`.padStart(4, '0');\n    return `${letters(a)}${letters(b)}-${numbers}`;\n}\nfunction legacyWalletChecksum(publicKeyHash /* note: lowercase hex representation */) {\n    // ImagePart\n    const output = new Uint8Array(64);\n    const input = Buffer.from(publicKeyHash);\n    const ImagePart = blake2b_1.default(output.length).update(input).digest('hex');\n    // TextPart\n    const [a, b, c, d] = buffer_crc32_1.default(ImagePart);\n    const TextPart = textPartFromBytes([a, b, c, d]);\n    return { ImagePart, TextPart };\n}\nexports.legacyWalletChecksum = legacyWalletChecksum;\nfunction toBytesInt32(int32) {\n    const byteArray = [0, 0, 0, 0];\n    for (let index = 0; index < byteArray.length; index++) {\n        const byte = int32 & 0xff;\n        byteArray[index] = byte;\n        int32 = (int32 - byte) / 256;\n    }\n    return byteArray;\n}\nfunction textPartFromWalletChecksumImagePart(walletChecksum) {\n    return textPartFromBytes(toBytesInt32(fnv_plus_1.fast1a32(walletChecksum)));\n}\nexports.textPartFromWalletChecksumImagePart = textPartFromWalletChecksumImagePart;\nfunction walletChecksum(publicKeyHash /* note: lowercase hex representation */) {\n    // ImagePart\n    const output = new Uint8Array(64);\n    const input = Buffer.from(publicKeyHash);\n    const ImagePart = blake2b_1.default(output.length, undefined, undefined, Buffer.from('wallets checksum') // personal\n    ).update(input).digest('hex');\n    // TextPart\n    const TextPart = textPartFromWalletChecksumImagePart(ImagePart);\n    return { ImagePart, TextPart };\n}\nexports.walletChecksum = walletChecksum;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/@emurgo/cip4-js/index.js?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack:///./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/bignumber.js/bignumber.js":
/*!************************************************!*\
  !*** ./node_modules/bignumber.js/bignumber.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;;(function (globalObject) {\r\n  'use strict';\r\n\r\n/*\r\n *      bignumber.js v9.0.1\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */\r\n\r\n\r\n  var BigNumber,\r\n    isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i,\r\n    mathceil = Math.ceil,\r\n    mathfloor = Math.floor,\r\n\r\n    bignumberError = '[BigNumber Error] ',\r\n    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',\r\n\r\n    BASE = 1e14,\r\n    LOG_BASE = 14,\r\n    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1\r\n    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\r\n    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],\r\n    SQRT_BASE = 1e7,\r\n\r\n    // EDITABLE\r\n    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\r\n    // the arguments to toExponential, toFixed, toFormat, and toPrecision.\r\n    MAX = 1E9;                                   // 0 to MAX_INT32\r\n\r\n\r\n  /*\r\n   * Create and return a BigNumber constructor.\r\n   */\r\n  function clone(configObject) {\r\n    var div, convertBase, parseNumeric,\r\n      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },\r\n      ONE = new BigNumber(1),\r\n\r\n\r\n      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\r\n\r\n\r\n      // The default values below must be integers within the inclusive ranges stated.\r\n      // The values can also be changed at run-time using BigNumber.set.\r\n\r\n      // The maximum number of decimal places for operations involving division.\r\n      DECIMAL_PLACES = 20,                     // 0 to MAX\r\n\r\n      // The rounding mode used when rounding to the above decimal places, and when using\r\n      // toExponential, toFixed, toFormat and toPrecision, and round (default value).\r\n      // UP         0 Away from zero.\r\n      // DOWN       1 Towards zero.\r\n      // CEIL       2 Towards +Infinity.\r\n      // FLOOR      3 Towards -Infinity.\r\n      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n      ROUNDING_MODE = 4,                       // 0 to 8\r\n\r\n      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\r\n\r\n      // The exponent value at and beneath which toString returns exponential notation.\r\n      // Number type: -7\r\n      TO_EXP_NEG = -7,                         // 0 to -MAX\r\n\r\n      // The exponent value at and above which toString returns exponential notation.\r\n      // Number type: 21\r\n      TO_EXP_POS = 21,                         // 0 to MAX\r\n\r\n      // RANGE : [MIN_EXP, MAX_EXP]\r\n\r\n      // The minimum exponent value, beneath which underflow to zero occurs.\r\n      // Number type: -324  (5e-324)\r\n      MIN_EXP = -1e7,                          // -1 to -MAX\r\n\r\n      // The maximum exponent value, above which overflow to Infinity occurs.\r\n      // Number type:  308  (1.7976931348623157e+308)\r\n      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\r\n      MAX_EXP = 1e7,                           // 1 to MAX\r\n\r\n      // Whether to use cryptographically-secure random number generation, if available.\r\n      CRYPTO = false,                          // true or false\r\n\r\n      // The modulo mode used when calculating the modulus: a mod n.\r\n      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n      // The remainder (r) is calculated as: r = a - n * q.\r\n      //\r\n      // UP        0 The remainder is positive if the dividend is negative, else is negative.\r\n      // DOWN      1 The remainder has the same sign as the dividend.\r\n      //             This modulo mode is commonly known as 'truncated division' and is\r\n      //             equivalent to (a % n) in JavaScript.\r\n      // FLOOR     3 The remainder has the same sign as the divisor (Python %).\r\n      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\r\n      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\r\n      //             The remainder is always positive.\r\n      //\r\n      // The truncated division, floored division, Euclidian division and IEEE 754 remainder\r\n      // modes are commonly used for the modulus operation.\r\n      // Although the other rounding modes can also be used, they may not give useful results.\r\n      MODULO_MODE = 1,                         // 0 to 9\r\n\r\n      // The maximum number of significant digits of the result of the exponentiatedBy operation.\r\n      // If POW_PRECISION is 0, there will be unlimited significant digits.\r\n      POW_PRECISION = 0,                    // 0 to MAX\r\n\r\n      // The format specification used by the BigNumber.prototype.toFormat method.\r\n      FORMAT = {\r\n        prefix: '',\r\n        groupSize: 3,\r\n        secondaryGroupSize: 0,\r\n        groupSeparator: ',',\r\n        decimalSeparator: '.',\r\n        fractionGroupSize: 0,\r\n        fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n        suffix: ''\r\n      },\r\n\r\n      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\r\n      // '-', '.', whitespace, or repeated character.\r\n      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';\r\n\r\n\r\n    //------------------------------------------------------------------------------------------\r\n\r\n\r\n    // CONSTRUCTOR\r\n\r\n\r\n    /*\r\n     * The BigNumber constructor and exported function.\r\n     * Create and return a new instance of a BigNumber object.\r\n     *\r\n     * v {number|string|BigNumber} A numeric value.\r\n     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n     */\r\n    function BigNumber(v, b) {\r\n      var alphabet, c, caseChanged, e, i, isNum, len, str,\r\n        x = this;\r\n\r\n      // Enable constructor call without `new`.\r\n      if (!(x instanceof BigNumber)) return new BigNumber(v, b);\r\n\r\n      if (b == null) {\r\n\r\n        if (v && v._isBigNumber === true) {\r\n          x.s = v.s;\r\n\r\n          if (!v.c || v.e > MAX_EXP) {\r\n            x.c = x.e = null;\r\n          } else if (v.e < MIN_EXP) {\r\n            x.c = [x.e = 0];\r\n          } else {\r\n            x.e = v.e;\r\n            x.c = v.c.slice();\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        if ((isNum = typeof v == 'number') && v * 0 == 0) {\r\n\r\n          // Use `1 / n` to handle minus zero also.\r\n          x.s = 1 / v < 0 ? (v = -v, -1) : 1;\r\n\r\n          // Fast path for integers, where n < 2147483648 (2**31).\r\n          if (v === ~~v) {\r\n            for (e = 0, i = v; i >= 10; i /= 10, e++);\r\n\r\n            if (e > MAX_EXP) {\r\n              x.c = x.e = null;\r\n            } else {\r\n              x.e = e;\r\n              x.c = [v];\r\n            }\r\n\r\n            return;\r\n          }\r\n\r\n          str = String(v);\r\n        } else {\r\n\r\n          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\r\n\r\n          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n        // Exponential form?\r\n        if ((i = str.search(/e/i)) > 0) {\r\n\r\n          // Determine exponent.\r\n          if (e < 0) e = i;\r\n          e += +str.slice(i + 1);\r\n          str = str.substring(0, i);\r\n        } else if (e < 0) {\r\n\r\n          // Integer.\r\n          e = str.length;\r\n        }\r\n\r\n      } else {\r\n\r\n        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n        intCheck(b, 2, ALPHABET.length, 'Base');\r\n\r\n        // Allow exponential notation to be used with base 10 argument, while\r\n        // also rounding to DECIMAL_PLACES as with other bases.\r\n        if (b == 10) {\r\n          x = new BigNumber(v);\r\n          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\r\n        }\r\n\r\n        str = String(v);\r\n\r\n        if (isNum = typeof v == 'number') {\r\n\r\n          // Avoid potential interpretation of Infinity and NaN as base 44+ values.\r\n          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\r\n\r\n          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\r\n\r\n          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n          if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, '').length > 15) {\r\n            throw Error\r\n             (tooManyDigits + v);\r\n          }\r\n        } else {\r\n          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        alphabet = ALPHABET.slice(0, b);\r\n        e = i = 0;\r\n\r\n        // Check that str is a valid base b number.\r\n        // Don't use RegExp, so alphabet can contain special characters.\r\n        for (len = str.length; i < len; i++) {\r\n          if (alphabet.indexOf(c = str.charAt(i)) < 0) {\r\n            if (c == '.') {\r\n\r\n              // If '.' is not the first character and it has not be found before.\r\n              if (i > e) {\r\n                e = len;\r\n                continue;\r\n              }\r\n            } else if (!caseChanged) {\r\n\r\n              // Allow e.g. hexadecimal 'FF' as well as 'ff'.\r\n              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||\r\n                  str == str.toLowerCase() && (str = str.toUpperCase())) {\r\n                caseChanged = true;\r\n                i = -1;\r\n                e = 0;\r\n                continue;\r\n              }\r\n            }\r\n\r\n            return parseNumeric(x, String(v), isNum, b);\r\n          }\r\n        }\r\n\r\n        // Prevent later check for length on converted number.\r\n        isNum = false;\r\n        str = convertBase(str, b, 10, x.s);\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n        else e = str.length;\r\n      }\r\n\r\n      // Determine leading zeros.\r\n      for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n      // Determine trailing zeros.\r\n      for (len = str.length; str.charCodeAt(--len) === 48;);\r\n\r\n      if (str = str.slice(i, ++len)) {\r\n        len -= i;\r\n\r\n        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n        if (isNum && BigNumber.DEBUG &&\r\n          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {\r\n            throw Error\r\n             (tooManyDigits + (x.s * v));\r\n        }\r\n\r\n         // Overflow?\r\n        if ((e = e - i - 1) > MAX_EXP) {\r\n\r\n          // Infinity.\r\n          x.c = x.e = null;\r\n\r\n        // Underflow?\r\n        } else if (e < MIN_EXP) {\r\n\r\n          // Zero.\r\n          x.c = [x.e = 0];\r\n        } else {\r\n          x.e = e;\r\n          x.c = [];\r\n\r\n          // Transform base\r\n\r\n          // e is the base 10 exponent.\r\n          // i is where to slice str to get the first element of the coefficient array.\r\n          i = (e + 1) % LOG_BASE;\r\n          if (e < 0) i += LOG_BASE;  // i < 1\r\n\r\n          if (i < len) {\r\n            if (i) x.c.push(+str.slice(0, i));\r\n\r\n            for (len -= LOG_BASE; i < len;) {\r\n              x.c.push(+str.slice(i, i += LOG_BASE));\r\n            }\r\n\r\n            i = LOG_BASE - (str = str.slice(i)).length;\r\n          } else {\r\n            i -= len;\r\n          }\r\n\r\n          for (; i--; str += '0');\r\n          x.c.push(+str);\r\n        }\r\n      } else {\r\n\r\n        // Zero.\r\n        x.c = [x.e = 0];\r\n      }\r\n    }\r\n\r\n\r\n    // CONSTRUCTOR PROPERTIES\r\n\r\n\r\n    BigNumber.clone = clone;\r\n\r\n    BigNumber.ROUND_UP = 0;\r\n    BigNumber.ROUND_DOWN = 1;\r\n    BigNumber.ROUND_CEIL = 2;\r\n    BigNumber.ROUND_FLOOR = 3;\r\n    BigNumber.ROUND_HALF_UP = 4;\r\n    BigNumber.ROUND_HALF_DOWN = 5;\r\n    BigNumber.ROUND_HALF_EVEN = 6;\r\n    BigNumber.ROUND_HALF_CEIL = 7;\r\n    BigNumber.ROUND_HALF_FLOOR = 8;\r\n    BigNumber.EUCLID = 9;\r\n\r\n\r\n    /*\r\n     * Configure infrequently-changing library-wide settings.\r\n     *\r\n     * Accept an object with the following optional properties (if the value of a property is\r\n     * a number, it must be an integer within the inclusive range stated):\r\n     *\r\n     *   DECIMAL_PLACES   {number}           0 to MAX\r\n     *   ROUNDING_MODE    {number}           0 to 8\r\n     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n     *   CRYPTO           {boolean}          true or false\r\n     *   MODULO_MODE      {number}           0 to 9\r\n     *   POW_PRECISION       {number}           0 to MAX\r\n     *   ALPHABET         {string}           A string of two or more unique characters which does\r\n     *                                       not contain '.'.\r\n     *   FORMAT           {object}           An object with some of the following properties:\r\n     *     prefix                 {string}\r\n     *     groupSize              {number}\r\n     *     secondaryGroupSize     {number}\r\n     *     groupSeparator         {string}\r\n     *     decimalSeparator       {string}\r\n     *     fractionGroupSize      {number}\r\n     *     fractionGroupSeparator {string}\r\n     *     suffix                 {string}\r\n     *\r\n     * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n     *\r\n     * E.g.\r\n     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n     *\r\n     * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n     *\r\n     * Return an object with the properties current values.\r\n     */\r\n    BigNumber.config = BigNumber.set = function (obj) {\r\n      var p, v;\r\n\r\n      if (obj != null) {\r\n\r\n        if (typeof obj == 'object') {\r\n\r\n          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            DECIMAL_PLACES = v;\r\n          }\r\n\r\n          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\r\n          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 8, p);\r\n            ROUNDING_MODE = v;\r\n          }\r\n\r\n          // EXPONENTIAL_AT {number|number[]}\r\n          // Integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\r\n          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, 0, p);\r\n              intCheck(v[1], 0, MAX, p);\r\n              TO_EXP_NEG = v[0];\r\n              TO_EXP_POS = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\r\n            }\r\n          }\r\n\r\n          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\r\n          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\r\n          if (obj.hasOwnProperty(p = 'RANGE')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, -1, p);\r\n              intCheck(v[1], 1, MAX, p);\r\n              MIN_EXP = v[0];\r\n              MAX_EXP = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              if (v) {\r\n                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\r\n              } else {\r\n                throw Error\r\n                 (bignumberError + p + ' cannot be zero: ' + v);\r\n              }\r\n            }\r\n          }\r\n\r\n          // CRYPTO {boolean} true or false.\r\n          // '[BigNumber Error] CRYPTO not true or false: {v}'\r\n          // '[BigNumber Error] crypto unavailable'\r\n          if (obj.hasOwnProperty(p = 'CRYPTO')) {\r\n            v = obj[p];\r\n            if (v === !!v) {\r\n              if (v) {\r\n                if (typeof crypto != 'undefined' && crypto &&\r\n                 (crypto.getRandomValues || crypto.randomBytes)) {\r\n                  CRYPTO = v;\r\n                } else {\r\n                  CRYPTO = !v;\r\n                  throw Error\r\n                   (bignumberError + 'crypto unavailable');\r\n                }\r\n              } else {\r\n                CRYPTO = v;\r\n              }\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' not true or false: ' + v);\r\n            }\r\n          }\r\n\r\n          // MODULO_MODE {number} Integer, 0 to 9 inclusive.\r\n          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 9, p);\r\n            MODULO_MODE = v;\r\n          }\r\n\r\n          // POW_PRECISION {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            POW_PRECISION = v;\r\n          }\r\n\r\n          // FORMAT {object}\r\n          // '[BigNumber Error] FORMAT not an object: {v}'\r\n          if (obj.hasOwnProperty(p = 'FORMAT')) {\r\n            v = obj[p];\r\n            if (typeof v == 'object') FORMAT = v;\r\n            else throw Error\r\n             (bignumberError + p + ' not an object: ' + v);\r\n          }\r\n\r\n          // ALPHABET {string}\r\n          // '[BigNumber Error] ALPHABET invalid: {v}'\r\n          if (obj.hasOwnProperty(p = 'ALPHABET')) {\r\n            v = obj[p];\r\n\r\n            // Disallow if less than two characters,\r\n            // or if it contains '+', '-', '.', whitespace, or a repeated character.\r\n            if (typeof v == 'string' && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(v)) {\r\n              ALPHABET = v;\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' invalid: ' + v);\r\n            }\r\n          }\r\n\r\n        } else {\r\n\r\n          // '[BigNumber Error] Object expected: {v}'\r\n          throw Error\r\n           (bignumberError + 'Object expected: ' + obj);\r\n        }\r\n      }\r\n\r\n      return {\r\n        DECIMAL_PLACES: DECIMAL_PLACES,\r\n        ROUNDING_MODE: ROUNDING_MODE,\r\n        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],\r\n        RANGE: [MIN_EXP, MAX_EXP],\r\n        CRYPTO: CRYPTO,\r\n        MODULO_MODE: MODULO_MODE,\r\n        POW_PRECISION: POW_PRECISION,\r\n        FORMAT: FORMAT,\r\n        ALPHABET: ALPHABET\r\n      };\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if v is a BigNumber instance, otherwise return false.\r\n     *\r\n     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n     *\r\n     * v {any}\r\n     *\r\n     * '[BigNumber Error] Invalid BigNumber: {v}'\r\n     */\r\n    BigNumber.isBigNumber = function (v) {\r\n      if (!v || v._isBigNumber !== true) return false;\r\n      if (!BigNumber.DEBUG) return true;\r\n\r\n      var i, n,\r\n        c = v.c,\r\n        e = v.e,\r\n        s = v.s;\r\n\r\n      out: if ({}.toString.call(c) == '[object Array]') {\r\n\r\n        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\r\n\r\n          // If the first element is zero, the BigNumber value must be zero.\r\n          if (c[0] === 0) {\r\n            if (e === 0 && c.length === 1) return true;\r\n            break out;\r\n          }\r\n\r\n          // Calculate number of digits that c[0] should have, based on the exponent.\r\n          i = (e + 1) % LOG_BASE;\r\n          if (i < 1) i += LOG_BASE;\r\n\r\n          // Calculate number of digits of c[0].\r\n          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\r\n          if (String(c[0]).length == i) {\r\n\r\n            for (i = 0; i < c.length; i++) {\r\n              n = c[i];\r\n              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\r\n            }\r\n\r\n            // Last element cannot be zero, unless it is the only element.\r\n            if (n !== 0) return true;\r\n          }\r\n        }\r\n\r\n      // Infinity/NaN\r\n      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\r\n        return true;\r\n      }\r\n\r\n      throw Error\r\n        (bignumberError + 'Invalid BigNumber: ' + v);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the maximum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.maximum = BigNumber.max = function () {\r\n      return maxOrMin(arguments, P.lt);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the minimum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.minimum = BigNumber.min = function () {\r\n      return maxOrMin(arguments, P.gt);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n     * zeros are produced).\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n     * '[BigNumber Error] crypto unavailable'\r\n     */\r\n    BigNumber.random = (function () {\r\n      var pow2_53 = 0x20000000000000;\r\n\r\n      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\r\n      // Check if Math.random() produces more than 32 bits of randomness.\r\n      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\r\n      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\r\n      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff\r\n       ? function () { return mathfloor(Math.random() * pow2_53); }\r\n       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +\r\n         (Math.random() * 0x800000 | 0); };\r\n\r\n      return function (dp) {\r\n        var a, b, e, k, v,\r\n          i = 0,\r\n          c = [],\r\n          rand = new BigNumber(ONE);\r\n\r\n        if (dp == null) dp = DECIMAL_PLACES;\r\n        else intCheck(dp, 0, MAX);\r\n\r\n        k = mathceil(dp / LOG_BASE);\r\n\r\n        if (CRYPTO) {\r\n\r\n          // Browsers supporting crypto.getRandomValues.\r\n          if (crypto.getRandomValues) {\r\n\r\n            a = crypto.getRandomValues(new Uint32Array(k *= 2));\r\n\r\n            for (; i < k;) {\r\n\r\n              // 53 bits:\r\n              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\r\n              // 11111 11111111 11111111 11111111 11100000 00000000 00000000\r\n              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\r\n              //                                     11111 11111111 11111111\r\n              // 0x20000 is 2^21.\r\n              v = a[i] * 0x20000 + (a[i + 1] >>> 11);\r\n\r\n              // Rejection sampling:\r\n              // 0 <= v < 9007199254740992\r\n              // Probability that v >= 9e15, is\r\n              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\r\n              if (v >= 9e15) {\r\n                b = crypto.getRandomValues(new Uint32Array(2));\r\n                a[i] = b[0];\r\n                a[i + 1] = b[1];\r\n              } else {\r\n\r\n                // 0 <= v <= 8999999999999999\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 2;\r\n              }\r\n            }\r\n            i = k / 2;\r\n\r\n          // Node.js supporting crypto.randomBytes.\r\n          } else if (crypto.randomBytes) {\r\n\r\n            // buffer\r\n            a = crypto.randomBytes(k *= 7);\r\n\r\n            for (; i < k;) {\r\n\r\n              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\r\n              // 0x100000000 is 2^32, 0x1000000 is 2^24\r\n              // 11111 11111111 11111111 11111111 11111111 11111111 11111111\r\n              // 0 <= v < 9007199254740992\r\n              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +\r\n                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +\r\n                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\r\n\r\n              if (v >= 9e15) {\r\n                crypto.randomBytes(7).copy(a, i);\r\n              } else {\r\n\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 7;\r\n              }\r\n            }\r\n            i = k / 7;\r\n          } else {\r\n            CRYPTO = false;\r\n            throw Error\r\n             (bignumberError + 'crypto unavailable');\r\n          }\r\n        }\r\n\r\n        // Use Math.random.\r\n        if (!CRYPTO) {\r\n\r\n          for (; i < k;) {\r\n            v = random53bitInt();\r\n            if (v < 9e15) c[i++] = v % 1e14;\r\n          }\r\n        }\r\n\r\n        k = c[--i];\r\n        dp %= LOG_BASE;\r\n\r\n        // Convert trailing digits to zeros according to dp.\r\n        if (k && dp) {\r\n          v = POWS_TEN[LOG_BASE - dp];\r\n          c[i] = mathfloor(k / v) * v;\r\n        }\r\n\r\n        // Remove trailing elements which are zero.\r\n        for (; c[i] === 0; c.pop(), i--);\r\n\r\n        // Zero?\r\n        if (i < 0) {\r\n          c = [e = 0];\r\n        } else {\r\n\r\n          // Remove leading elements which are zero and adjust exponent accordingly.\r\n          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\r\n\r\n          // Count the digits of the first element of c to determine leading zeros, and...\r\n          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);\r\n\r\n          // adjust the exponent accordingly.\r\n          if (i < LOG_BASE) e -= LOG_BASE - i;\r\n        }\r\n\r\n        rand.e = e;\r\n        rand.c = c;\r\n        return rand;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the sum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.sum = function () {\r\n      var i = 1,\r\n        args = arguments,\r\n        sum = new BigNumber(args[0]);\r\n      for (; i < args.length;) sum = sum.plus(args[i++]);\r\n      return sum;\r\n    };\r\n\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n\r\n    // Called by BigNumber and BigNumber.prototype.toString.\r\n    convertBase = (function () {\r\n      var decimal = '0123456789';\r\n\r\n      /*\r\n       * Convert string of baseIn to an array of numbers of baseOut.\r\n       * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n       */\r\n      function toBaseOut(str, baseIn, baseOut, alphabet) {\r\n        var j,\r\n          arr = [0],\r\n          arrL,\r\n          i = 0,\r\n          len = str.length;\r\n\r\n        for (; i < len;) {\r\n          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);\r\n\r\n          arr[0] += alphabet.indexOf(str.charAt(i++));\r\n\r\n          for (j = 0; j < arr.length; j++) {\r\n\r\n            if (arr[j] > baseOut - 1) {\r\n              if (arr[j + 1] == null) arr[j + 1] = 0;\r\n              arr[j + 1] += arr[j] / baseOut | 0;\r\n              arr[j] %= baseOut;\r\n            }\r\n          }\r\n        }\r\n\r\n        return arr.reverse();\r\n      }\r\n\r\n      // Convert a numeric string of baseIn to a numeric string of baseOut.\r\n      // If the caller is toString, we are converting from base 10 to baseOut.\r\n      // If the caller is BigNumber, we are converting from baseIn to base 10.\r\n      return function (str, baseIn, baseOut, sign, callerIsToString) {\r\n        var alphabet, d, e, k, r, x, xc, y,\r\n          i = str.indexOf('.'),\r\n          dp = DECIMAL_PLACES,\r\n          rm = ROUNDING_MODE;\r\n\r\n        // Non-integer.\r\n        if (i >= 0) {\r\n          k = POW_PRECISION;\r\n\r\n          // Unlimited precision.\r\n          POW_PRECISION = 0;\r\n          str = str.replace('.', '');\r\n          y = new BigNumber(baseIn);\r\n          x = y.pow(str.length - i);\r\n          POW_PRECISION = k;\r\n\r\n          // Convert str as if an integer, then restore the fraction part by dividing the\r\n          // result by its base raised to a power.\r\n\r\n          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),\r\n           10, baseOut, decimal);\r\n          y.e = y.c.length;\r\n        }\r\n\r\n        // Convert the number as integer.\r\n\r\n        xc = toBaseOut(str, baseIn, baseOut, callerIsToString\r\n         ? (alphabet = ALPHABET, decimal)\r\n         : (alphabet = decimal, ALPHABET));\r\n\r\n        // xc now represents str as an integer and converted to baseOut. e is the exponent.\r\n        e = k = xc.length;\r\n\r\n        // Remove trailing zeros.\r\n        for (; xc[--k] == 0; xc.pop());\r\n\r\n        // Zero?\r\n        if (!xc[0]) return alphabet.charAt(0);\r\n\r\n        // Does str represent an integer? If so, no need for the division.\r\n        if (i < 0) {\r\n          --e;\r\n        } else {\r\n          x.c = xc;\r\n          x.e = e;\r\n\r\n          // The sign is needed for correct rounding.\r\n          x.s = sign;\r\n          x = div(x, y, dp, rm, baseOut);\r\n          xc = x.c;\r\n          r = x.r;\r\n          e = x.e;\r\n        }\r\n\r\n        // xc now represents str converted to baseOut.\r\n\r\n        // THe index of the rounding digit.\r\n        d = e + dp + 1;\r\n\r\n        // The rounding digit: the digit to the right of the digit that may be rounded up.\r\n        i = xc[d];\r\n\r\n        // Look at the rounding digits and mode to determine whether to round up.\r\n\r\n        k = baseOut / 2;\r\n        r = r || d < 0 || xc[d + 1] != null;\r\n\r\n        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||\r\n               rm == (x.s < 0 ? 8 : 7));\r\n\r\n        // If the index of the rounding digit is not greater than zero, or xc represents\r\n        // zero, then the result of the base conversion is zero or, if rounding up, a value\r\n        // such as 0.00001.\r\n        if (d < 1 || !xc[0]) {\r\n\r\n          // 1^-dp or 0\r\n          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\r\n        } else {\r\n\r\n          // Truncate xc to the required number of decimal places.\r\n          xc.length = d;\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            // Rounding up may mean the previous digit has to be rounded up and so on.\r\n            for (--baseOut; ++xc[--d] > baseOut;) {\r\n              xc[d] = 0;\r\n\r\n              if (!d) {\r\n                ++e;\r\n                xc = [1].concat(xc);\r\n              }\r\n            }\r\n          }\r\n\r\n          // Determine trailing zeros.\r\n          for (k = xc.length; !xc[--k];);\r\n\r\n          // E.g. [4, 11, 15] becomes 4bf.\r\n          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));\r\n\r\n          // Add leading zeros, decimal point and trailing zeros as required.\r\n          str = toFixedPoint(str, e, alphabet.charAt(0));\r\n        }\r\n\r\n        // The caller will add the sign.\r\n        return str;\r\n      };\r\n    })();\r\n\r\n\r\n    // Perform division in the specified base. Called by div and convertBase.\r\n    div = (function () {\r\n\r\n      // Assume non-zero x and k.\r\n      function multiply(x, k, base) {\r\n        var m, temp, xlo, xhi,\r\n          carry = 0,\r\n          i = x.length,\r\n          klo = k % SQRT_BASE,\r\n          khi = k / SQRT_BASE | 0;\r\n\r\n        for (x = x.slice(); i--;) {\r\n          xlo = x[i] % SQRT_BASE;\r\n          xhi = x[i] / SQRT_BASE | 0;\r\n          m = khi * xlo + xhi * klo;\r\n          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;\r\n          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\r\n          x[i] = temp % base;\r\n        }\r\n\r\n        if (carry) x = [carry].concat(x);\r\n\r\n        return x;\r\n      }\r\n\r\n      function compare(a, b, aL, bL) {\r\n        var i, cmp;\r\n\r\n        if (aL != bL) {\r\n          cmp = aL > bL ? 1 : -1;\r\n        } else {\r\n\r\n          for (i = cmp = 0; i < aL; i++) {\r\n\r\n            if (a[i] != b[i]) {\r\n              cmp = a[i] > b[i] ? 1 : -1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        return cmp;\r\n      }\r\n\r\n      function subtract(a, b, aL, base) {\r\n        var i = 0;\r\n\r\n        // Subtract b from a.\r\n        for (; aL--;) {\r\n          a[aL] -= i;\r\n          i = a[aL] < b[aL] ? 1 : 0;\r\n          a[aL] = i * base + a[aL] - b[aL];\r\n        }\r\n\r\n        // Remove leading zeros.\r\n        for (; !a[0] && a.length > 1; a.splice(0, 1));\r\n      }\r\n\r\n      // x: dividend, y: divisor.\r\n      return function (x, y, dp, rm, base) {\r\n        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,\r\n          yL, yz,\r\n          s = x.s == y.s ? 1 : -1,\r\n          xc = x.c,\r\n          yc = y.c;\r\n\r\n        // Either NaN, Infinity or 0?\r\n        if (!xc || !xc[0] || !yc || !yc[0]) {\r\n\r\n          return new BigNumber(\r\n\r\n           // Return NaN if either NaN, or both Infinity or 0.\r\n           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :\r\n\r\n            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.\r\n            xc && xc[0] == 0 || !yc ? s * 0 : s / 0\r\n         );\r\n        }\r\n\r\n        q = new BigNumber(s);\r\n        qc = q.c = [];\r\n        e = x.e - y.e;\r\n        s = dp + e + 1;\r\n\r\n        if (!base) {\r\n          base = BASE;\r\n          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\r\n          s = s / LOG_BASE | 0;\r\n        }\r\n\r\n        // Result exponent may be one less then the current value of e.\r\n        // The coefficients of the BigNumbers from convertBase may have trailing zeros.\r\n        for (i = 0; yc[i] == (xc[i] || 0); i++);\r\n\r\n        if (yc[i] > (xc[i] || 0)) e--;\r\n\r\n        if (s < 0) {\r\n          qc.push(1);\r\n          more = true;\r\n        } else {\r\n          xL = xc.length;\r\n          yL = yc.length;\r\n          i = 0;\r\n          s += 2;\r\n\r\n          // Normalise xc and yc so highest order digit of yc is >= base / 2.\r\n\r\n          n = mathfloor(base / (yc[0] + 1));\r\n\r\n          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\r\n          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\r\n          if (n > 1) {\r\n            yc = multiply(yc, n, base);\r\n            xc = multiply(xc, n, base);\r\n            yL = yc.length;\r\n            xL = xc.length;\r\n          }\r\n\r\n          xi = yL;\r\n          rem = xc.slice(0, yL);\r\n          remL = rem.length;\r\n\r\n          // Add zeros to make remainder as long as divisor.\r\n          for (; remL < yL; rem[remL++] = 0);\r\n          yz = yc.slice();\r\n          yz = [0].concat(yz);\r\n          yc0 = yc[0];\r\n          if (yc[1] >= base / 2) yc0++;\r\n          // Not necessary, but to prevent trial digit n > base, when using base 3.\r\n          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\r\n\r\n          do {\r\n            n = 0;\r\n\r\n            // Compare divisor and remainder.\r\n            cmp = compare(yc, rem, yL, remL);\r\n\r\n            // If divisor < remainder.\r\n            if (cmp < 0) {\r\n\r\n              // Calculate trial digit, n.\r\n\r\n              rem0 = rem[0];\r\n              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n              // n is how many times the divisor goes into the current remainder.\r\n              n = mathfloor(rem0 / yc0);\r\n\r\n              //  Algorithm:\r\n              //  product = divisor multiplied by trial digit (n).\r\n              //  Compare product and remainder.\r\n              //  If product is greater than remainder:\r\n              //    Subtract divisor from product, decrement trial digit.\r\n              //  Subtract product from remainder.\r\n              //  If product was less than remainder at the last compare:\r\n              //    Compare new remainder and divisor.\r\n              //    If remainder is greater than divisor:\r\n              //      Subtract divisor from remainder, increment trial digit.\r\n\r\n              if (n > 1) {\r\n\r\n                // n may be > base only when base is 3.\r\n                if (n >= base) n = base - 1;\r\n\r\n                // product = divisor * trial digit.\r\n                prod = multiply(yc, n, base);\r\n                prodL = prod.length;\r\n                remL = rem.length;\r\n\r\n                // Compare product and remainder.\r\n                // If product > remainder then trial digit n too high.\r\n                // n is 1 too high about 5% of the time, and is not known to have\r\n                // ever been more than 1 too high.\r\n                while (compare(prod, rem, prodL, remL) == 1) {\r\n                  n--;\r\n\r\n                  // Subtract divisor from product.\r\n                  subtract(prod, yL < prodL ? yz : yc, prodL, base);\r\n                  prodL = prod.length;\r\n                  cmp = 1;\r\n                }\r\n              } else {\r\n\r\n                // n is 0 or 1, cmp is -1.\r\n                // If n is 0, there is no need to compare yc and rem again below,\r\n                // so change cmp to 1 to avoid it.\r\n                // If n is 1, leave cmp as -1, so yc and rem are compared again.\r\n                if (n == 0) {\r\n\r\n                  // divisor < remainder, so n must be at least 1.\r\n                  cmp = n = 1;\r\n                }\r\n\r\n                // product = divisor\r\n                prod = yc.slice();\r\n                prodL = prod.length;\r\n              }\r\n\r\n              if (prodL < remL) prod = [0].concat(prod);\r\n\r\n              // Subtract product from remainder.\r\n              subtract(rem, prod, remL, base);\r\n              remL = rem.length;\r\n\r\n               // If product was < remainder.\r\n              if (cmp == -1) {\r\n\r\n                // Compare divisor and new remainder.\r\n                // If divisor < new remainder, subtract divisor from remainder.\r\n                // Trial digit n too low.\r\n                // n is 1 too low about 5% of the time, and very rarely 2 too low.\r\n                while (compare(yc, rem, yL, remL) < 1) {\r\n                  n++;\r\n\r\n                  // Subtract divisor from remainder.\r\n                  subtract(rem, yL < remL ? yz : yc, remL, base);\r\n                  remL = rem.length;\r\n                }\r\n              }\r\n            } else if (cmp === 0) {\r\n              n++;\r\n              rem = [0];\r\n            } // else cmp === 1 and n will be 0\r\n\r\n            // Add the next digit, n, to the result array.\r\n            qc[i++] = n;\r\n\r\n            // Update the remainder.\r\n            if (rem[0]) {\r\n              rem[remL++] = xc[xi] || 0;\r\n            } else {\r\n              rem = [xc[xi]];\r\n              remL = 1;\r\n            }\r\n          } while ((xi++ < xL || rem[0] != null) && s--);\r\n\r\n          more = rem[0] != null;\r\n\r\n          // Leading zero?\r\n          if (!qc[0]) qc.splice(0, 1);\r\n        }\r\n\r\n        if (base == BASE) {\r\n\r\n          // To calculate q.e, first get the number of digits of qc[0].\r\n          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);\r\n\r\n          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\r\n\r\n        // Caller is convertBase.\r\n        } else {\r\n          q.e = e;\r\n          q.r = +more;\r\n        }\r\n\r\n        return q;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n     * notation rounded to the specified decimal places or significant digits.\r\n     *\r\n     * n: a BigNumber.\r\n     * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n     * rm: the rounding mode.\r\n     * id: 1 (toExponential) or 2 (toPrecision).\r\n     */\r\n    function format(n, i, rm, id) {\r\n      var c0, e, ne, len, str;\r\n\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      if (!n.c) return n.toString();\r\n\r\n      c0 = n.c[0];\r\n      ne = n.e;\r\n\r\n      if (i == null) {\r\n        str = coeffToString(n.c);\r\n        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)\r\n         ? toExponential(str, ne)\r\n         : toFixedPoint(str, ne, '0');\r\n      } else {\r\n        n = round(new BigNumber(n), i, rm);\r\n\r\n        // n.e may have changed if the value was rounded up.\r\n        e = n.e;\r\n\r\n        str = coeffToString(n.c);\r\n        len = str.length;\r\n\r\n        // toPrecision returns exponential notation if the number of significant digits\r\n        // specified is less than the number of digits necessary to represent the integer\r\n        // part of the value in fixed-point notation.\r\n\r\n        // Exponential notation.\r\n        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\r\n\r\n          // Append zeros?\r\n          for (; len < i; str += '0', len++);\r\n          str = toExponential(str, e);\r\n\r\n        // Fixed-point notation.\r\n        } else {\r\n          i -= ne;\r\n          str = toFixedPoint(str, e, '0');\r\n\r\n          // Append zeros?\r\n          if (e + 1 > len) {\r\n            if (--i > 0) for (str += '.'; i--; str += '0');\r\n          } else {\r\n            i += e - len;\r\n            if (i > 0) {\r\n              if (e + 1 == len) str += '.';\r\n              for (; i--; str += '0');\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return n.s < 0 && c0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // Handle BigNumber.max and BigNumber.min.\r\n    function maxOrMin(args, method) {\r\n      var n,\r\n        i = 1,\r\n        m = new BigNumber(args[0]);\r\n\r\n      for (; i < args.length; i++) {\r\n        n = new BigNumber(args[i]);\r\n\r\n        // If any number is NaN, return NaN.\r\n        if (!n.s) {\r\n          m = n;\r\n          break;\r\n        } else if (method.call(m, n)) {\r\n          m = n;\r\n        }\r\n      }\r\n\r\n      return m;\r\n    }\r\n\r\n\r\n    /*\r\n     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n     * Called by minus, plus and times.\r\n     */\r\n    function normalise(n, c, e) {\r\n      var i = 1,\r\n        j = c.length;\r\n\r\n       // Remove trailing zeros.\r\n      for (; !c[--j]; c.pop());\r\n\r\n      // Calculate the base 10 exponent. First get the number of digits of c[0].\r\n      for (j = c[0]; j >= 10; j /= 10, i++);\r\n\r\n      // Overflow?\r\n      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\r\n\r\n        // Infinity.\r\n        n.c = n.e = null;\r\n\r\n      // Underflow?\r\n      } else if (e < MIN_EXP) {\r\n\r\n        // Zero.\r\n        n.c = [n.e = 0];\r\n      } else {\r\n        n.e = e;\r\n        n.c = c;\r\n      }\r\n\r\n      return n;\r\n    }\r\n\r\n\r\n    // Handle values that fail the validity test in BigNumber.\r\n    parseNumeric = (function () {\r\n      var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i,\r\n        dotAfter = /^([^.]+)\\.$/,\r\n        dotBefore = /^\\.([^.]+)$/,\r\n        isInfinityOrNaN = /^-?(Infinity|NaN)$/,\r\n        whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\r\n\r\n      return function (x, str, isNum, b) {\r\n        var base,\r\n          s = isNum ? str : str.replace(whitespaceOrPlus, '');\r\n\r\n        // No exception on Infinity or NaN.\r\n        if (isInfinityOrNaN.test(s)) {\r\n          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\r\n        } else {\r\n          if (!isNum) {\r\n\r\n            // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\r\n            s = s.replace(basePrefix, function (m, p1, p2) {\r\n              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;\r\n              return !b || b == base ? p1 : m;\r\n            });\r\n\r\n            if (b) {\r\n              base = b;\r\n\r\n              // E.g. '1.' to '1', '.1' to '0.1'\r\n              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');\r\n            }\r\n\r\n            if (str != s) return new BigNumber(s, base);\r\n          }\r\n\r\n          // '[BigNumber Error] Not a number: {n}'\r\n          // '[BigNumber Error] Not a base {b} number: {n}'\r\n          if (BigNumber.DEBUG) {\r\n            throw Error\r\n              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);\r\n          }\r\n\r\n          // NaN\r\n          x.s = null;\r\n        }\r\n\r\n        x.c = x.e = null;\r\n      }\r\n    })();\r\n\r\n\r\n    /*\r\n     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n     * If r is truthy, it is known that there are more digits after the rounding digit.\r\n     */\r\n    function round(x, sd, rm, r) {\r\n      var d, i, j, k, n, ni, rd,\r\n        xc = x.c,\r\n        pows10 = POWS_TEN;\r\n\r\n      // if x is not Infinity or NaN...\r\n      if (xc) {\r\n\r\n        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n        // n is a base 1e14 number, the value of the element of array x.c containing rd.\r\n        // ni is the index of n within x.c.\r\n        // d is the number of digits of n.\r\n        // i is the index of rd within n including leading zeros.\r\n        // j is the actual index of rd within n (if < 0, rd is a leading zero).\r\n        out: {\r\n\r\n          // Get the number of digits of the first element of xc.\r\n          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);\r\n          i = sd - d;\r\n\r\n          // If the rounding digit is in the first element of xc...\r\n          if (i < 0) {\r\n            i += LOG_BASE;\r\n            j = sd;\r\n            n = xc[ni = 0];\r\n\r\n            // Get the rounding digit at index j of n.\r\n            rd = n / pows10[d - j - 1] % 10 | 0;\r\n          } else {\r\n            ni = mathceil((i + 1) / LOG_BASE);\r\n\r\n            if (ni >= xc.length) {\r\n\r\n              if (r) {\r\n\r\n                // Needed by sqrt.\r\n                for (; xc.length <= ni; xc.push(0));\r\n                n = rd = 0;\r\n                d = 1;\r\n                i %= LOG_BASE;\r\n                j = i - LOG_BASE + 1;\r\n              } else {\r\n                break out;\r\n              }\r\n            } else {\r\n              n = k = xc[ni];\r\n\r\n              // Get the number of digits of n.\r\n              for (d = 1; k >= 10; k /= 10, d++);\r\n\r\n              // Get the index of rd within n.\r\n              i %= LOG_BASE;\r\n\r\n              // Get the index of rd within n, adjusted for leading zeros.\r\n              // The number of leading zeros of n is given by LOG_BASE - d.\r\n              j = i - LOG_BASE + d;\r\n\r\n              // Get the rounding digit at index j of n.\r\n              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;\r\n            }\r\n          }\r\n\r\n          r = r || sd < 0 ||\r\n\r\n          // Are there any non-zero digits after the rounding digit?\r\n          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\r\n          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\r\n           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\r\n\r\n          r = rm < 4\r\n           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&\r\n\r\n            // Check whether the digit to the left of the rounding digit is odd.\r\n            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||\r\n             rm == (x.s < 0 ? 8 : 7));\r\n\r\n          if (sd < 1 || !xc[0]) {\r\n            xc.length = 0;\r\n\r\n            if (r) {\r\n\r\n              // Convert sd to decimal places.\r\n              sd -= x.e + 1;\r\n\r\n              // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\r\n              x.e = -sd || 0;\r\n            } else {\r\n\r\n              // Zero.\r\n              xc[0] = x.e = 0;\r\n            }\r\n\r\n            return x;\r\n          }\r\n\r\n          // Remove excess digits.\r\n          if (i == 0) {\r\n            xc.length = ni;\r\n            k = 1;\r\n            ni--;\r\n          } else {\r\n            xc.length = ni + 1;\r\n            k = pows10[LOG_BASE - i];\r\n\r\n            // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n            // j > 0 means i > number of leading zeros of n.\r\n            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\r\n          }\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            for (; ;) {\r\n\r\n              // If the digit to be rounded up is in the first element of xc...\r\n              if (ni == 0) {\r\n\r\n                // i will be the length of xc[0] before k is added.\r\n                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);\r\n                j = xc[0] += k;\r\n                for (k = 1; j >= 10; j /= 10, k++);\r\n\r\n                // if i != k the length has increased.\r\n                if (i != k) {\r\n                  x.e++;\r\n                  if (xc[0] == BASE) xc[0] = 1;\r\n                }\r\n\r\n                break;\r\n              } else {\r\n                xc[ni] += k;\r\n                if (xc[ni] != BASE) break;\r\n                xc[ni--] = 0;\r\n                k = 1;\r\n              }\r\n            }\r\n          }\r\n\r\n          // Remove trailing zeros.\r\n          for (i = xc.length; xc[--i] === 0; xc.pop());\r\n        }\r\n\r\n        // Overflow? Infinity.\r\n        if (x.e > MAX_EXP) {\r\n          x.c = x.e = null;\r\n\r\n        // Underflow? Zero.\r\n        } else if (x.e < MIN_EXP) {\r\n          x.c = [x.e = 0];\r\n        }\r\n      }\r\n\r\n      return x;\r\n    }\r\n\r\n\r\n    function valueOf(n) {\r\n      var str,\r\n        e = n.e;\r\n\r\n      if (e === null) return n.toString();\r\n\r\n      str = coeffToString(n.c);\r\n\r\n      str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n        ? toExponential(str, e)\r\n        : toFixedPoint(str, e, '0');\r\n\r\n      return n.s < 0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // PROTOTYPE/INSTANCE METHODS\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n     */\r\n    P.absoluteValue = P.abs = function () {\r\n      var x = new BigNumber(this);\r\n      if (x.s < 0) x.s = 1;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return\r\n     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     *   0 if they have the same value,\r\n     *   or null if the value of either is NaN.\r\n     */\r\n    P.comparedTo = function (y, b) {\r\n      return compare(this, new BigNumber(y, b));\r\n    };\r\n\r\n\r\n    /*\r\n     * If dp is undefined or null or true or false, return the number of decimal places of the\r\n     * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n     *\r\n     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.decimalPlaces = P.dp = function (dp, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), dp + x.e + 1, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n      // Subtract the number of trailing zeros of the last number.\r\n      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);\r\n      if (n < 0) n = 0;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n / 0 = I\r\n     *  n / N = N\r\n     *  n / I = 0\r\n     *  0 / n = 0\r\n     *  0 / 0 = N\r\n     *  0 / N = N\r\n     *  0 / I = 0\r\n     *  N / n = N\r\n     *  N / 0 = N\r\n     *  N / N = N\r\n     *  N / I = N\r\n     *  I / n = I\r\n     *  I / 0 = I\r\n     *  I / N = N\r\n     *  I / I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.dividedBy = P.div = function (y, b) {\r\n      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n     * BigNumber by the value of BigNumber(y, b).\r\n     */\r\n    P.dividedToIntegerBy = P.idiv = function (y, b) {\r\n      return div(this, new BigNumber(y, b), 0, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n     *\r\n     * If m is present, return the result modulo m.\r\n     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n     *\r\n     * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n     *\r\n     * n {number|string|BigNumber} The exponent. An integer.\r\n     * [m] {number|string|BigNumber} The modulus.\r\n     *\r\n     * '[BigNumber Error] Exponent not an integer: {n}'\r\n     */\r\n    P.exponentiatedBy = P.pow = function (n, m) {\r\n      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,\r\n        x = this;\r\n\r\n      n = new BigNumber(n);\r\n\r\n      // Allow NaN and Infinity, but not other non-integers.\r\n      if (n.c && !n.isInteger()) {\r\n        throw Error\r\n          (bignumberError + 'Exponent not an integer: ' + valueOf(n));\r\n      }\r\n\r\n      if (m != null) m = new BigNumber(m);\r\n\r\n      // Exponent of MAX_SAFE_INTEGER is 15.\r\n      nIsBig = n.e > 14;\r\n\r\n      // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.\r\n      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\r\n\r\n        // The sign of the result of pow when x is negative depends on the evenness of n.\r\n        // If +n overflows to Infinity, the evenness of n would be not be known.\r\n        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));\r\n        return m ? y.mod(m) : y;\r\n      }\r\n\r\n      nIsNeg = n.s < 0;\r\n\r\n      if (m) {\r\n\r\n        // x % m returns NaN if abs(m) is zero, or m is NaN.\r\n        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\r\n\r\n        isModExp = !nIsNeg && x.isInteger() && m.isInteger();\r\n\r\n        if (isModExp) x = x.mod(m);\r\n\r\n      // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.\r\n      // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.\r\n      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0\r\n        // [1, 240000000]\r\n        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7\r\n        // [80000000000000]  [99999750000000]\r\n        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\r\n\r\n        // If x is negative and n is odd, k = -0, else k = 0.\r\n        k = x.s < 0 && isOdd(n) ? -0 : 0;\r\n\r\n        // If x >= 1, k = Infinity.\r\n        if (x.e > -1) k = 1 / k;\r\n\r\n        // If n is negative return 0, else return Infinity.\r\n        return new BigNumber(nIsNeg ? 1 / k : k);\r\n\r\n      } else if (POW_PRECISION) {\r\n\r\n        // Truncating each coefficient array to a length of k after each multiplication\r\n        // equates to truncating significant digits to POW_PRECISION + [28, 41],\r\n        // i.e. there will be a minimum of 28 guard digits retained.\r\n        k = mathceil(POW_PRECISION / LOG_BASE + 2);\r\n      }\r\n\r\n      if (nIsBig) {\r\n        half = new BigNumber(0.5);\r\n        if (nIsNeg) n.s = 1;\r\n        nIsOdd = isOdd(n);\r\n      } else {\r\n        i = Math.abs(+valueOf(n));\r\n        nIsOdd = i % 2;\r\n      }\r\n\r\n      y = new BigNumber(ONE);\r\n\r\n      // Performs 54 loop iterations for n of 9007199254740991.\r\n      for (; ;) {\r\n\r\n        if (nIsOdd) {\r\n          y = y.times(x);\r\n          if (!y.c) break;\r\n\r\n          if (k) {\r\n            if (y.c.length > k) y.c.length = k;\r\n          } else if (isModExp) {\r\n            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\r\n          }\r\n        }\r\n\r\n        if (i) {\r\n          i = mathfloor(i / 2);\r\n          if (i === 0) break;\r\n          nIsOdd = i % 2;\r\n        } else {\r\n          n = n.times(half);\r\n          round(n, n.e + 1, 1);\r\n\r\n          if (n.e > 14) {\r\n            nIsOdd = isOdd(n);\r\n          } else {\r\n            i = +valueOf(n);\r\n            if (i === 0) break;\r\n            nIsOdd = i % 2;\r\n          }\r\n        }\r\n\r\n        x = x.times(x);\r\n\r\n        if (k) {\r\n          if (x.c && x.c.length > k) x.c.length = k;\r\n        } else if (isModExp) {\r\n          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\r\n        }\r\n      }\r\n\r\n      if (isModExp) return y;\r\n      if (nIsNeg) y = ONE.div(y);\r\n\r\n      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n     */\r\n    P.integerValue = function (rm) {\r\n      var n = new BigNumber(this);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n      return round(n, n.e + 1, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isEqualTo = P.eq = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n     */\r\n    P.isFinite = function () {\r\n      return !!this.c;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isGreaterThan = P.gt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\r\n\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n     */\r\n    P.isInteger = function () {\r\n      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isLessThan = P.lt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isLessThanOrEqualTo = P.lte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n     */\r\n    P.isNaN = function () {\r\n      return !this.s;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is negative, otherwise return false.\r\n     */\r\n    P.isNegative = function () {\r\n      return this.s < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is positive, otherwise return false.\r\n     */\r\n    P.isPositive = function () {\r\n      return this.s > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n     */\r\n    P.isZero = function () {\r\n      return !!this.c && this.c[0] == 0;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n - 0 = n\r\n     *  n - N = N\r\n     *  n - I = -I\r\n     *  0 - n = -n\r\n     *  0 - 0 = 0\r\n     *  0 - N = N\r\n     *  0 - I = -I\r\n     *  N - n = N\r\n     *  N - 0 = N\r\n     *  N - N = N\r\n     *  N - I = N\r\n     *  I - n = I\r\n     *  I - 0 = I\r\n     *  I - N = N\r\n     *  I - I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.minus = function (y, b) {\r\n      var i, j, t, xLTy,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n      if (a != b) {\r\n        y.s = -b;\r\n        return x.plus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Either Infinity?\r\n        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\r\n\r\n        // Either zero?\r\n        if (!xc[0] || !yc[0]) {\r\n\r\n          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :\r\n\r\n           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\r\n           ROUNDING_MODE == 3 ? -0 : 0);\r\n        }\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Determine which is the bigger number.\r\n      if (a = xe - ye) {\r\n\r\n        if (xLTy = a < 0) {\r\n          a = -a;\r\n          t = xc;\r\n        } else {\r\n          ye = xe;\r\n          t = yc;\r\n        }\r\n\r\n        t.reverse();\r\n\r\n        // Prepend zeros to equalise exponents.\r\n        for (b = a; b--; t.push(0));\r\n        t.reverse();\r\n      } else {\r\n\r\n        // Exponents equal. Check digit by digit.\r\n        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\r\n\r\n        for (a = b = 0; b < j; b++) {\r\n\r\n          if (xc[b] != yc[b]) {\r\n            xLTy = xc[b] < yc[b];\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // x < y? Point xc to the array of the bigger number.\r\n      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;\r\n\r\n      b = (j = yc.length) - (i = xc.length);\r\n\r\n      // Append zeros to xc if shorter.\r\n      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\r\n      if (b > 0) for (; b--; xc[i++] = 0);\r\n      b = BASE - 1;\r\n\r\n      // Subtract yc from xc.\r\n      for (; j > a;) {\r\n\r\n        if (xc[--j] < yc[j]) {\r\n          for (i = j; i && !xc[--i]; xc[i] = b);\r\n          --xc[i];\r\n          xc[j] += BASE;\r\n        }\r\n\r\n        xc[j] -= yc[j];\r\n      }\r\n\r\n      // Remove leading zeros and adjust exponent accordingly.\r\n      for (; xc[0] == 0; xc.splice(0, 1), --ye);\r\n\r\n      // Zero?\r\n      if (!xc[0]) {\r\n\r\n        // Following IEEE 754 (2008) 6.3,\r\n        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\r\n        y.s = ROUNDING_MODE == 3 ? -1 : 1;\r\n        y.c = [y.e = 0];\r\n        return y;\r\n      }\r\n\r\n      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\r\n      // for finite x and y.\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     *   n % 0 =  N\r\n     *   n % N =  N\r\n     *   n % I =  n\r\n     *   0 % n =  0\r\n     *  -0 % n = -0\r\n     *   0 % 0 =  N\r\n     *   0 % N =  N\r\n     *   0 % I =  0\r\n     *   N % n =  N\r\n     *   N % 0 =  N\r\n     *   N % N =  N\r\n     *   N % I =  N\r\n     *   I % n =  N\r\n     *   I % 0 =  N\r\n     *   I % N =  N\r\n     *   I % I =  N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n     * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n     */\r\n    P.modulo = P.mod = function (y, b) {\r\n      var q, s,\r\n        x = this;\r\n\r\n      y = new BigNumber(y, b);\r\n\r\n      // Return NaN if x is Infinity or NaN, or y is NaN or zero.\r\n      if (!x.c || !y.s || y.c && !y.c[0]) {\r\n        return new BigNumber(NaN);\r\n\r\n      // Return x if y is Infinity or x is zero.\r\n      } else if (!y.c || x.c && !x.c[0]) {\r\n        return new BigNumber(x);\r\n      }\r\n\r\n      if (MODULO_MODE == 9) {\r\n\r\n        // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n        // r = x - qy    where  0 <= r < abs(y)\r\n        s = y.s;\r\n        y.s = 1;\r\n        q = div(x, y, 0, 3);\r\n        y.s = s;\r\n        q.s *= s;\r\n      } else {\r\n        q = div(x, y, 0, MODULO_MODE);\r\n      }\r\n\r\n      y = x.minus(q.times(y));\r\n\r\n      // To match JavaScript %, ensure sign of zero is sign of dividend.\r\n      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\r\n\r\n      return y;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n * 0 = 0\r\n     *  n * N = N\r\n     *  n * I = I\r\n     *  0 * n = 0\r\n     *  0 * 0 = 0\r\n     *  0 * N = N\r\n     *  0 * I = N\r\n     *  N * n = N\r\n     *  N * 0 = N\r\n     *  N * N = N\r\n     *  N * I = N\r\n     *  I * n = I\r\n     *  I * 0 = N\r\n     *  I * N = N\r\n     *  I * I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n     * of BigNumber(y, b).\r\n     */\r\n    P.multipliedBy = P.times = function (y, b) {\r\n      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,\r\n        base, sqrtBase,\r\n        x = this,\r\n        xc = x.c,\r\n        yc = (y = new BigNumber(y, b)).c;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xc || !yc || !xc[0] || !yc[0]) {\r\n\r\n        // Return NaN if either is NaN, or one is 0 and the other is Infinity.\r\n        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\r\n          y.c = y.e = y.s = null;\r\n        } else {\r\n          y.s *= x.s;\r\n\r\n          // Return Infinity if either is Infinity.\r\n          if (!xc || !yc) {\r\n            y.c = y.e = null;\r\n\r\n          // Return 0 if either is 0.\r\n          } else {\r\n            y.c = [0];\r\n            y.e = 0;\r\n          }\r\n        }\r\n\r\n        return y;\r\n      }\r\n\r\n      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\r\n      y.s *= x.s;\r\n      xcL = xc.length;\r\n      ycL = yc.length;\r\n\r\n      // Ensure xc points to longer array and xcL to its length.\r\n      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;\r\n\r\n      // Initialise the result array with zeros.\r\n      for (i = xcL + ycL, zc = []; i--; zc.push(0));\r\n\r\n      base = BASE;\r\n      sqrtBase = SQRT_BASE;\r\n\r\n      for (i = ycL; --i >= 0;) {\r\n        c = 0;\r\n        ylo = yc[i] % sqrtBase;\r\n        yhi = yc[i] / sqrtBase | 0;\r\n\r\n        for (k = xcL, j = i + k; j > i;) {\r\n          xlo = xc[--k] % sqrtBase;\r\n          xhi = xc[k] / sqrtBase | 0;\r\n          m = yhi * xlo + xhi * ylo;\r\n          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;\r\n          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\r\n          zc[j--] = xlo % base;\r\n        }\r\n\r\n        zc[j] = c;\r\n      }\r\n\r\n      if (c) {\r\n        ++e;\r\n      } else {\r\n        zc.splice(0, 1);\r\n      }\r\n\r\n      return normalise(y, zc, e);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n     * i.e. multiplied by -1.\r\n     */\r\n    P.negated = function () {\r\n      var x = new BigNumber(this);\r\n      x.s = -x.s || null;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n + 0 = n\r\n     *  n + N = N\r\n     *  n + I = I\r\n     *  0 + n = n\r\n     *  0 + 0 = 0\r\n     *  0 + N = N\r\n     *  0 + I = I\r\n     *  N + n = N\r\n     *  N + 0 = N\r\n     *  N + N = N\r\n     *  N + I = N\r\n     *  I + n = I\r\n     *  I + 0 = I\r\n     *  I + N = N\r\n     *  I + I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.plus = function (y, b) {\r\n      var t,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n       if (a != b) {\r\n        y.s = -b;\r\n        return x.minus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Return Infinity if either Infinity.\r\n        if (!xc || !yc) return new BigNumber(a / 0);\r\n\r\n        // Either zero?\r\n        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\r\n      if (a = xe - ye) {\r\n        if (a > 0) {\r\n          ye = xe;\r\n          t = yc;\r\n        } else {\r\n          a = -a;\r\n          t = xc;\r\n        }\r\n\r\n        t.reverse();\r\n        for (; a--; t.push(0));\r\n        t.reverse();\r\n      }\r\n\r\n      a = xc.length;\r\n      b = yc.length;\r\n\r\n      // Point xc to the longer array, and b to the shorter length.\r\n      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;\r\n\r\n      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\r\n      for (a = 0; b;) {\r\n        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\r\n        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\r\n      }\r\n\r\n      if (a) {\r\n        xc = [a].concat(xc);\r\n        ++ye;\r\n      }\r\n\r\n      // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n      // ye = MAX_EXP + 1 possible\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     * If sd is undefined or null or true or false, return the number of significant digits of\r\n     * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n     * If sd is true include integer-part trailing zeros in the count.\r\n     *\r\n     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n     *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.precision = P.sd = function (sd, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (sd != null && sd !== !!sd) {\r\n        intCheck(sd, 1, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), sd, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      v = c.length - 1;\r\n      n = v * LOG_BASE + 1;\r\n\r\n      if (v = c[v]) {\r\n\r\n        // Subtract the number of trailing zeros of the last element.\r\n        for (; v % 10 == 0; v /= 10, n--);\r\n\r\n        // Add the number of digits of the first element.\r\n        for (v = c[0]; v >= 10; v /= 10, n++);\r\n      }\r\n\r\n      if (sd && x.e + 1 > n) n = x.e + 1;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n     *\r\n     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n     */\r\n    P.shiftedBy = function (k) {\r\n      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\r\n      return this.times('1e' + k);\r\n    };\r\n\r\n\r\n    /*\r\n     *  sqrt(-n) =  N\r\n     *  sqrt(N) =  N\r\n     *  sqrt(-I) =  N\r\n     *  sqrt(I) =  I\r\n     *  sqrt(0) =  0\r\n     *  sqrt(-0) = -0\r\n     *\r\n     * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.squareRoot = P.sqrt = function () {\r\n      var m, n, r, rep, t,\r\n        x = this,\r\n        c = x.c,\r\n        s = x.s,\r\n        e = x.e,\r\n        dp = DECIMAL_PLACES + 4,\r\n        half = new BigNumber('0.5');\r\n\r\n      // Negative/NaN/Infinity/zero?\r\n      if (s !== 1 || !c || !c[0]) {\r\n        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\r\n      }\r\n\r\n      // Initial estimate.\r\n      s = Math.sqrt(+valueOf(x));\r\n\r\n      // Math.sqrt underflow/overflow?\r\n      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n      if (s == 0 || s == 1 / 0) {\r\n        n = coeffToString(c);\r\n        if ((n.length + e) % 2 == 0) n += '0';\r\n        s = Math.sqrt(+n);\r\n        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n        if (s == 1 / 0) {\r\n          n = '5e' + e;\r\n        } else {\r\n          n = s.toExponential();\r\n          n = n.slice(0, n.indexOf('e') + 1) + e;\r\n        }\r\n\r\n        r = new BigNumber(n);\r\n      } else {\r\n        r = new BigNumber(s + '');\r\n      }\r\n\r\n      // Check for zero.\r\n      // r could be zero if MIN_EXP is changed after the this value was created.\r\n      // This would cause a division by zero (x/t) and hence Infinity below, which would cause\r\n      // coeffToString to throw.\r\n      if (r.c[0]) {\r\n        e = r.e;\r\n        s = e + dp;\r\n        if (s < 3) s = 0;\r\n\r\n        // Newton-Raphson iteration.\r\n        for (; ;) {\r\n          t = r;\r\n          r = half.times(t.plus(div(x, t, dp, 1)));\r\n\r\n          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\r\n\r\n            // The exponent of r may here be one less than the final result exponent,\r\n            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\r\n            // are indexed correctly.\r\n            if (r.e < e) --s;\r\n            n = n.slice(s - 3, s + 1);\r\n\r\n            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\r\n            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\r\n            // iteration.\r\n            if (n == '9999' || !rep && n == '4999') {\r\n\r\n              // On the first iteration only, check to see if rounding up gives the\r\n              // exact result as the nines may infinitely repeat.\r\n              if (!rep) {\r\n                round(t, t.e + DECIMAL_PLACES + 2, 0);\r\n\r\n                if (t.times(t).eq(x)) {\r\n                  r = t;\r\n                  break;\r\n                }\r\n              }\r\n\r\n              dp += 4;\r\n              s += 4;\r\n              rep = 1;\r\n            } else {\r\n\r\n              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\r\n              // result. If not, then there are further digits and m will be truthy.\r\n              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n                // Truncate to the first rounding digit.\r\n                round(r, r.e + DECIMAL_PLACES + 2, 1);\r\n                m = !r.times(r).eq(x);\r\n              }\r\n\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in exponential notation and\r\n     * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toExponential = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp++;\r\n      }\r\n      return format(this, dp, rm, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n     * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toFixed = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp = dp + this.e + 1;\r\n      }\r\n      return format(this, dp, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n     * of the format or FORMAT object (see BigNumber.set).\r\n     *\r\n     * The formatting object may contain some or all of the properties shown below.\r\n     *\r\n     * FORMAT = {\r\n     *   prefix: '',\r\n     *   groupSize: 3,\r\n     *   secondaryGroupSize: 0,\r\n     *   groupSeparator: ',',\r\n     *   decimalSeparator: '.',\r\n     *   fractionGroupSize: 0,\r\n     *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n     *   suffix: ''\r\n     * };\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     * [format] {object} Formatting options. See FORMAT pbject above.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     * '[BigNumber Error] Argument not an object: {format}'\r\n     */\r\n    P.toFormat = function (dp, rm, format) {\r\n      var str,\r\n        x = this;\r\n\r\n      if (format == null) {\r\n        if (dp != null && rm && typeof rm == 'object') {\r\n          format = rm;\r\n          rm = null;\r\n        } else if (dp && typeof dp == 'object') {\r\n          format = dp;\r\n          dp = rm = null;\r\n        } else {\r\n          format = FORMAT;\r\n        }\r\n      } else if (typeof format != 'object') {\r\n        throw Error\r\n          (bignumberError + 'Argument not an object: ' + format);\r\n      }\r\n\r\n      str = x.toFixed(dp, rm);\r\n\r\n      if (x.c) {\r\n        var i,\r\n          arr = str.split('.'),\r\n          g1 = +format.groupSize,\r\n          g2 = +format.secondaryGroupSize,\r\n          groupSeparator = format.groupSeparator || '',\r\n          intPart = arr[0],\r\n          fractionPart = arr[1],\r\n          isNeg = x.s < 0,\r\n          intDigits = isNeg ? intPart.slice(1) : intPart,\r\n          len = intDigits.length;\r\n\r\n        if (g2) i = g1, g1 = g2, g2 = i, len -= i;\r\n\r\n        if (g1 > 0 && len > 0) {\r\n          i = len % g1 || g1;\r\n          intPart = intDigits.substr(0, i);\r\n          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);\r\n          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\r\n          if (isNeg) intPart = '-' + intPart;\r\n        }\r\n\r\n        str = fractionPart\r\n         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)\r\n          ? fractionPart.replace(new RegExp('\\\\d{' + g2 + '}\\\\B', 'g'),\r\n           '$&' + (format.fractionGroupSeparator || ''))\r\n          : fractionPart)\r\n         : intPart;\r\n      }\r\n\r\n      return (format.prefix || '') + str + (format.suffix || '');\r\n    };\r\n\r\n\r\n    /*\r\n     * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n     * fraction with an integer numerator and an integer denominator.\r\n     * The denominator will be a positive non-zero value less than or equal to the specified\r\n     * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n     * the lowest value necessary to represent the number exactly.\r\n     *\r\n     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n     *\r\n     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n     */\r\n    P.toFraction = function (md) {\r\n      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,\r\n        x = this,\r\n        xc = x.c;\r\n\r\n      if (md != null) {\r\n        n = new BigNumber(md);\r\n\r\n        // Throw if md is less than one or is not an integer, unless it is Infinity.\r\n        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\r\n          throw Error\r\n            (bignumberError + 'Argument ' +\r\n              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));\r\n        }\r\n      }\r\n\r\n      if (!xc) return new BigNumber(x);\r\n\r\n      d = new BigNumber(ONE);\r\n      n1 = d0 = new BigNumber(ONE);\r\n      d1 = n0 = new BigNumber(ONE);\r\n      s = coeffToString(xc);\r\n\r\n      // Determine initial denominator.\r\n      // d is a power of 10 and the minimum max denominator that specifies the value exactly.\r\n      e = d.e = s.length - x.e - 1;\r\n      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\r\n      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;\r\n\r\n      exp = MAX_EXP;\r\n      MAX_EXP = 1 / 0;\r\n      n = new BigNumber(s);\r\n\r\n      // n0 = d1 = 0\r\n      n0.c[0] = 0;\r\n\r\n      for (; ;)  {\r\n        q = div(n, d, 0, 1);\r\n        d2 = d0.plus(q.times(d1));\r\n        if (d2.comparedTo(md) == 1) break;\r\n        d0 = d1;\r\n        d1 = d2;\r\n        n1 = n0.plus(q.times(d2 = n1));\r\n        n0 = d2;\r\n        d = n.minus(q.times(d2 = d));\r\n        n = d2;\r\n      }\r\n\r\n      d2 = div(md.minus(d0), d1, 0, 1);\r\n      n0 = n0.plus(d2.times(n1));\r\n      d0 = d0.plus(d2.times(d1));\r\n      n0.s = n1.s = x.s;\r\n      e = e * 2;\r\n\r\n      // Determine which fraction is closer to x, n0/d0 or n1/d1\r\n      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(\r\n          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\r\n\r\n      MAX_EXP = exp;\r\n\r\n      return r;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return the value of this BigNumber converted to a number primitive.\r\n     */\r\n    P.toNumber = function () {\r\n      return +valueOf(this);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n     * necessary to represent the integer part of the value in fixed-point notation, then use\r\n     * exponential notation.\r\n     *\r\n     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.toPrecision = function (sd, rm) {\r\n      if (sd != null) intCheck(sd, 1, MAX);\r\n      return format(this, sd, rm, 2);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n     * TO_EXP_NEG, return exponential notation.\r\n     *\r\n     * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n     *\r\n     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n     */\r\n    P.toString = function (b) {\r\n      var str,\r\n        n = this,\r\n        s = n.s,\r\n        e = n.e;\r\n\r\n      // Infinity or NaN?\r\n      if (e === null) {\r\n        if (s) {\r\n          str = 'Infinity';\r\n          if (s < 0) str = '-' + str;\r\n        } else {\r\n          str = 'NaN';\r\n        }\r\n      } else {\r\n        if (b == null) {\r\n          str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n           ? toExponential(coeffToString(n.c), e)\r\n           : toFixedPoint(coeffToString(n.c), e, '0');\r\n        } else if (b === 10) {\r\n          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\r\n          str = toFixedPoint(coeffToString(n.c), n.e, '0');\r\n        } else {\r\n          intCheck(b, 2, ALPHABET.length, 'Base');\r\n          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);\r\n        }\r\n\r\n        if (s < 0 && n.c[0]) str = '-' + str;\r\n      }\r\n\r\n      return str;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return as toString, but do not accept a base argument, and include the minus sign for\r\n     * negative zero.\r\n     */\r\n    P.valueOf = P.toJSON = function () {\r\n      return valueOf(this);\r\n    };\r\n\r\n\r\n    P._isBigNumber = true;\r\n\r\n    if (configObject != null) BigNumber.set(configObject);\r\n\r\n    return BigNumber;\r\n  }\r\n\r\n\r\n  // PRIVATE HELPER FUNCTIONS\r\n\r\n  // These functions don't need access to variables,\r\n  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\r\n\r\n\r\n  function bitFloor(n) {\r\n    var i = n | 0;\r\n    return n > 0 || n === i ? i : i - 1;\r\n  }\r\n\r\n\r\n  // Return a coefficient array as a string of base 10 digits.\r\n  function coeffToString(a) {\r\n    var s, z,\r\n      i = 1,\r\n      j = a.length,\r\n      r = a[0] + '';\r\n\r\n    for (; i < j;) {\r\n      s = a[i++] + '';\r\n      z = LOG_BASE - s.length;\r\n      for (; z--; s = '0' + s);\r\n      r += s;\r\n    }\r\n\r\n    // Determine trailing zeros.\r\n    for (j = r.length; r.charCodeAt(--j) === 48;);\r\n\r\n    return r.slice(0, j + 1 || 1);\r\n  }\r\n\r\n\r\n  // Compare the value of BigNumbers x and y.\r\n  function compare(x, y) {\r\n    var a, b,\r\n      xc = x.c,\r\n      yc = y.c,\r\n      i = x.s,\r\n      j = y.s,\r\n      k = x.e,\r\n      l = y.e;\r\n\r\n    // Either NaN?\r\n    if (!i || !j) return null;\r\n\r\n    a = xc && !xc[0];\r\n    b = yc && !yc[0];\r\n\r\n    // Either zero?\r\n    if (a || b) return a ? b ? 0 : -j : i;\r\n\r\n    // Signs differ?\r\n    if (i != j) return i;\r\n\r\n    a = i < 0;\r\n    b = k == l;\r\n\r\n    // Either Infinity?\r\n    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\r\n\r\n    // Compare exponents.\r\n    if (!b) return k > l ^ a ? 1 : -1;\r\n\r\n    j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n    // Compare digit by digit.\r\n    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\r\n\r\n    // Compare lengths.\r\n    return k == l ? 0 : k > l ^ a ? 1 : -1;\r\n  }\r\n\r\n\r\n  /*\r\n   * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n   */\r\n  function intCheck(n, min, max, name) {\r\n    if (n < min || n > max || n !== mathfloor(n)) {\r\n      throw Error\r\n       (bignumberError + (name || 'Argument') + (typeof n == 'number'\r\n         ? n < min || n > max ? ' out of range: ' : ' not an integer: '\r\n         : ' not a primitive number: ') + String(n));\r\n    }\r\n  }\r\n\r\n\r\n  // Assumes finite n.\r\n  function isOdd(n) {\r\n    var k = n.c.length - 1;\r\n    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\r\n  }\r\n\r\n\r\n  function toExponential(str, e) {\r\n    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +\r\n     (e < 0 ? 'e' : 'e+') + e;\r\n  }\r\n\r\n\r\n  function toFixedPoint(str, e, z) {\r\n    var len, zs;\r\n\r\n    // Negative exponent?\r\n    if (e < 0) {\r\n\r\n      // Prepend zeros.\r\n      for (zs = z + '.'; ++e; zs += z);\r\n      str = zs + str;\r\n\r\n    // Positive exponent\r\n    } else {\r\n      len = str.length;\r\n\r\n      // Append zeros.\r\n      if (++e > len) {\r\n        for (zs = z, e -= len; --e; zs += z);\r\n        str += zs;\r\n      } else if (e < len) {\r\n        str = str.slice(0, e) + '.' + str.slice(e);\r\n      }\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n\r\n  // EXPORT\r\n\r\n\r\n  BigNumber = clone();\r\n  BigNumber['default'] = BigNumber.BigNumber = BigNumber;\r\n\r\n  // AMD.\r\n  if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return BigNumber; }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\r\n  // Node.js and other environments that support module.exports.\r\n  } else {}\r\n})(this);\r\n\n\n//# sourceURL=webpack:///./node_modules/bignumber.js/bignumber.js?");

/***/ }),

/***/ "./node_modules/blake2b-wasm/blake2b.js":
/*!**********************************************!*\
  !*** ./node_modules/blake2b-wasm/blake2b.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nmodule.exports = loadWebAssembly\n\nloadWebAssembly.supported = typeof WebAssembly !== 'undefined'\n\nfunction loadWebAssembly (opts) {\n  if (!loadWebAssembly.supported) return null\n\n  var imp = opts && opts.imports\n  var wasm = toUint8Array('AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMK00AElgMAIABCADcDACAAQQhqQgA3AwAgAEEQakIANwMAIABBGGpCADcDACAAQSBqQgA3AwAgAEEoakIANwMAIABBMGpCADcDACAAQThqQgA3AwAgAEHAAGpCADcDACAAQcgAakIANwMAIABB0ABqQgA3AwAgAEHYAGpCADcDACAAQeAAakIANwMAIABB6ABqQgA3AwAgAEHwAGpCADcDACAAQfgAakIANwMAIABBgAFqQoiS853/zPmE6gBBACkDAIU3AwAgAEGIAWpCu86qptjQ67O7f0EIKQMAhTcDACAAQZABakKr8NP0r+68tzxBECkDAIU3AwAgAEGYAWpC8e30+KWn/aelf0EYKQMAhTcDACAAQaABakLRhZrv+s+Uh9EAQSApAwCFNwMAIABBqAFqQp/Y+dnCkdqCm39BKCkDAIU3AwAgAEGwAWpC6/qG2r+19sEfQTApAwCFNwMAIABBuAFqQvnC+JuRo7Pw2wBBOCkDAIU3AwAgAEHAAWpCADcDACAAQcgBakIANwMAIABB0AFqQgA3AwALbQEDfyAAQcABaiEDIABByAFqIQQgBCkDAKchBQJAA0AgASACRg0BIAVBgAFGBEAgAyADKQMAIAWtfDcDAEEAIQUgABADCyAAIAVqIAEtAAA6AAAgBUEBaiEFIAFBAWohAQwACwsgBCAFrTcDAAtkAQN/IABBwAFqIQEgAEHIAWohAiABIAEpAwAgAikDAHw3AwAgAEHQAWpCfzcDACACKQMApyEDAkADQCADQYABRg0BIAAgA2pBADoAACADQQFqIQMMAAsLIAIgA603AwAgABADC+U7AiB+CX8gAEGAAWohISAAQYgBaiEiIABBkAFqISMgAEGYAWohJCAAQaABaiElIABBqAFqISYgAEGwAWohJyAAQbgBaiEoICEpAwAhASAiKQMAIQIgIykDACEDICQpAwAhBCAlKQMAIQUgJikDACEGICcpAwAhByAoKQMAIQhCiJLznf/M+YTqACEJQrvOqqbY0Ouzu38hCkKr8NP0r+68tzwhC0Lx7fT4paf9p6V/IQxC0YWa7/rPlIfRACENQp/Y+dnCkdqCm38hDkLr+obav7X2wR8hD0L5wvibkaOz8NsAIRAgACkDACERIABBCGopAwAhEiAAQRBqKQMAIRMgAEEYaikDACEUIABBIGopAwAhFSAAQShqKQMAIRYgAEEwaikDACEXIABBOGopAwAhGCAAQcAAaikDACEZIABByABqKQMAIRogAEHQAGopAwAhGyAAQdgAaikDACEcIABB4ABqKQMAIR0gAEHoAGopAwAhHiAAQfAAaikDACEfIABB+ABqKQMAISAgDSAAQcABaikDAIUhDSAPIABB0AFqKQMAhSEPIAEgBSARfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBN8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAUfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgFXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBZ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAXfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBl8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAafHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgG3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBx8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAdfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHnx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB98fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAgfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgH3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBt8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAVfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBp8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAgfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggHnx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBd8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiASfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBF8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByATfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBh8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAWfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBx8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAZfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgHXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBF8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAWfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgE3x8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIICB8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAefHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgG3x8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB98fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAUfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgF3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBh8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCASfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgGnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBV8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAYfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgGnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBR8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiASfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgHnx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB18fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAcfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggH3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBN8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAXfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgFnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBt8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAVfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggEXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFICB8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAZfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgGnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBF8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAWfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBN8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAVfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggG3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIICB8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAffHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBx8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAdfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggF3x8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBl8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAUfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgHnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBN8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAdfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgF3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBt8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByARfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBl8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAUfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgFXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB58fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAYfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgFnx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIICB8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAffHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgEnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBp8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAdfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgFnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBJ8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAgfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgH3x8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB58fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAVfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggG3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBF8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAYfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgF3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBR8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAafHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggE3x8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBl8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAcfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgHnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBx8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAYfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgH3x8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIB18fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByASfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggFHx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBp8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAWfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHICB8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAVfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggGXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBd8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSATfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgG3x8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBd8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAgfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgH3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBp8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAcfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgFHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBF8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAZfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgHXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBN8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAefHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgGHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBJ8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAVfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgG3x8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBZ8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAbfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgE3x8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBl8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAVfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgGHx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBd8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCASfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggFnx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGICB8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAcfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgGnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIB98fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAUfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB58fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSARfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgEXx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBJ8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiATfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgFHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBV8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAWfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggF3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBh8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAZfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgGnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBt8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAcfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIB58fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAffHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgIHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIB98fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAbfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgFXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBl8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAafHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgIHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIB58fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAXfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgEnx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB18fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByARfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgE3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBx8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAYfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgFnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBR8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFICEgISkDACABIAmFhTcDACAiICIpAwAgAiAKhYU3AwAgIyAjKQMAIAMgC4WFNwMAICQgJCkDACAEIAyFhTcDACAlICUpAwAgBSANhYU3AwAgJiAmKQMAIAYgDoWFNwMAICcgJykDACAHIA+FhTcDACAoICgpAwAgCCAQhYU3AwAL')\n  var ready = null\n\n  var mod = {\n    buffer: wasm,\n    memory: null,\n    exports: null,\n    realloc: realloc,\n    onload: onload\n  }\n\n  onload(function () {})\n\n  return mod\n\n  function realloc (size) {\n    mod.exports.memory.grow(Math.ceil(Math.abs(size - mod.memory.length) / 65536))\n    mod.memory = new Uint8Array(mod.exports.memory.buffer)\n  }\n\n  function onload (cb) {\n    if (mod.exports) return cb()\n\n    if (ready) {\n      ready.then(cb.bind(null, null)).catch(cb)\n      return\n    }\n\n    try {\n      if (opts && opts.async) throw new Error('async')\n      setup({instance: new WebAssembly.Instance(new WebAssembly.Module(wasm), imp)})\n    } catch (err) {\n      ready = WebAssembly.instantiate(wasm, imp).then(setup)\n    }\n\n    onload(cb)\n  }\n\n  function setup (w) {\n    mod.exports = w.instance.exports\n    mod.memory = mod.exports.memory && mod.exports.memory.buffer && new Uint8Array(mod.exports.memory.buffer)\n  }\n}\n\nfunction toUint8Array (s) {\n  if (typeof atob === 'function') return new Uint8Array(atob(s).split('').map(charCodeAt))\n  return new (__webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer)(s, 'base64')\n}\n\nfunction charCodeAt (c) {\n  return c.charCodeAt(0)\n}\n\n\n//# sourceURL=webpack:///./node_modules/blake2b-wasm/blake2b.js?");

/***/ }),

/***/ "./node_modules/blake2b-wasm/index.js":
/*!********************************************!*\
  !*** ./node_modules/blake2b-wasm/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var assert = __webpack_require__(/*! nanoassert */ \"./node_modules/nanoassert/index.js\")\nvar wasm = __webpack_require__(/*! ./blake2b */ \"./node_modules/blake2b-wasm/blake2b.js\")()\n\nvar head = 64\nvar freeList = []\n\nmodule.exports = Blake2b\nvar BYTES_MIN = module.exports.BYTES_MIN = 16\nvar BYTES_MAX = module.exports.BYTES_MAX = 64\nvar BYTES = module.exports.BYTES = 32\nvar KEYBYTES_MIN = module.exports.KEYBYTES_MIN = 16\nvar KEYBYTES_MAX = module.exports.KEYBYTES_MAX = 64\nvar KEYBYTES = module.exports.KEYBYTES = 32\nvar SALTBYTES = module.exports.SALTBYTES = 16\nvar PERSONALBYTES = module.exports.PERSONALBYTES = 16\n\nfunction Blake2b (digestLength, key, salt, personal, noAssert) {\n  if (!(this instanceof Blake2b)) return new Blake2b(digestLength, key, salt, personal, noAssert)\n  if (!(wasm && wasm.exports)) throw new Error('WASM not loaded. Wait for Blake2b.ready(cb)')\n  if (!digestLength) digestLength = 32\n\n  if (noAssert !== true) {\n    assert(digestLength >= BYTES_MIN, 'digestLength must be at least ' + BYTES_MIN + ', was given ' + digestLength)\n    assert(digestLength <= BYTES_MAX, 'digestLength must be at most ' + BYTES_MAX + ', was given ' + digestLength)\n    if (key != null) assert(key.length >= KEYBYTES_MIN, 'key must be at least ' + KEYBYTES_MIN + ', was given ' + key.length)\n    if (key != null) assert(key.length <= KEYBYTES_MAX, 'key must be at least ' + KEYBYTES_MAX + ', was given ' + key.length)\n    if (salt != null) assert(salt.length === SALTBYTES, 'salt must be exactly ' + SALTBYTES + ', was given ' + salt.length)\n    if (personal != null) assert(personal.length === PERSONALBYTES, 'personal must be exactly ' + PERSONALBYTES + ', was given ' + personal.length)\n  }\n\n  if (!freeList.length) {\n    freeList.push(head)\n    head += 216\n  }\n\n  this.digestLength = digestLength\n  this.finalized = false\n  this.pointer = freeList.pop()\n\n  wasm.memory.fill(0, 0, 64)\n  wasm.memory[0] = this.digestLength\n  wasm.memory[1] = key ? key.length : 0\n  wasm.memory[2] = 1 // fanout\n  wasm.memory[3] = 1 // depth\n\n  if (salt) wasm.memory.set(salt, 32)\n  if (personal) wasm.memory.set(personal, 48)\n\n  if (this.pointer + 216 > wasm.memory.length) wasm.realloc(this.pointer + 216) // we need 216 bytes for the state\n  wasm.exports.blake2b_init(this.pointer, this.digestLength)\n\n  if (key) {\n    this.update(key)\n    wasm.memory.fill(0, head, head + key.length) // whiteout key\n    wasm.memory[this.pointer + 200] = 128\n  }\n}\n\n\nBlake2b.prototype.update = function (input) {\n  assert(this.finalized === false, 'Hash instance finalized')\n  assert(input, 'input must be TypedArray or Buffer')\n\n  if (head + input.length > wasm.memory.length) wasm.realloc(head + input.length)\n  wasm.memory.set(input, head)\n  wasm.exports.blake2b_update(this.pointer, head, head + input.length)\n  return this\n}\n\nBlake2b.prototype.digest = function (enc) {\n  assert(this.finalized === false, 'Hash instance finalized')\n  this.finalized = true\n\n  freeList.push(this.pointer)\n  wasm.exports.blake2b_final(this.pointer)\n\n  if (!enc || enc === 'binary') {\n    return wasm.memory.slice(this.pointer + 128, this.pointer + 128 + this.digestLength)\n  }\n\n  if (enc === 'hex') {\n    return hexSlice(wasm.memory, this.pointer + 128, this.digestLength)\n  }\n\n  assert(enc.length >= this.digestLength, 'input must be TypedArray or Buffer')\n  for (var i = 0; i < this.digestLength; i++) {\n    enc[i] = wasm.memory[this.pointer + 128 + i]\n  }\n\n  return enc\n}\n\n// libsodium compat\nBlake2b.prototype.final = Blake2b.prototype.digest\n\nBlake2b.WASM = wasm && wasm.buffer\nBlake2b.SUPPORTED = typeof WebAssembly !== 'undefined'\n\nBlake2b.ready = function (cb) {\n  if (!cb) cb = noop\n  if (!wasm) return cb(new Error('WebAssembly not supported'))\n\n  // backwards compat, can be removed in a new major\n  var p = new Promise(function (reject, resolve) {\n    wasm.onload(function (err) {\n      if (err) resolve()\n      else reject()\n      cb(err)\n    })\n  })\n\n  return p\n}\n\nBlake2b.prototype.ready = Blake2b.ready\n\nfunction noop () {}\n\nfunction hexSlice (buf, start, len) {\n  var str = ''\n  for (var i = 0; i < len; i++) str += toHex(buf[start + i])\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\n\n//# sourceURL=webpack:///./node_modules/blake2b-wasm/index.js?");

/***/ }),

/***/ "./node_modules/blake2b/index.js":
/*!***************************************!*\
  !*** ./node_modules/blake2b/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var assert = __webpack_require__(/*! nanoassert */ \"./node_modules/nanoassert/index.js\")\nvar b2wasm = __webpack_require__(/*! blake2b-wasm */ \"./node_modules/blake2b-wasm/index.js\")\n\n// 64-bit unsigned addition\n// Sets v[a,a+1] += v[b,b+1]\n// v should be a Uint32Array\nfunction ADD64AA (v, a, b) {\n  var o0 = v[a] + v[b]\n  var o1 = v[a + 1] + v[b + 1]\n  if (o0 >= 0x100000000) {\n    o1++\n  }\n  v[a] = o0\n  v[a + 1] = o1\n}\n\n// 64-bit unsigned addition\n// Sets v[a,a+1] += b\n// b0 is the low 32 bits of b, b1 represents the high 32 bits\nfunction ADD64AC (v, a, b0, b1) {\n  var o0 = v[a] + b0\n  if (b0 < 0) {\n    o0 += 0x100000000\n  }\n  var o1 = v[a + 1] + b1\n  if (o0 >= 0x100000000) {\n    o1++\n  }\n  v[a] = o0\n  v[a + 1] = o1\n}\n\n// Little-endian byte access\nfunction B2B_GET32 (arr, i) {\n  return (arr[i] ^\n  (arr[i + 1] << 8) ^\n  (arr[i + 2] << 16) ^\n  (arr[i + 3] << 24))\n}\n\n// G Mixing function\n// The ROTRs are inlined for speed\nfunction B2B_G (a, b, c, d, ix, iy) {\n  var x0 = m[ix]\n  var x1 = m[ix + 1]\n  var y0 = m[iy]\n  var y1 = m[iy + 1]\n\n  ADD64AA(v, a, b) // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s\n  ADD64AC(v, a, x0, x1) // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits\n\n  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits\n  var xor0 = v[d] ^ v[a]\n  var xor1 = v[d + 1] ^ v[a + 1]\n  v[d] = xor1\n  v[d + 1] = xor0\n\n  ADD64AA(v, c, d)\n\n  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits\n  xor0 = v[b] ^ v[c]\n  xor1 = v[b + 1] ^ v[c + 1]\n  v[b] = (xor0 >>> 24) ^ (xor1 << 8)\n  v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8)\n\n  ADD64AA(v, a, b)\n  ADD64AC(v, a, y0, y1)\n\n  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits\n  xor0 = v[d] ^ v[a]\n  xor1 = v[d + 1] ^ v[a + 1]\n  v[d] = (xor0 >>> 16) ^ (xor1 << 16)\n  v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16)\n\n  ADD64AA(v, c, d)\n\n  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits\n  xor0 = v[b] ^ v[c]\n  xor1 = v[b + 1] ^ v[c + 1]\n  v[b] = (xor1 >>> 31) ^ (xor0 << 1)\n  v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1)\n}\n\n// Initialization Vector\nvar BLAKE2B_IV32 = new Uint32Array([\n  0xF3BCC908, 0x6A09E667, 0x84CAA73B, 0xBB67AE85,\n  0xFE94F82B, 0x3C6EF372, 0x5F1D36F1, 0xA54FF53A,\n  0xADE682D1, 0x510E527F, 0x2B3E6C1F, 0x9B05688C,\n  0xFB41BD6B, 0x1F83D9AB, 0x137E2179, 0x5BE0CD19\n])\n\nvar SIGMA8 = [\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3\n]\n\n// These are offsets into a uint64 buffer.\n// Multiply them all by 2 to make them offsets into a uint32 buffer,\n// because this is Javascript and we don't have uint64s\nvar SIGMA82 = new Uint8Array(SIGMA8.map(function (x) { return x * 2 }))\n\n// Compression function. 'last' flag indicates last block.\n// Note we're representing 16 uint64s as 32 uint32s\nvar v = new Uint32Array(32)\nvar m = new Uint32Array(32)\nfunction blake2bCompress (ctx, last) {\n  var i = 0\n\n  // init work variables\n  for (i = 0; i < 16; i++) {\n    v[i] = ctx.h[i]\n    v[i + 16] = BLAKE2B_IV32[i]\n  }\n\n  // low 64 bits of offset\n  v[24] = v[24] ^ ctx.t\n  v[25] = v[25] ^ (ctx.t / 0x100000000)\n  // high 64 bits not supported, offset may not be higher than 2**53-1\n\n  // last block flag set ?\n  if (last) {\n    v[28] = ~v[28]\n    v[29] = ~v[29]\n  }\n\n  // get little-endian words\n  for (i = 0; i < 32; i++) {\n    m[i] = B2B_GET32(ctx.b, 4 * i)\n  }\n\n  // twelve rounds of mixing\n  for (i = 0; i < 12; i++) {\n    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1])\n    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3])\n    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5])\n    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7])\n    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9])\n    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11])\n    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13])\n    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15])\n  }\n\n  for (i = 0; i < 16; i++) {\n    ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16]\n  }\n}\n\n// reusable parameter_block\nvar parameter_block = new Uint8Array([\n  0, 0, 0, 0,      //  0: outlen, keylen, fanout, depth\n  0, 0, 0, 0,      //  4: leaf length, sequential mode\n  0, 0, 0, 0,      //  8: node offset\n  0, 0, 0, 0,      // 12: node offset\n  0, 0, 0, 0,      // 16: node depth, inner length, rfu\n  0, 0, 0, 0,      // 20: rfu\n  0, 0, 0, 0,      // 24: rfu\n  0, 0, 0, 0,      // 28: rfu\n  0, 0, 0, 0,      // 32: salt\n  0, 0, 0, 0,      // 36: salt\n  0, 0, 0, 0,      // 40: salt\n  0, 0, 0, 0,      // 44: salt\n  0, 0, 0, 0,      // 48: personal\n  0, 0, 0, 0,      // 52: personal\n  0, 0, 0, 0,      // 56: personal\n  0, 0, 0, 0       // 60: personal\n])\n\n// Creates a BLAKE2b hashing context\n// Requires an output length between 1 and 64 bytes\n// Takes an optional Uint8Array key\nfunction Blake2b (outlen, key, salt, personal) {\n  // zero out parameter_block before usage\n  parameter_block.fill(0)\n  // state, 'param block'\n\n  this.b = new Uint8Array(128)\n  this.h = new Uint32Array(16)\n  this.t = 0 // input count\n  this.c = 0 // pointer within buffer\n  this.outlen = outlen // output length in bytes\n\n  parameter_block[0] = outlen\n  if (key) parameter_block[1] = key.length\n  parameter_block[2] = 1 // fanout\n  parameter_block[3] = 1 // depth\n\n  if (salt) parameter_block.set(salt, 32)\n  if (personal) parameter_block.set(personal, 48)\n\n  // initialize hash state\n  for (var i = 0; i < 16; i++) {\n    this.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameter_block, i * 4)\n  }\n\n  // key the hash, if applicable\n  if (key) {\n    blake2bUpdate(this, key)\n    // at the end\n    this.c = 128\n  }\n}\n\nBlake2b.prototype.update = function (input) {\n  assert(input != null, 'input must be Uint8Array or Buffer')\n  blake2bUpdate(this, input)\n  return this\n}\n\nBlake2b.prototype.digest = function (out) {\n  var buf = (!out || out === 'binary' || out === 'hex') ? new Uint8Array(this.outlen) : out\n  assert(buf.length >= this.outlen, 'out must have at least outlen bytes of space')\n  blake2bFinal(this, buf)\n  if (out === 'hex') return hexSlice(buf)\n  return buf\n}\n\nBlake2b.prototype.final = Blake2b.prototype.digest\n\nBlake2b.ready = function (cb) {\n  b2wasm.ready(function () {\n    cb() // ignore the error\n  })\n}\n\n// Updates a BLAKE2b streaming hash\n// Requires hash context and Uint8Array (byte array)\nfunction blake2bUpdate (ctx, input) {\n  for (var i = 0; i < input.length; i++) {\n    if (ctx.c === 128) { // buffer full ?\n      ctx.t += ctx.c // add counters\n      blake2bCompress(ctx, false) // compress (not last)\n      ctx.c = 0 // counter to zero\n    }\n    ctx.b[ctx.c++] = input[i]\n  }\n}\n\n// Completes a BLAKE2b streaming hash\n// Returns a Uint8Array containing the message digest\nfunction blake2bFinal (ctx, out) {\n  ctx.t += ctx.c // mark last block offset\n\n  while (ctx.c < 128) { // fill up with zeros\n    ctx.b[ctx.c++] = 0\n  }\n  blake2bCompress(ctx, true) // final block flag = 1\n\n  for (var i = 0; i < ctx.outlen; i++) {\n    out[i] = ctx.h[i >> 2] >> (8 * (i & 3))\n  }\n  return out\n}\n\nfunction hexSlice (buf) {\n  var str = ''\n  for (var i = 0; i < buf.length; i++) str += toHex(buf[i])\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nvar Proto = Blake2b\n\nmodule.exports = function createHash (outlen, key, salt, personal, noAssert) {\n  if (noAssert !== true) {\n    assert(outlen >= BYTES_MIN, 'outlen must be at least ' + BYTES_MIN + ', was given ' + outlen)\n    assert(outlen <= BYTES_MAX, 'outlen must be at most ' + BYTES_MAX + ', was given ' + outlen)\n    if (key != null) assert(key.length >= KEYBYTES_MIN, 'key must be at least ' + KEYBYTES_MIN + ', was given ' + key.length)\n    if (key != null) assert(key.length <= KEYBYTES_MAX, 'key must be at most ' + KEYBYTES_MAX + ', was given ' + key.length)\n    if (salt != null) assert(salt.length === SALTBYTES, 'salt must be exactly ' + SALTBYTES + ', was given ' + salt.length)\n    if (personal != null) assert(personal.length === PERSONALBYTES, 'personal must be exactly ' + PERSONALBYTES + ', was given ' + personal.length)\n  }\n\n  return new Proto(outlen, key, salt, personal)\n}\n\nmodule.exports.ready = function (cb) {\n  b2wasm.ready(function () { // ignore errors\n    cb()\n  })\n}\n\nmodule.exports.WASM_SUPPORTED = b2wasm.SUPPORTED\nmodule.exports.WASM_LOADED = false\n\nvar BYTES_MIN = module.exports.BYTES_MIN = 16\nvar BYTES_MAX = module.exports.BYTES_MAX = 64\nvar BYTES = module.exports.BYTES = 32\nvar KEYBYTES_MIN = module.exports.KEYBYTES_MIN = 16\nvar KEYBYTES_MAX = module.exports.KEYBYTES_MAX = 64\nvar KEYBYTES = module.exports.KEYBYTES = 32\nvar SALTBYTES = module.exports.SALTBYTES = 16\nvar PERSONALBYTES = module.exports.PERSONALBYTES = 16\n\nb2wasm.ready(function (err) {\n  if (!err) {\n    module.exports.WASM_LOADED = true\n    Proto = b2wasm\n  }\n})\n\n\n//# sourceURL=webpack:///./node_modules/blake2b/index.js?");

/***/ }),

/***/ "./node_modules/buffer-crc32/index.js":
/*!********************************************!*\
  !*** ./node_modules/buffer-crc32/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer;\n\nvar CRC_TABLE = [\n  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,\n  0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,\n  0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,\n  0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,\n  0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,\n  0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n  0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,\n  0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n  0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,\n  0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,\n  0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,\n  0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,\n  0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,\n  0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,\n  0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n  0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,\n  0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n  0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,\n  0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,\n  0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,\n  0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,\n  0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,\n  0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,\n  0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,\n  0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,\n  0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,\n  0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,\n  0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n  0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,\n  0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n  0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,\n  0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,\n  0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,\n  0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,\n  0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,\n  0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,\n  0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n  0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,\n  0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n  0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,\n  0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,\n  0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,\n  0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,\n  0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,\n  0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,\n  0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,\n  0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,\n  0x2d02ef8d\n];\n\nif (typeof Int32Array !== 'undefined') {\n  CRC_TABLE = new Int32Array(CRC_TABLE);\n}\n\nfunction ensureBuffer(input) {\n  if (Buffer.isBuffer(input)) {\n    return input;\n  }\n\n  var hasNewBufferAPI =\n      typeof Buffer.alloc === \"function\" &&\n      typeof Buffer.from === \"function\";\n\n  if (typeof input === \"number\") {\n    return hasNewBufferAPI ? Buffer.alloc(input) : new Buffer(input);\n  }\n  else if (typeof input === \"string\") {\n    return hasNewBufferAPI ? Buffer.from(input) : new Buffer(input);\n  }\n  else {\n    throw new Error(\"input must be buffer, number, or string, received \" +\n                    typeof input);\n  }\n}\n\nfunction bufferizeInt(num) {\n  var tmp = ensureBuffer(4);\n  tmp.writeInt32BE(num, 0);\n  return tmp;\n}\n\nfunction _crc32(buf, previous) {\n  buf = ensureBuffer(buf);\n  if (Buffer.isBuffer(previous)) {\n    previous = previous.readUInt32BE(0);\n  }\n  var crc = ~~previous ^ -1;\n  for (var n = 0; n < buf.length; n++) {\n    crc = CRC_TABLE[(crc ^ buf[n]) & 0xff] ^ (crc >>> 8);\n  }\n  return (crc ^ -1);\n}\n\nfunction crc32() {\n  return bufferizeInt(_crc32.apply(null, arguments));\n}\ncrc32.signed = function () {\n  return _crc32.apply(null, arguments);\n};\ncrc32.unsigned = function () {\n  return _crc32.apply(null, arguments) >>> 0;\n};\n\nmodule.exports = crc32;\n\n\n//# sourceURL=webpack:///./node_modules/buffer-crc32/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/fnv-plus/index.js":
/*!****************************************!*\
  !*** ./node_modules/fnv-plus/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * FNV-1a Hash implementation (32, 64, 128, 256, 512, and 1024 bit)\n * @author Travis Webb <me@traviswebb.com>\n * @see http://tools.ietf.org/html/draft-eastlake-fnv-06\n */\nvar fnvplus = (function(){\n\tvar i, hl = [], hl16 = ['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'],\n\t\tversion = '1a',\n\t\tuseUTF8 = false,\n\t\t_hash32, _hash52, _hash64, _hash128, _hash256, _hash512, _hash1024,\n\t\treferenceSeed = 'chongo <Landon Curt Noll> /\\\\../\\\\',\n\t\tdefaultKeyspace = 52,\n\t\tfnvConstants = {\n\t\t\t32: {offset: 0},\n\t\t\t64: {offset: [0,0,0,0]},\n\t\t\t128: {offset: [0,0,0,0,0,0,0,0]},\n\t\t\t256: {offset: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},\n\t\t\t512: {offset: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},\n\t\t\t1024: {offset: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}};\n\n\tfor(i=0; i < 256; i++){\n\t\thl[i] = ((i >> 4) & 15).toString(16) + (i & 15).toString(16);\n\t}\n\n\tfunction hexToBase(hex, base){\n\t\tvar alphabet = '0123456789abcdefghijklmnopqrstuvwxyz',\n\t\t\tdigits = [0], carry, i, j, string = '';\n\n\t\tfor(i = 0; i < hex.length; i+=2){\n\t\t\tcarry = parseInt(hex.substr(i,2),16);\n\t\t\tfor(j = 0; j < digits.length; j++){\n\t\t\t\tcarry += digits[j] << 8;\n\t\t\t\tdigits[j] = carry % base;\n\t\t\t\tcarry = (carry / base) | 0;\n\t\t\t}\n\t\t\twhile (carry > 0) {\n\t\t\t\tdigits.push(carry % base);\n\t\t\t\tcarry = (carry / base) | 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = digits.length - 1; i >= 0; --i){\n\t\t\tstring += alphabet[digits[i]];\n\t\t}\n\n\t\treturn string;\n\t}\n\n\tfunction hashValHex(value, keyspace) {\n\t\treturn {\n\t\t\tbits: keyspace,\n\t\t\tvalue: value,\n\t\t\tdec: function(){return hexToBase(value, 10);},\n\t\t\thex: function(){return value;},\n\t\t\tstr: function(){return hexToBase(value, 36);}\n\t\t};\n\t}\n\n\tfunction hashValInt32(value, keyspace) {\n\t\treturn {\n\t\t\tbits: keyspace,\n\t\t\tvalue: value,\n\t\t\tdec: function(){return value.toString();},\n\t\t\thex: function(){return hl[value>>>24]+ hl[(value>>>16)&255]+hl[(value>>>8)&255]+hl[value&255];},\n\t\t\tstr: function(){return value.toString(36);}\n\t\t};\n\t}\n\n\tfunction hashValInt52(value, keyspace) {\n\t\treturn {\n\t\t\tbits: keyspace,\n\t\t\tvalue: value,\n\t\t\tdec: function(){return value.toString();},\n\t\t\thex: function(){return ('0000000000000000'+value.toString(16)).substr(-13);},\n\t\t\tstr: function(){return value.toString(36);}\n\t\t};\n\t}\n\n\tfunction hash(message, keyspace) {\n\t\tvar str = (typeof message === 'object') ? JSON.stringify(message) : message;\n\n\t\tswitch(keyspace || defaultKeyspace){\n\t\t\tcase 32:\n\t\t\t\treturn _hash32(str);\n\t\t\tcase 64:\n\t\t\t\treturn _hash64(str);\n\t\t\tcase 128:\n\t\t\t\treturn _hash128(str);\n\t\t\tcase 256:\n\t\t\t\treturn _hash256(str);\n\t\t\tcase 512:\n\t\t\t\treturn _hash512(str);\n\t\t\tcase 1024:\n\t\t\t\treturn _hash1024(str);\n\t\t\tdefault:\n\t\t\t\treturn _hash52(str);\n\t\t}\n\t}\n\n\tfunction setKeyspace(keyspace) {\n\t\tif (keyspace === 52 || fnvConstants[keyspace]) {\n\t\t\tdefaultKeyspace = keyspace;\n\t\t} else {\n\t\t\tthrow new Error('Supported FNV keyspacs: 32, 52, 64, 128, 256, 512, and 1024 bit');\n\t\t}\n\t}\n\n\tfunction setVersion(_version) {\n\t\tif (_version === '1a' ) {\n\t\t\tversion = _version;\n\t\t\t_hash32   = useUTF8 ? _hash32_1a_utf   : _hash32_1a;\n\t\t\t_hash52   = useUTF8 ? _hash52_1a_utf   : _hash52_1a;\n\t\t\t_hash64   = useUTF8 ? _hash64_1a_utf   : _hash64_1a;\n\t\t\t_hash128  = useUTF8 ? _hash128_1a_utf  : _hash128_1a;\n\t\t\t_hash256  = useUTF8 ? _hash256_1a_utf  : _hash256_1a;\n\t\t\t_hash512  = useUTF8 ? _hash512_1a_utf  : _hash512_1a;\n\t\t\t_hash1024 = useUTF8 ? _hash1024_1a_utf : _hash1024_1a;\n\t\t} else if (_version === '1') {\n\t\t\tversion = _version;\n\t\t\t_hash32   = useUTF8 ? _hash32_1_utf   : _hash32_1;\n\t\t\t_hash52   = useUTF8 ? _hash52_1_utf   : _hash52_1;\n\t\t\t_hash64   = useUTF8 ? _hash64_1_utf   : _hash64_1;\n\t\t\t_hash128  = useUTF8 ? _hash128_1_utf  : _hash128_1;\n\t\t\t_hash256  = useUTF8 ? _hash256_1_utf  : _hash256_1;\n\t\t\t_hash512  = useUTF8 ? _hash512_1_utf  : _hash512_1;\n\t\t\t_hash1024 = useUTF8 ? _hash1024_1_utf : _hash1024_1;\n\t\t} else {\n\t\t\tthrow new Error('Supported FNV versions: 1, 1a');\n\t\t}\n\t}\n\n\tfunction setUTF8(utf8) {\n\t\tif (utf8) {\n\t\t\tuseUTF8 = true;\n\t\t\t_hash32   = version == '1a' ? _hash32_1a_utf   : _hash32_1_utf;\n\t\t\t_hash52   = version == '1a' ? _hash52_1a_utf   : _hash52_1_utf;\n\t\t\t_hash64   = version == '1a' ? _hash64_1a_utf   : _hash64_1_utf;\n\t\t\t_hash128  = version == '1a' ? _hash128_1a_utf  : _hash128_1_utf;\n\t\t\t_hash256  = version == '1a' ? _hash256_1a_utf  : _hash256_1_utf;\n\t\t\t_hash512  = version == '1a' ? _hash512_1a_utf  : _hash512_1_utf;\n\t\t\t_hash1024 = version == '1a' ? _hash1024_1a_utf : _hash1024_1_utf;\n\t\t} else {\n\t\t\tuseUTF8 = false;\n\t\t\t_hash32   = version == '1a' ? _hash32_1a   : _hash32_1;\n\t\t\t_hash52   = version == '1a' ? _hash52_1a   : _hash52_1;\n\t\t\t_hash64   = version == '1a' ? _hash64_1a   : _hash64_1;\n\t\t\t_hash128  = version == '1a' ? _hash128_1a  : _hash128_1;\n\t\t\t_hash256  = version == '1a' ? _hash256_1a  : _hash256_1;\n\t\t\t_hash512  = version == '1a' ? _hash512_1a  : _hash512_1;\n\t\t\t_hash1024 = version == '1a' ? _hash1024_1a : _hash1024_1;\n\t\t}\n\t}\n\n\tfunction seed(seed) {\n\t\tvar oldVersion = version, res, i;\n\n\t\tseed = (seed || seed === 0) ? seed : referenceSeed;\n\n\t\tif (seed === referenceSeed) setVersion('1');\n\n\t\tfor (var keysize in fnvConstants) {\n\t\t\tfnvConstants[keysize].offset = [];\n\t\t\tfor(i = 0; i < keysize / 16; i++){\n\t\t\t\tfnvConstants[keysize].offset[i]\t= 0;\n\t\t\t}\n\t\t\tres = hash(seed, parseInt(keysize, 10)).hex();\n\t\t\tfor(i = 0; i < keysize / 16; i++){\n\t\t\t\tfnvConstants[keysize].offset[i]\t= parseInt(res.substr(i*4,4), 16);\n\t\t\t}\n\t\t}\n\n\t\tsetVersion(oldVersion);\n\t}\n\n\t/**\n\t * Implementation without library overhead.\n\t */\n\n\tfunction _hash32_1a_fast(str) {\n\t\tvar i, l = str.length-3, t0=0,v0=0x9dc5,t1=0,v1=0x811c;\n\n\t\tfor (i = 0; i < l;) {\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t}\n\n\t\twhile(i<l+3){\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t}\n\n\n\t\treturn ((v1<<16)>>>0)+v0;\n\t}\n\n\tfunction _hash32_1a_fast_hex(str) {\n\t\tvar i, l = str.length-3, t0=0,v0=0x9dc5,t1=0,v1=0x811c;\n\n\t\tfor (i = 0; i < l;) {\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t}\n\n\t\twhile(i<l+3){\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t}\n\n\n\t\treturn hl[(v1>>>8)&255]+hl[v1&255]+hl[(v0>>>8)&255]+hl[v0&255];\n\t}\n\n\tfunction _hash52_1a_fast(str){\n\t\tvar i,l=str.length-3,t0=0,v0=0x2325,t1=0,v1=0x8422,t2=0,v2=0x9ce4,t3=0,v3=0xcbf2;\n\n\t\tfor (i = 0; i < l;) {\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t}\n\n\t\twhile(i<l+3){\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t}\n\n\t\treturn (v3&15) * 281474976710656 + v2 * 4294967296 + v1 * 65536 + (v0^(v3>>4));\n\t}\n\n\tfunction _hash52_1a_fast_hex(str){\n\t\tvar i,l=str.length-3,t0=0,v0=0x2325,t1=0,v1=0x8422,t2=0,v2=0x9ce4,t3=0,v3=0xcbf2;\n\n\t\tfor (i = 0; i < l;) {\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t}\n\n\t\twhile(i<l+3){\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t}\n\n\t\treturn hl16[v3&15]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[(v0>>8)^(v3>>12)]+hl[(v0^(v3>>4))&255];\n\t}\n\n\tfunction _hash64_1a_fast(str){\n\t\tvar i,l=str.length-3,t0=0,v0=0x2325,t1=0,v1=0x8422,t2=0,v2=0x9ce4,t3=0,v3=0xcbf2;\n\n\t\tfor (i = 0; i < l;) {\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t}\n\n\t\twhile(i<l+3){\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t}\n\n\t\treturn hl[v3>>8]+hl[v3&255]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[v0>>8]+hl[v0&255];\n\t}\n\n\tfunction _hash32_1a_fast_utf(str) {\n\t\tvar c,i,l=str.length,t0=0,v0=0x9dc5,t1=0,v1=0x811c;\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tc = str.charCodeAt(i);\n\t\t\tif(c < 128){\n\t\t\t\tv0^=c;\n\t\t\t}else if(c < 2048){\n\t\t\t\tv0^=(c>>6)|192;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else if(((c&64512)==55296)&&(i+1)<l&&((str.charCodeAt(i+1)&64512)==56320)){\n\t\t\t\tc=65536+((c&1023)<<10)+(str.charCodeAt(++i)&1023);\n\t\t\t\tv0^=(c>>18)|240;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=((c>>12)&63)|128;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else{\n\t\t\t\tv0^=(c>>12)|224;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t}\n\n\t\treturn ((v1<<16)>>>0)+v0;\n\t}\n\n\tfunction _hash32_1a_fast_hex_utf(str) {\n\t\tvar c,i,l=str.length,t0=0,v0=0x9dc5,t1=0,v1=0x811c;\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tc = str.charCodeAt(i);\n\t\t\tif(c < 128){\n\t\t\t\tv0^=c;\n\t\t\t}else if(c < 2048){\n\t\t\t\tv0^=(c>>6)|192;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else if(((c&64512)==55296)&&(i+1)<l&&((str.charCodeAt(i+1)&64512)==56320)){\n\t\t\t\tc=65536+((c&1023)<<10)+(str.charCodeAt(++i)&1023);\n\t\t\t\tv0^=(c>>18)|240;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=((c>>12)&63)|128;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else{\n\t\t\t\tv0^=(c>>12)|224;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t}\n\n\n\t\treturn hl[(v1>>>8)&255]+hl[v1&255]+hl[(v0>>>8)&255]+hl[v0&255];\n\t}\n\n\tfunction _hash52_1a_fast_utf(str){\n\t\tvar c,i,l=str.length,t0=0,v0=0x2325,t1=0,v1=0x8422,t2=0,v2=0x9ce4,t3=0,v3=0xcbf2;\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tc = str.charCodeAt(i);\n\t\t\tif(c < 128){\n\t\t\t\tv0^=c;\n\t\t\t}else if(c < 2048){\n\t\t\t\tv0^=(c>>6)|192;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else if(((c&64512)==55296)&&(i+1)<l&&((str.charCodeAt(i+1)&64512)==56320)){\n\t\t\t\tc=65536+((c&1023)<<10)+(str.charCodeAt(++i)&1023);\n\t\t\t\tv0^=(c>>18)|240;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=((c>>12)&63)|128;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else{\n\t\t\t\tv0^=(c>>12)|224;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t}\n\n\t\treturn (v3&15) * 281474976710656 + v2 * 4294967296 + v1 * 65536 + (v0^(v3>>4));\n\t}\n\n\tfunction _hash52_1a_fast_hex_utf (str){\n\t\tvar c,i,l=str.length,t0=0,v0=0x2325,t1=0,v1=0x8422,t2=0,v2=0x9ce4,t3=0,v3=0xcbf2;\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tc = str.charCodeAt(i);\n\t\t\tif(c < 128){\n\t\t\t\tv0^=c;\n\t\t\t}else if(c < 2048){\n\t\t\t\tv0^=(c>>6)|192;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else if(((c&64512)==55296)&&(i+1)<l&&((str.charCodeAt(i+1)&64512)==56320)){\n\t\t\t\tc=65536+((c&1023)<<10)+(str.charCodeAt(++i)&1023);\n\t\t\t\tv0^=(c>>18)|240;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=((c>>12)&63)|128;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else{\n\t\t\t\tv0^=(c>>12)|224;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t}\n\n\t\treturn hl16[v3&15]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[(v0>>8)^(v3>>12)]+hl[(v0^(v3>>4))&255];\n\t}\n\n\tfunction _hash64_1a_fast_utf(str){\n\t\tvar c,i,l=str.length,t0=0,v0=0x2325,t1=0,v1=0x8422,t2=0,v2=0x9ce4,t3=0,v3=0xcbf2;\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tc = str.charCodeAt(i);\n\t\t\tif(c < 128){\n\t\t\t\tv0^=c;\n\t\t\t}else if(c < 2048){\n\t\t\t\tv0^=(c>>6)|192;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else if(((c&64512)==55296)&&(i+1)<l&&((str.charCodeAt(i+1)&64512)==56320)){\n\t\t\t\tc=65536+((c&1023)<<10)+(str.charCodeAt(++i)&1023);\n\t\t\t\tv0^=(c>>18)|240;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=((c>>12)&63)|128;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else{\n\t\t\t\tv0^=(c>>12)|224;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t}\n\n\t\treturn hl[v3>>8]+hl[v3&255]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[v0>>8]+hl[v0&255];\n\t}\n\t/**\n\t * Regular functions. This versions are accessible through API\n\t */\n\n\tfunction _hash32_1a(str){\n\t\tvar i,l=str.length-3,s=fnvConstants[32].offset,t0=0,v0=s[1]|0,t1=0,v1=s[0]|0;\n\n\t\tfor (i = 0; i < l;) {\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t}\n\n\t\twhile(i<l+3){\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t}\n\n\t\treturn hashValInt32(((v1<<16)>>>0)+v0,32);\n\t}\n\n\tfunction _hash32_1(str){\n\t\tvar i,l=str.length-3,s=fnvConstants[32].offset,t0=0,v0=s[1]|0,t1=0,v1=s[0]|0;\n\n\t\tfor (i = 0; i < l;) {\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t}\n\n\t\twhile(i<l+3){\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t}\n\n\t\treturn hashValInt32(((v1<<16)>>>0)+v0,32);\n\t}\n\n\tfunction _hash32_1a_utf(str){\n\t\tvar c,i,l=str.length,s=fnvConstants[32].offset,t0=0,v0=s[1]|0,t1=0,v1=s[0]|0;\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tc = str.charCodeAt(i);\n\t\t\tif(c < 128){\n\t\t\t\tv0^=c;\n\t\t\t}else if(c < 2048){\n\t\t\t\tv0^=(c>>6)|192;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else if(((c&64512)==55296)&&(i+1)<l&&((str.charCodeAt(i+1)&64512)==56320)){\n\t\t\t\tc=65536+((c&1023)<<10)+(str.charCodeAt(++i)&1023);\n\t\t\t\tv0^=(c>>18)|240;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=((c>>12)&63)|128;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else{\n\t\t\t\tv0^=(c>>12)|224;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t}\n\n\t\treturn hashValInt32(((v1<<16)>>>0)+v0,32);\n\t}\n\n\tfunction _hash32_1_utf(str){\n\t\tvar c,i,l=str.length,s=fnvConstants[32].offset,t0=0,v0=s[1]|0,t1=0,v1=s[0]|0;\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tc = str.charCodeAt(i);\n\t\t\tt0=v0*403;t1=v1*403;\n\t\t\tt1+=v0<<8;\n\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\tif(c < 128){\n\t\t\t\tv0^=c;\n\t\t\t}else if(c < 2048){\n\t\t\t\tv0^=(c>>6)|192;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else if(((c&64512)==55296)&&(i+1)<l&&((str.charCodeAt(i+1)&64512)==56320)){\n\t\t\t\tc=65536+((c&1023)<<10)+(str.charCodeAt(++i)&1023);\n\t\t\t\tv0^=(c>>18)|240;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=((c>>12)&63)|128;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else{\n\t\t\t\tv0^=(c>>12)|224;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*403;t1=v1*403;\n\t\t\t\tt1+=v0<<8;\n\t\t\t\tv1=(t1+(t0>>>16))&65535;v0=t0&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}\n\t\t}\n\n\t\treturn hashValInt32(((v1<<16)>>>0)+v0,32);\n\t}\n\n\t_hash32 = _hash32_1a;\n\n\tfunction _hash52_1a(str){\n\t\tvar i,l=str.length-3,s=fnvConstants[64].offset,t0=0,v0=s[3]|0,t1=0,v1=s[2]|0,t2=0,v2=s[1]|0,t3=0,v3=s[0]|0;\n\n\t\tfor (i = 0; i < l;) {\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t}\n\n\t\twhile(i<l+3){\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t}\n\n\t\treturn hashValInt52((v3&15)*281474976710656+v2*4294967296+v1*65536+(v0^(v3>>4)),52);\n\t}\n\n\tfunction _hash52_1(str){\n\t\tvar i,l=str.length-3,s=fnvConstants[64].offset,t0=0,v0=s[3]|0,t1=0,v1=s[2]|0,t2=0,v2=s[1]|0,t3=0,v3=s[0]|0;\n\n\t\tfor (i = 0; i < l;) {\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t}\n\n\t\twhile(i<l+3){\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t}\n\n\t\treturn hashValInt52((v3&15)*281474976710656+v2*4294967296+v1*65536+(v0^(v3>>4)),52);\n\t}\n\n\tfunction _hash52_1a_utf(str){\n\t\tvar c,i,l=str.length,s=fnvConstants[64].offset,t0=0,v0=s[3]|0,t1=0,v1=s[2]|0,t2=0,v2=s[1]|0,t3=0,v3=s[0]|0;\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tc = str.charCodeAt(i);\n\t\t\tif(c < 128){\n\t\t\t\tv0^=c;\n\t\t\t}else if(c < 2048){\n\t\t\t\tv0^=(c>>6)|192;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else if(((c&64512)==55296)&&(i+1)<l&&((str.charCodeAt(i+1)&64512)==56320)){\n\t\t\t\tc=65536+((c&1023)<<10)+(str.charCodeAt(++i)&1023);\n\t\t\t\tv0^=(c>>18)|240;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=((c>>12)&63)|128;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else{\n\t\t\t\tv0^=(c>>12)|224;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t}\n\n\t\treturn hashValInt52((v3&15)*281474976710656+v2*4294967296+v1*65536+(v0^(v3>>4)),52);\n\t}\n\n\tfunction _hash52_1_utf(str){\n\t\tvar c,i,l=str.length,s=fnvConstants[64].offset,t0=0,v0=s[3]|0,t1=0,v1=s[2]|0,t2=0,v2=s[1]|0,t3=0,v3=s[0]|0;\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tc = str.charCodeAt(i);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tif(c < 128){\n\t\t\t\tv0^=c;\n\t\t\t}else if(c < 2048){\n\t\t\t\tv0^=(c>>6)|192;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else if(((c&64512)==55296)&&(i+1)<l&&((str.charCodeAt(i+1)&64512)==56320)){\n\t\t\t\tc=65536+((c&1023)<<10)+(str.charCodeAt(++i)&1023);\n\t\t\t\tv0^=(c>>18)|240;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=((c>>12)&63)|128;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else{\n\t\t\t\tv0^=(c>>12)|224;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}\n\t\t}\n\n\t\treturn hashValInt52((v3&15)*281474976710656+v2*4294967296+v1*65536+(v0^(v3>>4)),52);\n\t}\n\n\t_hash52 = _hash52_1a;\n\n\tfunction _hash64_1a(str){\n\t\tvar i,l=str.length-3,s=fnvConstants[64].offset,t0=0,v0=s[3]|0,t1=0,v1=s[2]|0,t2=0,v2=s[1]|0,t3=0,v3=s[0]|0;\n\n\t\tfor (i = 0; i < l;) {\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t}\n\n\t\twhile(i<l+3){\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t}\n\n\t\treturn hashValHex(hl[v3>>8]+hl[v3&255]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[v0>>8]+hl[v0&255],64);\n\t}\n\n\tfunction _hash64_1(str){\n\t\tvar i,l=str.length-3,s=fnvConstants[64].offset,t0=0,v0=s[3]|0,t1=0,v1=s[2]|0,t2=0,v2=s[1]|0,t3=0,v3=s[0]|0;\n\n\t\tfor (i = 0; i < l;) {\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t}\n\n\t\twhile(i<l+3){\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t}\n\n\t\treturn hashValHex(hl[v3>>8]+hl[v3&255]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[v0>>8]+hl[v0&255],64);\n\t}\n\n\tfunction _hash64_1a_utf(str){\n\t\tvar c,i,l=str.length,s=fnvConstants[64].offset,t0=0,v0=s[3]|0,t1=0,v1=s[2]|0,t2=0,v2=s[1]|0,t3=0,v3=s[0]|0;\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tc = str.charCodeAt(i);\n\t\t\tif(c < 128){\n\t\t\t\tv0^=c;\n\t\t\t}else if(c < 2048){\n\t\t\t\tv0^=(c>>6)|192;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else if(((c&64512)==55296)&&(i+1)<l&&((str.charCodeAt(i+1)&64512)==56320)){\n\t\t\t\tc=65536+((c&1023)<<10)+(str.charCodeAt(++i)&1023);\n\t\t\t\tv0^=(c>>18)|240;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=((c>>12)&63)|128;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else{\n\t\t\t\tv0^=(c>>12)|224;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t}\n\n\t\treturn hashValHex(hl[v3>>8]+hl[v3&255]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[v0>>8]+hl[v0&255],64);\n\t}\n\n\tfunction _hash64_1_utf(str){\n\t\tvar c,i,l=str.length,s=fnvConstants[64].offset,t0=0,v0=s[3]|0,t1=0,v1=s[2]|0,t2=0,v2=s[1]|0,t3=0,v3=s[0]|0;\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tc = str.charCodeAt(i);\n\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\tif(c < 128){\n\t\t\t\tv0^=c;\n\t\t\t}else if(c < 2048){\n\t\t\t\tv0^=(c>>6)|192;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else if(((c&64512)==55296)&&(i+1)<l&&((str.charCodeAt(i+1)&64512)==56320)){\n\t\t\t\tc=65536+((c&1023)<<10)+(str.charCodeAt(++i)&1023);\n\t\t\t\tv0^=(c>>18)|240;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=((c>>12)&63)|128;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else{\n\t\t\t\tv0^=(c>>12)|224;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*435;t1=v1*435;t2=v2*435;t3=v3*435;\n\t\t\t\tt2+=v0<<8;t3+=v1<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;v3=(t3+(t2>>>16))&65535;v2=t2&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}\n\t\t}\n\n\t\treturn hashValHex(hl[v3>>8]+hl[v3&255]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[v0>>8]+hl[v0&255],64);\n\t}\n\n\t_hash64 = _hash64_1a;\n\n\tfunction _hash128_1a(str){\n\t\tvar i,l=str.length-3,s=fnvConstants[128].offset,t0=0,v0=s[7]|0,t1=0,v1=s[6]|0,t2=0,v2=s[5]|0,t3=0,v3=s[4]|0,t4=0,v4=s[3]|0,t5=0,v5=s[2]|0,t6=0,v6=s[1]|0,t7=0,v7=s[0]|0;\n\n\t\tfor (i = 0; i < l;) {\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t}\n\n\t\twhile(i<l+3){\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t}\n\n\t\treturn hashValHex(hl[v7>>8]+hl[v7&255]+hl[v6>>8]+hl[v6&255]+hl[v5>>8]+hl[v5&255]+hl[v4>>8]+hl[v4&255]+hl[v3>>8]+hl[v3&255]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[v0>>8]+hl[v0&255],128);\n\t}\n\n\tfunction _hash128_1(str){\n\t\tvar i,l=str.length-3,s=fnvConstants[128].offset,t0=0,v0=s[7]|0,t1=0,v1=s[6]|0,t2=0,v2=s[5]|0,t3=0,v3=s[4]|0,t4=0,v4=s[3]|0,t5=0,v5=s[2]|0,t6=0,v6=s[1]|0,t7=0,v7=s[0]|0;\n\n\t\tfor (i = 0; i < l;) {\n\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t}\n\n\t\twhile(i<l+3){\n\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t}\n\n\t\treturn hashValHex(hl[v7>>8]+hl[v7&255]+hl[v6>>8]+hl[v6&255]+hl[v5>>8]+hl[v5&255]+hl[v4>>8]+hl[v4&255]+hl[v3>>8]+hl[v3&255]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[v0>>8]+hl[v0&255],128);\n\t}\n\n\tfunction _hash128_1a_utf(str){\n\t\tvar c,i,l=str.length,s=fnvConstants[128].offset,t0=0,v0=s[7]|0,t1=0,v1=s[6]|0,t2=0,v2=s[5]|0,t3=0,v3=s[4]|0,t4=0,v4=s[3]|0,t5=0,v5=s[2]|0,t6=0,v6=s[1]|0,t7=0,v7=s[0]|0;\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tc = str.charCodeAt(i);\n\t\t\tif(c < 128){\n\t\t\t\tv0^=c;\n\t\t\t}else if(c < 2048){\n\t\t\t\tv0^=(c>>6)|192;\n\t\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else if(((c&64512)==55296)&&(i+1)<l&&((str.charCodeAt(i+1)&64512)==56320)){\n\t\t\t\tc=65536+((c&1023)<<10)+(str.charCodeAt(++i)&1023);\n\t\t\t\tv0^=(c>>18)|240;\n\t\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t\t\tv0^=((c>>12)&63)|128;\n\t\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else{\n\t\t\t\tv0^=(c>>12)|224;\n\t\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}\n\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t}\n\n\t\treturn hashValHex(hl[v7>>8]+hl[v7&255]+hl[v6>>8]+hl[v6&255]+hl[v5>>8]+hl[v5&255]+hl[v4>>8]+hl[v4&255]+hl[v3>>8]+hl[v3&255]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[v0>>8]+hl[v0&255],128);\n\t}\n\n\tfunction _hash128_1_utf(str){\n\t\tvar c,i,l=str.length,s=fnvConstants[128].offset,t0=0,v0=s[7]|0,t1=0,v1=s[6]|0,t2=0,v2=s[5]|0,t3=0,v3=s[4]|0,t4=0,v4=s[3]|0,t5=0,v5=s[2]|0,t6=0,v6=s[1]|0,t7=0,v7=s[0]|0;\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tc = str.charCodeAt(i);\n\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t\tif(c < 128){\n\t\t\t\tv0^=c;\n\t\t\t}else if(c < 2048){\n\t\t\t\tv0^=(c>>6)|192;\n\t\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else if(((c&64512)==55296)&&(i+1)<l&&((str.charCodeAt(i+1)&64512)==56320)){\n\t\t\t\tc=65536+((c&1023)<<10)+(str.charCodeAt(++i)&1023);\n\t\t\t\tv0^=(c>>18)|240;\n\t\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t\t\tv0^=((c>>12)&63)|128;\n\t\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else{\n\t\t\t\tv0^=(c>>12)|224;\n\t\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*315;t1=v1*315;t2=v2*315;t3=v3*315;t4=v4*315;t5=v5*315;t6=v6*315;t7=v7*315;\n\t\t\t\tt5+=v0<<8;t6+=v1<<8;t7+=v2<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;v7=(t7+(t6>>>16))&65535;v6=t6&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}\n\t\t}\n\n\t\treturn hashValHex(hl[v7>>8]+hl[v7&255]+hl[v6>>8]+hl[v6&255]+hl[v5>>8]+hl[v5&255]+hl[v4>>8]+hl[v4&255]+hl[v3>>8]+hl[v3&255]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[v0>>8]+hl[v0&255],128);\n\t}\n\n\t_hash128 = _hash128_1a;\n\n\tfunction _hash256_1a(str){\n\t\tvar i,l=str.length-3,s=fnvConstants[256].offset,t0=0,v0=s[15]|0,t1=0,v1=s[14]|0,t2=0,v2=s[13]|0,t3=0,v3=s[12]|0,t4=0,v4=s[11]|0,t5=0,v5=s[10]|0,t6=0,v6=s[9]|0,t7=0,v7=s[8]|0,t8=0,v8=s[7]|0,t9=0,v9=s[6]|0,t10=0,v10=s[5]|0,t11=0,v11=s[4]|0,t12=0,v12=s[3]|0,t13=0,v13=s[2]|0,t14=0,v14=s[1]|0,t15=0,v15=s[0]|0;\n\n\t\tfor (i = 0; i < l;) {\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t}\n\n\t\twhile(i<l+3){\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t}\n\n\t\treturn hashValHex(hl[v15>>8]+hl[v15&255]+hl[v14>>8]+hl[v14&255]+hl[v13>>8]+hl[v13&255]+hl[v12>>8]+hl[v12&255]+hl[v11>>8]+hl[v11&255]+hl[v10>>8]+hl[v10&255]+hl[v9>>8]+hl[v9&255]+hl[v8>>8]+hl[v8&255]+hl[v7>>8]+hl[v7&255]+hl[v6>>8]+hl[v6&255]+hl[v5>>8]+hl[v5&255]+hl[v4>>8]+hl[v4&255]+hl[v3>>8]+hl[v3&255]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[v0>>8]+hl[v0&255],256);\n\t}\n\n\tfunction _hash256_1(str){\n\t\tvar i,l=str.length-3,s=fnvConstants[256].offset,t0=0,v0=s[15]|0,t1=0,v1=s[14]|0,t2=0,v2=s[13]|0,t3=0,v3=s[12]|0,t4=0,v4=s[11]|0,t5=0,v5=s[10]|0,t6=0,v6=s[9]|0,t7=0,v7=s[8]|0,t8=0,v8=s[7]|0,t9=0,v9=s[6]|0,t10=0,v10=s[5]|0,t11=0,v11=s[4]|0,t12=0,v12=s[3]|0,t13=0,v13=s[2]|0,t14=0,v14=s[1]|0,t15=0,v15=s[0]|0;\n\n\t\tfor (i = 0; i < l;) {\n\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t}\n\n\t\twhile(i<l+3){\n\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t}\n\n\t\treturn hashValHex(hl[v15>>8]+hl[v15&255]+hl[v14>>8]+hl[v14&255]+hl[v13>>8]+hl[v13&255]+hl[v12>>8]+hl[v12&255]+hl[v11>>8]+hl[v11&255]+hl[v10>>8]+hl[v10&255]+hl[v9>>8]+hl[v9&255]+hl[v8>>8]+hl[v8&255]+hl[v7>>8]+hl[v7&255]+hl[v6>>8]+hl[v6&255]+hl[v5>>8]+hl[v5&255]+hl[v4>>8]+hl[v4&255]+hl[v3>>8]+hl[v3&255]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[v0>>8]+hl[v0&255],256);\n\t}\n\n\tfunction _hash256_1a_utf(str){\n\t\tvar c,i,l=str.length,s=fnvConstants[256].offset,t0=0,v0=s[15]|0,t1=0,v1=s[14]|0,t2=0,v2=s[13]|0,t3=0,v3=s[12]|0,t4=0,v4=s[11]|0,t5=0,v5=s[10]|0,t6=0,v6=s[9]|0,t7=0,v7=s[8]|0,t8=0,v8=s[7]|0,t9=0,v9=s[6]|0,t10=0,v10=s[5]|0,t11=0,v11=s[4]|0,t12=0,v12=s[3]|0,t13=0,v13=s[2]|0,t14=0,v14=s[1]|0,t15=0,v15=s[0]|0;\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tc = str.charCodeAt(i);\n\t\t\tif(c < 128){\n\t\t\t\tv0^=c;\n\t\t\t}else if(c < 2048){\n\t\t\t\tv0^=(c>>6)|192;\n\t\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else if(((c&64512)==55296)&&(i+1)<l&&((str.charCodeAt(i+1)&64512)==56320)){\n\t\t\t\tc=65536+((c&1023)<<10)+(str.charCodeAt(++i)&1023);\n\t\t\t\tv0^=(c>>18)|240;\n\t\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t\t\tv0^=((c>>12)&63)|128;\n\t\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else{\n\t\t\t\tv0^=(c>>12)|224;\n\t\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}\n\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t}\n\n\t\treturn hashValHex(hl[v15>>8]+hl[v15&255]+hl[v14>>8]+hl[v14&255]+hl[v13>>8]+hl[v13&255]+hl[v12>>8]+hl[v12&255]+hl[v11>>8]+hl[v11&255]+hl[v10>>8]+hl[v10&255]+hl[v9>>8]+hl[v9&255]+hl[v8>>8]+hl[v8&255]+hl[v7>>8]+hl[v7&255]+hl[v6>>8]+hl[v6&255]+hl[v5>>8]+hl[v5&255]+hl[v4>>8]+hl[v4&255]+hl[v3>>8]+hl[v3&255]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[v0>>8]+hl[v0&255],256);\n\t}\n\n\tfunction _hash256_1_utf(str){\n\t\tvar c,i,l=str.length,s=fnvConstants[256].offset,t0=0,v0=s[15]|0,t1=0,v1=s[14]|0,t2=0,v2=s[13]|0,t3=0,v3=s[12]|0,t4=0,v4=s[11]|0,t5=0,v5=s[10]|0,t6=0,v6=s[9]|0,t7=0,v7=s[8]|0,t8=0,v8=s[7]|0,t9=0,v9=s[6]|0,t10=0,v10=s[5]|0,t11=0,v11=s[4]|0,t12=0,v12=s[3]|0,t13=0,v13=s[2]|0,t14=0,v14=s[1]|0,t15=0,v15=s[0]|0;\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tc = str.charCodeAt(i);\n\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t\tif(c < 128){\n\t\t\t\tv0^=c;\n\t\t\t}else if(c < 2048){\n\t\t\t\tv0^=(c>>6)|192;\n\t\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else if(((c&64512)==55296)&&(i+1)<l&&((str.charCodeAt(i+1)&64512)==56320)){\n\t\t\t\tc=65536+((c&1023)<<10)+(str.charCodeAt(++i)&1023);\n\t\t\t\tv0^=(c>>18)|240;\n\t\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t\t\tv0^=((c>>12)&63)|128;\n\t\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else{\n\t\t\t\tv0^=(c>>12)|224;\n\t\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*355;t1=v1*355;t2=v2*355;t3=v3*355;t4=v4*355;t5=v5*355;t6=v6*355;t7=v7*355;t8=v8*355;t9=v9*355;t10=v10*355;t11=v11*355;t12=v12*355;t13=v13*355;t14=v14*355;t15=v15*355;\n\t\t\t\tt10+=v0<<8;t11+=v1<<8;t12+=v2<<8;t13+=v3<<8;t14+=v4<<8;t15+=v5<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;v15=(t15+(t14>>>16))&65535;v14=t14&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}\n\t\t}\n\n\t\treturn hashValHex(hl[v15>>8]+hl[v15&255]+hl[v14>>8]+hl[v14&255]+hl[v13>>8]+hl[v13&255]+hl[v12>>8]+hl[v12&255]+hl[v11>>8]+hl[v11&255]+hl[v10>>8]+hl[v10&255]+hl[v9>>8]+hl[v9&255]+hl[v8>>8]+hl[v8&255]+hl[v7>>8]+hl[v7&255]+hl[v6>>8]+hl[v6&255]+hl[v5>>8]+hl[v5&255]+hl[v4>>8]+hl[v4&255]+hl[v3>>8]+hl[v3&255]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[v0>>8]+hl[v0&255],256);\n\t}\n\n\t_hash256 = _hash256_1a;\n\n\tfunction _hash512_1a(str){\n\t\tvar i,l=str.length-3,s=fnvConstants[512].offset,t0=0,v0=s[31]|0,t1=0,v1=s[30]|0,t2=0,v2=s[29]|0,t3=0,v3=s[28]|0,t4=0,v4=s[27]|0,t5=0,v5=s[26]|0,t6=0,v6=s[25]|0,t7=0,v7=s[24]|0,t8=0,v8=s[23]|0,t9=0,v9=s[22]|0,t10=0,v10=s[21]|0,t11=0,v11=s[20]|0,t12=0,v12=s[19]|0,t13=0,v13=s[18]|0,t14=0,v14=s[17]|0,t15=0,v15=s[16]|0,t16=0,v16=s[15]|0,t17=0,v17=s[14]|0,t18=0,v18=s[13]|0,t19=0,v19=s[12]|0,t20=0,v20=s[11]|0,t21=0,v21=s[10]|0,t22=0,v22=s[9]|0,t23=0,v23=s[8]|0,t24=0,v24=s[7]|0,t25=0,v25=s[6]|0,t26=0,v26=s[5]|0,t27=0,v27=s[4]|0,t28=0,v28=s[3]|0,t29=0,v29=s[2]|0,t30=0,v30=s[1]|0,t31=0,v31=s[0]|0;\n\n\t\tfor (i = 0; i < l;) {\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t}\n\n\t\twhile(i<l+3){\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t}\n\n\t\treturn hashValHex(hl[v31>>8]+hl[v31&255]+hl[v30>>8]+hl[v30&255]+hl[v29>>8]+hl[v29&255]+hl[v28>>8]+hl[v28&255]+hl[v27>>8]+hl[v27&255]+hl[v26>>8]+hl[v26&255]+hl[v25>>8]+hl[v25&255]+hl[v24>>8]+hl[v24&255]+hl[v23>>8]+hl[v23&255]+hl[v22>>8]+hl[v22&255]+hl[v21>>8]+hl[v21&255]+hl[v20>>8]+hl[v20&255]+hl[v19>>8]+hl[v19&255]+hl[v18>>8]+hl[v18&255]+hl[v17>>8]+hl[v17&255]+hl[v16>>8]+hl[v16&255]+hl[v15>>8]+hl[v15&255]+hl[v14>>8]+hl[v14&255]+hl[v13>>8]+hl[v13&255]+hl[v12>>8]+hl[v12&255]+hl[v11>>8]+hl[v11&255]+hl[v10>>8]+hl[v10&255]+hl[v9>>8]+hl[v9&255]+hl[v8>>8]+hl[v8&255]+hl[v7>>8]+hl[v7&255]+hl[v6>>8]+hl[v6&255]+hl[v5>>8]+hl[v5&255]+hl[v4>>8]+hl[v4&255]+hl[v3>>8]+hl[v3&255]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[v0>>8]+hl[v0&255],512);\n\t}\n\n\tfunction _hash512_1(str){\n\t\tvar i,l=str.length-3,s=fnvConstants[512].offset,t0=0,v0=s[31]|0,t1=0,v1=s[30]|0,t2=0,v2=s[29]|0,t3=0,v3=s[28]|0,t4=0,v4=s[27]|0,t5=0,v5=s[26]|0,t6=0,v6=s[25]|0,t7=0,v7=s[24]|0,t8=0,v8=s[23]|0,t9=0,v9=s[22]|0,t10=0,v10=s[21]|0,t11=0,v11=s[20]|0,t12=0,v12=s[19]|0,t13=0,v13=s[18]|0,t14=0,v14=s[17]|0,t15=0,v15=s[16]|0,t16=0,v16=s[15]|0,t17=0,v17=s[14]|0,t18=0,v18=s[13]|0,t19=0,v19=s[12]|0,t20=0,v20=s[11]|0,t21=0,v21=s[10]|0,t22=0,v22=s[9]|0,t23=0,v23=s[8]|0,t24=0,v24=s[7]|0,t25=0,v25=s[6]|0,t26=0,v26=s[5]|0,t27=0,v27=s[4]|0,t28=0,v28=s[3]|0,t29=0,v29=s[2]|0,t30=0,v30=s[1]|0,t31=0,v31=s[0]|0;\n\n\t\tfor (i = 0; i < l;) {\n\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t}\n\n\t\twhile(i<l+3){\n\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t}\n\n\t\treturn hashValHex(hl[v31>>8]+hl[v31&255]+hl[v30>>8]+hl[v30&255]+hl[v29>>8]+hl[v29&255]+hl[v28>>8]+hl[v28&255]+hl[v27>>8]+hl[v27&255]+hl[v26>>8]+hl[v26&255]+hl[v25>>8]+hl[v25&255]+hl[v24>>8]+hl[v24&255]+hl[v23>>8]+hl[v23&255]+hl[v22>>8]+hl[v22&255]+hl[v21>>8]+hl[v21&255]+hl[v20>>8]+hl[v20&255]+hl[v19>>8]+hl[v19&255]+hl[v18>>8]+hl[v18&255]+hl[v17>>8]+hl[v17&255]+hl[v16>>8]+hl[v16&255]+hl[v15>>8]+hl[v15&255]+hl[v14>>8]+hl[v14&255]+hl[v13>>8]+hl[v13&255]+hl[v12>>8]+hl[v12&255]+hl[v11>>8]+hl[v11&255]+hl[v10>>8]+hl[v10&255]+hl[v9>>8]+hl[v9&255]+hl[v8>>8]+hl[v8&255]+hl[v7>>8]+hl[v7&255]+hl[v6>>8]+hl[v6&255]+hl[v5>>8]+hl[v5&255]+hl[v4>>8]+hl[v4&255]+hl[v3>>8]+hl[v3&255]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[v0>>8]+hl[v0&255],512);\n\t}\n\n\tfunction _hash512_1a_utf(str){\n\t\tvar c,i,l=str.length,s=fnvConstants[512].offset,t0=0,v0=s[31]|0,t1=0,v1=s[30]|0,t2=0,v2=s[29]|0,t3=0,v3=s[28]|0,t4=0,v4=s[27]|0,t5=0,v5=s[26]|0,t6=0,v6=s[25]|0,t7=0,v7=s[24]|0,t8=0,v8=s[23]|0,t9=0,v9=s[22]|0,t10=0,v10=s[21]|0,t11=0,v11=s[20]|0,t12=0,v12=s[19]|0,t13=0,v13=s[18]|0,t14=0,v14=s[17]|0,t15=0,v15=s[16]|0,t16=0,v16=s[15]|0,t17=0,v17=s[14]|0,t18=0,v18=s[13]|0,t19=0,v19=s[12]|0,t20=0,v20=s[11]|0,t21=0,v21=s[10]|0,t22=0,v22=s[9]|0,t23=0,v23=s[8]|0,t24=0,v24=s[7]|0,t25=0,v25=s[6]|0,t26=0,v26=s[5]|0,t27=0,v27=s[4]|0,t28=0,v28=s[3]|0,t29=0,v29=s[2]|0,t30=0,v30=s[1]|0,t31=0,v31=s[0]|0;\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tc = str.charCodeAt(i);\n\t\t\tif(c < 128){\n\t\t\t\tv0^=c;\n\t\t\t}else if(c < 2048){\n\t\t\t\tv0^=(c>>6)|192;\n\t\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else if(((c&64512)==55296)&&(i+1)<l&&((str.charCodeAt(i+1)&64512)==56320)){\n\t\t\t\tc=65536+((c&1023)<<10)+(str.charCodeAt(++i)&1023);\n\t\t\t\tv0^=(c>>18)|240;\n\t\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t\t\tv0^=((c>>12)&63)|128;\n\t\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else{\n\t\t\t\tv0^=(c>>12)|224;\n\t\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}\n\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t}\n\n\t\treturn hashValHex(hl[v31>>8]+hl[v31&255]+hl[v30>>8]+hl[v30&255]+hl[v29>>8]+hl[v29&255]+hl[v28>>8]+hl[v28&255]+hl[v27>>8]+hl[v27&255]+hl[v26>>8]+hl[v26&255]+hl[v25>>8]+hl[v25&255]+hl[v24>>8]+hl[v24&255]+hl[v23>>8]+hl[v23&255]+hl[v22>>8]+hl[v22&255]+hl[v21>>8]+hl[v21&255]+hl[v20>>8]+hl[v20&255]+hl[v19>>8]+hl[v19&255]+hl[v18>>8]+hl[v18&255]+hl[v17>>8]+hl[v17&255]+hl[v16>>8]+hl[v16&255]+hl[v15>>8]+hl[v15&255]+hl[v14>>8]+hl[v14&255]+hl[v13>>8]+hl[v13&255]+hl[v12>>8]+hl[v12&255]+hl[v11>>8]+hl[v11&255]+hl[v10>>8]+hl[v10&255]+hl[v9>>8]+hl[v9&255]+hl[v8>>8]+hl[v8&255]+hl[v7>>8]+hl[v7&255]+hl[v6>>8]+hl[v6&255]+hl[v5>>8]+hl[v5&255]+hl[v4>>8]+hl[v4&255]+hl[v3>>8]+hl[v3&255]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[v0>>8]+hl[v0&255],512);\n\t}\n\n\tfunction _hash512_1_utf(str){\n\t\tvar c,i,l=str.length,s=fnvConstants[512].offset,t0=0,v0=s[31]|0,t1=0,v1=s[30]|0,t2=0,v2=s[29]|0,t3=0,v3=s[28]|0,t4=0,v4=s[27]|0,t5=0,v5=s[26]|0,t6=0,v6=s[25]|0,t7=0,v7=s[24]|0,t8=0,v8=s[23]|0,t9=0,v9=s[22]|0,t10=0,v10=s[21]|0,t11=0,v11=s[20]|0,t12=0,v12=s[19]|0,t13=0,v13=s[18]|0,t14=0,v14=s[17]|0,t15=0,v15=s[16]|0,t16=0,v16=s[15]|0,t17=0,v17=s[14]|0,t18=0,v18=s[13]|0,t19=0,v19=s[12]|0,t20=0,v20=s[11]|0,t21=0,v21=s[10]|0,t22=0,v22=s[9]|0,t23=0,v23=s[8]|0,t24=0,v24=s[7]|0,t25=0,v25=s[6]|0,t26=0,v26=s[5]|0,t27=0,v27=s[4]|0,t28=0,v28=s[3]|0,t29=0,v29=s[2]|0,t30=0,v30=s[1]|0,t31=0,v31=s[0]|0;\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tc = str.charCodeAt(i);\n\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t\tif(c < 128){\n\t\t\t\tv0^=c;\n\t\t\t}else if(c < 2048){\n\t\t\t\tv0^=(c>>6)|192;\n\t\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else if(((c&64512)==55296)&&(i+1)<l&&((str.charCodeAt(i+1)&64512)==56320)){\n\t\t\t\tc=65536+((c&1023)<<10)+(str.charCodeAt(++i)&1023);\n\t\t\t\tv0^=(c>>18)|240;\n\t\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t\t\tv0^=((c>>12)&63)|128;\n\t\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else{\n\t\t\t\tv0^=(c>>12)|224;\n\t\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*343;t1=v1*343;t2=v2*343;t3=v3*343;t4=v4*343;t5=v5*343;t6=v6*343;t7=v7*343;t8=v8*343;t9=v9*343;t10=v10*343;t11=v11*343;t12=v12*343;t13=v13*343;t14=v14*343;t15=v15*343;t16=v16*343;t17=v17*343;t18=v18*343;t19=v19*343;t20=v20*343;t21=v21*343;t22=v22*343;t23=v23*343;t24=v24*343;t25=v25*343;t26=v26*343;t27=v27*343;t28=v28*343;t29=v29*343;t30=v30*343;t31=v31*343;\n\t\t\t\tt21+=v0<<8;t22+=v1<<8;t23+=v2<<8;t24+=v3<<8;t25+=v4<<8;t26+=v5<<8;t27+=v6<<8;t28+=v7<<8;t29+=v8<<8;t30+=v9<<8;t31+=v10<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;v31=(t31+(t30>>>16))&65535;v30=t30&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}\n\t\t}\n\n\t\treturn hashValHex(hl[v31>>8]+hl[v31&255]+hl[v30>>8]+hl[v30&255]+hl[v29>>8]+hl[v29&255]+hl[v28>>8]+hl[v28&255]+hl[v27>>8]+hl[v27&255]+hl[v26>>8]+hl[v26&255]+hl[v25>>8]+hl[v25&255]+hl[v24>>8]+hl[v24&255]+hl[v23>>8]+hl[v23&255]+hl[v22>>8]+hl[v22&255]+hl[v21>>8]+hl[v21&255]+hl[v20>>8]+hl[v20&255]+hl[v19>>8]+hl[v19&255]+hl[v18>>8]+hl[v18&255]+hl[v17>>8]+hl[v17&255]+hl[v16>>8]+hl[v16&255]+hl[v15>>8]+hl[v15&255]+hl[v14>>8]+hl[v14&255]+hl[v13>>8]+hl[v13&255]+hl[v12>>8]+hl[v12&255]+hl[v11>>8]+hl[v11&255]+hl[v10>>8]+hl[v10&255]+hl[v9>>8]+hl[v9&255]+hl[v8>>8]+hl[v8&255]+hl[v7>>8]+hl[v7&255]+hl[v6>>8]+hl[v6&255]+hl[v5>>8]+hl[v5&255]+hl[v4>>8]+hl[v4&255]+hl[v3>>8]+hl[v3&255]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[v0>>8]+hl[v0&255],512);\n\t}\n\n\t_hash512 = _hash512_1a;\n\n\tfunction _hash1024_1a(str){\n\t\tvar i,l=str.length-3,s=fnvConstants[1024].offset,t0=0,v0=s[63]|0,t1=0,v1=s[62]|0,t2=0,v2=s[61]|0,t3=0,v3=s[60]|0,t4=0,v4=s[59]|0,t5=0,v5=s[58]|0,t6=0,v6=s[57]|0,t7=0,v7=s[56]|0,t8=0,v8=s[55]|0,t9=0,v9=s[54]|0,t10=0,v10=s[53]|0,t11=0,v11=s[52]|0,t12=0,v12=s[51]|0,t13=0,v13=s[50]|0,t14=0,v14=s[49]|0,t15=0,v15=s[48]|0,t16=0,v16=s[47]|0,t17=0,v17=s[46]|0,t18=0,v18=s[45]|0,t19=0,v19=s[44]|0,t20=0,v20=s[43]|0,t21=0,v21=s[42]|0,t22=0,v22=s[41]|0,t23=0,v23=s[40]|0,t24=0,v24=s[39]|0,t25=0,v25=s[38]|0,t26=0,v26=s[37]|0,t27=0,v27=s[36]|0,t28=0,v28=s[35]|0,t29=0,v29=s[34]|0,t30=0,v30=s[33]|0,t31=0,v31=s[32]|0,t32=0,v32=s[31]|0,t33=0,v33=s[30]|0,t34=0,v34=s[29]|0,t35=0,v35=s[28]|0,t36=0,v36=s[27]|0,t37=0,v37=s[26]|0,t38=0,v38=s[25]|0,t39=0,v39=s[24]|0,t40=0,v40=s[23]|0,t41=0,v41=s[22]|0,t42=0,v42=s[21]|0,t43=0,v43=s[20]|0,t44=0,v44=s[19]|0,t45=0,v45=s[18]|0,t46=0,v46=s[17]|0,t47=0,v47=s[16]|0,t48=0,v48=s[15]|0,t49=0,v49=s[14]|0,t50=0,v50=s[13]|0,t51=0,v51=s[12]|0,t52=0,v52=s[11]|0,t53=0,v53=s[10]|0,t54=0,v54=s[9]|0,t55=0,v55=s[8]|0,t56=0,v56=s[7]|0,t57=0,v57=s[6]|0,t58=0,v58=s[5]|0,t59=0,v59=s[4]|0,t60=0,v60=s[3]|0,t61=0,v61=s[2]|0,t62=0,v62=s[1]|0,t63=0,v63=s[0]|0;\n\n\t\tfor (i = 0; i < l;) {\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t}\n\n\t\twhile(i<l+3){\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t}\n\n\t\treturn hashValHex(hl[v63>>8]+hl[v63&255]+hl[v62>>8]+hl[v62&255]+hl[v61>>8]+hl[v61&255]+hl[v60>>8]+hl[v60&255]+hl[v59>>8]+hl[v59&255]+hl[v58>>8]+hl[v58&255]+hl[v57>>8]+hl[v57&255]+hl[v56>>8]+hl[v56&255]+hl[v55>>8]+hl[v55&255]+hl[v54>>8]+hl[v54&255]+hl[v53>>8]+hl[v53&255]+hl[v52>>8]+hl[v52&255]+hl[v51>>8]+hl[v51&255]+hl[v50>>8]+hl[v50&255]+hl[v49>>8]+hl[v49&255]+hl[v48>>8]+hl[v48&255]+hl[v47>>8]+hl[v47&255]+hl[v46>>8]+hl[v46&255]+hl[v45>>8]+hl[v45&255]+hl[v44>>8]+hl[v44&255]+hl[v43>>8]+hl[v43&255]+hl[v42>>8]+hl[v42&255]+hl[v41>>8]+hl[v41&255]+hl[v40>>8]+hl[v40&255]+hl[v39>>8]+hl[v39&255]+hl[v38>>8]+hl[v38&255]+hl[v37>>8]+hl[v37&255]+hl[v36>>8]+hl[v36&255]+hl[v35>>8]+hl[v35&255]+hl[v34>>8]+hl[v34&255]+hl[v33>>8]+hl[v33&255]+hl[v32>>8]+hl[v32&255]+hl[v31>>8]+hl[v31&255]+hl[v30>>8]+hl[v30&255]+hl[v29>>8]+hl[v29&255]+hl[v28>>8]+hl[v28&255]+hl[v27>>8]+hl[v27&255]+hl[v26>>8]+hl[v26&255]+hl[v25>>8]+hl[v25&255]+hl[v24>>8]+hl[v24&255]+hl[v23>>8]+hl[v23&255]+hl[v22>>8]+hl[v22&255]+hl[v21>>8]+hl[v21&255]+hl[v20>>8]+hl[v20&255]+hl[v19>>8]+hl[v19&255]+hl[v18>>8]+hl[v18&255]+hl[v17>>8]+hl[v17&255]+hl[v16>>8]+hl[v16&255]+hl[v15>>8]+hl[v15&255]+hl[v14>>8]+hl[v14&255]+hl[v13>>8]+hl[v13&255]+hl[v12>>8]+hl[v12&255]+hl[v11>>8]+hl[v11&255]+hl[v10>>8]+hl[v10&255]+hl[v9>>8]+hl[v9&255]+hl[v8>>8]+hl[v8&255]+hl[v7>>8]+hl[v7&255]+hl[v6>>8]+hl[v6&255]+hl[v5>>8]+hl[v5&255]+hl[v4>>8]+hl[v4&255]+hl[v3>>8]+hl[v3&255]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[v0>>8]+hl[v0&255],1024);\n\t}\n\n\tfunction _hash1024_1(str){\n\t\tvar i,l=str.length-3,s=fnvConstants[1024].offset,t0=0,v0=s[63]|0,t1=0,v1=s[62]|0,t2=0,v2=s[61]|0,t3=0,v3=s[60]|0,t4=0,v4=s[59]|0,t5=0,v5=s[58]|0,t6=0,v6=s[57]|0,t7=0,v7=s[56]|0,t8=0,v8=s[55]|0,t9=0,v9=s[54]|0,t10=0,v10=s[53]|0,t11=0,v11=s[52]|0,t12=0,v12=s[51]|0,t13=0,v13=s[50]|0,t14=0,v14=s[49]|0,t15=0,v15=s[48]|0,t16=0,v16=s[47]|0,t17=0,v17=s[46]|0,t18=0,v18=s[45]|0,t19=0,v19=s[44]|0,t20=0,v20=s[43]|0,t21=0,v21=s[42]|0,t22=0,v22=s[41]|0,t23=0,v23=s[40]|0,t24=0,v24=s[39]|0,t25=0,v25=s[38]|0,t26=0,v26=s[37]|0,t27=0,v27=s[36]|0,t28=0,v28=s[35]|0,t29=0,v29=s[34]|0,t30=0,v30=s[33]|0,t31=0,v31=s[32]|0,t32=0,v32=s[31]|0,t33=0,v33=s[30]|0,t34=0,v34=s[29]|0,t35=0,v35=s[28]|0,t36=0,v36=s[27]|0,t37=0,v37=s[26]|0,t38=0,v38=s[25]|0,t39=0,v39=s[24]|0,t40=0,v40=s[23]|0,t41=0,v41=s[22]|0,t42=0,v42=s[21]|0,t43=0,v43=s[20]|0,t44=0,v44=s[19]|0,t45=0,v45=s[18]|0,t46=0,v46=s[17]|0,t47=0,v47=s[16]|0,t48=0,v48=s[15]|0,t49=0,v49=s[14]|0,t50=0,v50=s[13]|0,t51=0,v51=s[12]|0,t52=0,v52=s[11]|0,t53=0,v53=s[10]|0,t54=0,v54=s[9]|0,t55=0,v55=s[8]|0,t56=0,v56=s[7]|0,t57=0,v57=s[6]|0,t58=0,v58=s[5]|0,t59=0,v59=s[4]|0,t60=0,v60=s[3]|0,t61=0,v61=s[2]|0,t62=0,v62=s[1]|0,t63=0,v63=s[0]|0;\n\n\t\tfor (i = 0; i < l;) {\n\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t}\n\n\t\twhile(i<l+3){\n\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t\tv0^=str.charCodeAt(i++);\n\t\t}\n\n\t\treturn hashValHex(hl[v63>>8]+hl[v63&255]+hl[v62>>8]+hl[v62&255]+hl[v61>>8]+hl[v61&255]+hl[v60>>8]+hl[v60&255]+hl[v59>>8]+hl[v59&255]+hl[v58>>8]+hl[v58&255]+hl[v57>>8]+hl[v57&255]+hl[v56>>8]+hl[v56&255]+hl[v55>>8]+hl[v55&255]+hl[v54>>8]+hl[v54&255]+hl[v53>>8]+hl[v53&255]+hl[v52>>8]+hl[v52&255]+hl[v51>>8]+hl[v51&255]+hl[v50>>8]+hl[v50&255]+hl[v49>>8]+hl[v49&255]+hl[v48>>8]+hl[v48&255]+hl[v47>>8]+hl[v47&255]+hl[v46>>8]+hl[v46&255]+hl[v45>>8]+hl[v45&255]+hl[v44>>8]+hl[v44&255]+hl[v43>>8]+hl[v43&255]+hl[v42>>8]+hl[v42&255]+hl[v41>>8]+hl[v41&255]+hl[v40>>8]+hl[v40&255]+hl[v39>>8]+hl[v39&255]+hl[v38>>8]+hl[v38&255]+hl[v37>>8]+hl[v37&255]+hl[v36>>8]+hl[v36&255]+hl[v35>>8]+hl[v35&255]+hl[v34>>8]+hl[v34&255]+hl[v33>>8]+hl[v33&255]+hl[v32>>8]+hl[v32&255]+hl[v31>>8]+hl[v31&255]+hl[v30>>8]+hl[v30&255]+hl[v29>>8]+hl[v29&255]+hl[v28>>8]+hl[v28&255]+hl[v27>>8]+hl[v27&255]+hl[v26>>8]+hl[v26&255]+hl[v25>>8]+hl[v25&255]+hl[v24>>8]+hl[v24&255]+hl[v23>>8]+hl[v23&255]+hl[v22>>8]+hl[v22&255]+hl[v21>>8]+hl[v21&255]+hl[v20>>8]+hl[v20&255]+hl[v19>>8]+hl[v19&255]+hl[v18>>8]+hl[v18&255]+hl[v17>>8]+hl[v17&255]+hl[v16>>8]+hl[v16&255]+hl[v15>>8]+hl[v15&255]+hl[v14>>8]+hl[v14&255]+hl[v13>>8]+hl[v13&255]+hl[v12>>8]+hl[v12&255]+hl[v11>>8]+hl[v11&255]+hl[v10>>8]+hl[v10&255]+hl[v9>>8]+hl[v9&255]+hl[v8>>8]+hl[v8&255]+hl[v7>>8]+hl[v7&255]+hl[v6>>8]+hl[v6&255]+hl[v5>>8]+hl[v5&255]+hl[v4>>8]+hl[v4&255]+hl[v3>>8]+hl[v3&255]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[v0>>8]+hl[v0&255],1024);\n\t}\n\n\tfunction _hash1024_1a_utf(str){\n\t\tvar c,i,l=str.length,s=fnvConstants[1024].offset,t0=0,v0=s[63]|0,t1=0,v1=s[62]|0,t2=0,v2=s[61]|0,t3=0,v3=s[60]|0,t4=0,v4=s[59]|0,t5=0,v5=s[58]|0,t6=0,v6=s[57]|0,t7=0,v7=s[56]|0,t8=0,v8=s[55]|0,t9=0,v9=s[54]|0,t10=0,v10=s[53]|0,t11=0,v11=s[52]|0,t12=0,v12=s[51]|0,t13=0,v13=s[50]|0,t14=0,v14=s[49]|0,t15=0,v15=s[48]|0,t16=0,v16=s[47]|0,t17=0,v17=s[46]|0,t18=0,v18=s[45]|0,t19=0,v19=s[44]|0,t20=0,v20=s[43]|0,t21=0,v21=s[42]|0,t22=0,v22=s[41]|0,t23=0,v23=s[40]|0,t24=0,v24=s[39]|0,t25=0,v25=s[38]|0,t26=0,v26=s[37]|0,t27=0,v27=s[36]|0,t28=0,v28=s[35]|0,t29=0,v29=s[34]|0,t30=0,v30=s[33]|0,t31=0,v31=s[32]|0,t32=0,v32=s[31]|0,t33=0,v33=s[30]|0,t34=0,v34=s[29]|0,t35=0,v35=s[28]|0,t36=0,v36=s[27]|0,t37=0,v37=s[26]|0,t38=0,v38=s[25]|0,t39=0,v39=s[24]|0,t40=0,v40=s[23]|0,t41=0,v41=s[22]|0,t42=0,v42=s[21]|0,t43=0,v43=s[20]|0,t44=0,v44=s[19]|0,t45=0,v45=s[18]|0,t46=0,v46=s[17]|0,t47=0,v47=s[16]|0,t48=0,v48=s[15]|0,t49=0,v49=s[14]|0,t50=0,v50=s[13]|0,t51=0,v51=s[12]|0,t52=0,v52=s[11]|0,t53=0,v53=s[10]|0,t54=0,v54=s[9]|0,t55=0,v55=s[8]|0,t56=0,v56=s[7]|0,t57=0,v57=s[6]|0,t58=0,v58=s[5]|0,t59=0,v59=s[4]|0,t60=0,v60=s[3]|0,t61=0,v61=s[2]|0,t62=0,v62=s[1]|0,t63=0,v63=s[0]|0;\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tc = str.charCodeAt(i);\n\t\t\tif(c < 128){\n\t\t\t\tv0^=c;\n\t\t\t}else if(c < 2048){\n\t\t\t\tv0^=(c>>6)|192;\n\t\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else if(((c&64512)==55296)&&(i+1)<l&&((str.charCodeAt(i+1)&64512)==56320)){\n\t\t\t\tc=65536+((c&1023)<<10)+(str.charCodeAt(++i)&1023);\n\t\t\t\tv0^=(c>>18)|240;\n\t\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t\t\tv0^=((c>>12)&63)|128;\n\t\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else{\n\t\t\t\tv0^=(c>>12)|224;\n\t\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}\n\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t}\n\n\t\treturn hashValHex(hl[v63>>8]+hl[v63&255]+hl[v62>>8]+hl[v62&255]+hl[v61>>8]+hl[v61&255]+hl[v60>>8]+hl[v60&255]+hl[v59>>8]+hl[v59&255]+hl[v58>>8]+hl[v58&255]+hl[v57>>8]+hl[v57&255]+hl[v56>>8]+hl[v56&255]+hl[v55>>8]+hl[v55&255]+hl[v54>>8]+hl[v54&255]+hl[v53>>8]+hl[v53&255]+hl[v52>>8]+hl[v52&255]+hl[v51>>8]+hl[v51&255]+hl[v50>>8]+hl[v50&255]+hl[v49>>8]+hl[v49&255]+hl[v48>>8]+hl[v48&255]+hl[v47>>8]+hl[v47&255]+hl[v46>>8]+hl[v46&255]+hl[v45>>8]+hl[v45&255]+hl[v44>>8]+hl[v44&255]+hl[v43>>8]+hl[v43&255]+hl[v42>>8]+hl[v42&255]+hl[v41>>8]+hl[v41&255]+hl[v40>>8]+hl[v40&255]+hl[v39>>8]+hl[v39&255]+hl[v38>>8]+hl[v38&255]+hl[v37>>8]+hl[v37&255]+hl[v36>>8]+hl[v36&255]+hl[v35>>8]+hl[v35&255]+hl[v34>>8]+hl[v34&255]+hl[v33>>8]+hl[v33&255]+hl[v32>>8]+hl[v32&255]+hl[v31>>8]+hl[v31&255]+hl[v30>>8]+hl[v30&255]+hl[v29>>8]+hl[v29&255]+hl[v28>>8]+hl[v28&255]+hl[v27>>8]+hl[v27&255]+hl[v26>>8]+hl[v26&255]+hl[v25>>8]+hl[v25&255]+hl[v24>>8]+hl[v24&255]+hl[v23>>8]+hl[v23&255]+hl[v22>>8]+hl[v22&255]+hl[v21>>8]+hl[v21&255]+hl[v20>>8]+hl[v20&255]+hl[v19>>8]+hl[v19&255]+hl[v18>>8]+hl[v18&255]+hl[v17>>8]+hl[v17&255]+hl[v16>>8]+hl[v16&255]+hl[v15>>8]+hl[v15&255]+hl[v14>>8]+hl[v14&255]+hl[v13>>8]+hl[v13&255]+hl[v12>>8]+hl[v12&255]+hl[v11>>8]+hl[v11&255]+hl[v10>>8]+hl[v10&255]+hl[v9>>8]+hl[v9&255]+hl[v8>>8]+hl[v8&255]+hl[v7>>8]+hl[v7&255]+hl[v6>>8]+hl[v6&255]+hl[v5>>8]+hl[v5&255]+hl[v4>>8]+hl[v4&255]+hl[v3>>8]+hl[v3&255]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[v0>>8]+hl[v0&255],1024);\n\t}\n\n\tfunction _hash1024_1_utf(str){\n\t\tvar c,i,l=str.length,s=fnvConstants[1024].offset,t0=0,v0=s[63]|0,t1=0,v1=s[62]|0,t2=0,v2=s[61]|0,t3=0,v3=s[60]|0,t4=0,v4=s[59]|0,t5=0,v5=s[58]|0,t6=0,v6=s[57]|0,t7=0,v7=s[56]|0,t8=0,v8=s[55]|0,t9=0,v9=s[54]|0,t10=0,v10=s[53]|0,t11=0,v11=s[52]|0,t12=0,v12=s[51]|0,t13=0,v13=s[50]|0,t14=0,v14=s[49]|0,t15=0,v15=s[48]|0,t16=0,v16=s[47]|0,t17=0,v17=s[46]|0,t18=0,v18=s[45]|0,t19=0,v19=s[44]|0,t20=0,v20=s[43]|0,t21=0,v21=s[42]|0,t22=0,v22=s[41]|0,t23=0,v23=s[40]|0,t24=0,v24=s[39]|0,t25=0,v25=s[38]|0,t26=0,v26=s[37]|0,t27=0,v27=s[36]|0,t28=0,v28=s[35]|0,t29=0,v29=s[34]|0,t30=0,v30=s[33]|0,t31=0,v31=s[32]|0,t32=0,v32=s[31]|0,t33=0,v33=s[30]|0,t34=0,v34=s[29]|0,t35=0,v35=s[28]|0,t36=0,v36=s[27]|0,t37=0,v37=s[26]|0,t38=0,v38=s[25]|0,t39=0,v39=s[24]|0,t40=0,v40=s[23]|0,t41=0,v41=s[22]|0,t42=0,v42=s[21]|0,t43=0,v43=s[20]|0,t44=0,v44=s[19]|0,t45=0,v45=s[18]|0,t46=0,v46=s[17]|0,t47=0,v47=s[16]|0,t48=0,v48=s[15]|0,t49=0,v49=s[14]|0,t50=0,v50=s[13]|0,t51=0,v51=s[12]|0,t52=0,v52=s[11]|0,t53=0,v53=s[10]|0,t54=0,v54=s[9]|0,t55=0,v55=s[8]|0,t56=0,v56=s[7]|0,t57=0,v57=s[6]|0,t58=0,v58=s[5]|0,t59=0,v59=s[4]|0,t60=0,v60=s[3]|0,t61=0,v61=s[2]|0,t62=0,v62=s[1]|0,t63=0,v63=s[0]|0;\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tc = str.charCodeAt(i);\n\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t\tif(c < 128){\n\t\t\t\tv0^=c;\n\t\t\t}else if(c < 2048){\n\t\t\t\tv0^=(c>>6)|192;\n\t\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else if(((c&64512)==55296)&&(i+1)<l&&((str.charCodeAt(i+1)&64512)==56320)){\n\t\t\t\tc=65536+((c&1023)<<10)+(str.charCodeAt(++i)&1023);\n\t\t\t\tv0^=(c>>18)|240;\n\t\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t\t\tv0^=((c>>12)&63)|128;\n\t\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}else{\n\t\t\t\tv0^=(c>>12)|224;\n\t\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t\t\tv0^=((c>>6)&63)|128;\n\t\t\t\tt0=v0*397;t1=v1*397;t2=v2*397;t3=v3*397;t4=v4*397;t5=v5*397;t6=v6*397;t7=v7*397;t8=v8*397;t9=v9*397;t10=v10*397;t11=v11*397;t12=v12*397;t13=v13*397;t14=v14*397;t15=v15*397;t16=v16*397;t17=v17*397;t18=v18*397;t19=v19*397;t20=v20*397;t21=v21*397;t22=v22*397;t23=v23*397;t24=v24*397;t25=v25*397;t26=v26*397;t27=v27*397;t28=v28*397;t29=v29*397;t30=v30*397;t31=v31*397;t32=v32*397;t33=v33*397;t34=v34*397;t35=v35*397;t36=v36*397;t37=v37*397;t38=v38*397;t39=v39*397;t40=v40*397;t41=v41*397;t42=v42*397;t43=v43*397;t44=v44*397;t45=v45*397;t46=v46*397;t47=v47*397;t48=v48*397;t49=v49*397;t50=v50*397;t51=v51*397;t52=v52*397;t53=v53*397;t54=v54*397;t55=v55*397;t56=v56*397;t57=v57*397;t58=v58*397;t59=v59*397;t60=v60*397;t61=v61*397;t62=v62*397;t63=v63*397;\n\t\t\t\tt42+=v0<<8;t43+=v1<<8;t44+=v2<<8;t45+=v3<<8;t46+=v4<<8;t47+=v5<<8;t48+=v6<<8;t49+=v7<<8;t50+=v8<<8;t51+=v9<<8;t52+=v10<<8;t53+=v11<<8;t54+=v12<<8;t55+=v13<<8;t56+=v14<<8;t57+=v15<<8;t58+=v16<<8;t59+=v17<<8;t60+=v18<<8;t61+=v19<<8;t62+=v20<<8;t63+=v21<<8;\n\t\t\t\tt1+=t0>>>16;v0=t0&65535;t2+=t1>>>16;v1=t1&65535;t3+=t2>>>16;v2=t2&65535;t4+=t3>>>16;v3=t3&65535;t5+=t4>>>16;v4=t4&65535;t6+=t5>>>16;v5=t5&65535;t7+=t6>>>16;v6=t6&65535;t8+=t7>>>16;v7=t7&65535;t9+=t8>>>16;v8=t8&65535;t10+=t9>>>16;v9=t9&65535;t11+=t10>>>16;v10=t10&65535;t12+=t11>>>16;v11=t11&65535;t13+=t12>>>16;v12=t12&65535;t14+=t13>>>16;v13=t13&65535;t15+=t14>>>16;v14=t14&65535;t16+=t15>>>16;v15=t15&65535;t17+=t16>>>16;v16=t16&65535;t18+=t17>>>16;v17=t17&65535;t19+=t18>>>16;v18=t18&65535;t20+=t19>>>16;v19=t19&65535;t21+=t20>>>16;v20=t20&65535;t22+=t21>>>16;v21=t21&65535;t23+=t22>>>16;v22=t22&65535;t24+=t23>>>16;v23=t23&65535;t25+=t24>>>16;v24=t24&65535;t26+=t25>>>16;v25=t25&65535;t27+=t26>>>16;v26=t26&65535;t28+=t27>>>16;v27=t27&65535;t29+=t28>>>16;v28=t28&65535;t30+=t29>>>16;v29=t29&65535;t31+=t30>>>16;v30=t30&65535;t32+=t31>>>16;v31=t31&65535;t33+=t32>>>16;v32=t32&65535;t34+=t33>>>16;v33=t33&65535;t35+=t34>>>16;v34=t34&65535;t36+=t35>>>16;v35=t35&65535;t37+=t36>>>16;v36=t36&65535;t38+=t37>>>16;v37=t37&65535;t39+=t38>>>16;v38=t38&65535;t40+=t39>>>16;v39=t39&65535;t41+=t40>>>16;v40=t40&65535;t42+=t41>>>16;v41=t41&65535;t43+=t42>>>16;v42=t42&65535;t44+=t43>>>16;v43=t43&65535;t45+=t44>>>16;v44=t44&65535;t46+=t45>>>16;v45=t45&65535;t47+=t46>>>16;v46=t46&65535;t48+=t47>>>16;v47=t47&65535;t49+=t48>>>16;v48=t48&65535;t50+=t49>>>16;v49=t49&65535;t51+=t50>>>16;v50=t50&65535;t52+=t51>>>16;v51=t51&65535;t53+=t52>>>16;v52=t52&65535;t54+=t53>>>16;v53=t53&65535;t55+=t54>>>16;v54=t54&65535;t56+=t55>>>16;v55=t55&65535;t57+=t56>>>16;v56=t56&65535;t58+=t57>>>16;v57=t57&65535;t59+=t58>>>16;v58=t58&65535;t60+=t59>>>16;v59=t59&65535;t61+=t60>>>16;v60=t60&65535;t62+=t61>>>16;v61=t61&65535;v63=(t63+(t62>>>16))&65535;v62=t62&65535;\n\t\t\t\tv0^=(c&63)|128;\n\t\t\t}\n\t\t}\n\n\t\treturn hashValHex(hl[v63>>8]+hl[v63&255]+hl[v62>>8]+hl[v62&255]+hl[v61>>8]+hl[v61&255]+hl[v60>>8]+hl[v60&255]+hl[v59>>8]+hl[v59&255]+hl[v58>>8]+hl[v58&255]+hl[v57>>8]+hl[v57&255]+hl[v56>>8]+hl[v56&255]+hl[v55>>8]+hl[v55&255]+hl[v54>>8]+hl[v54&255]+hl[v53>>8]+hl[v53&255]+hl[v52>>8]+hl[v52&255]+hl[v51>>8]+hl[v51&255]+hl[v50>>8]+hl[v50&255]+hl[v49>>8]+hl[v49&255]+hl[v48>>8]+hl[v48&255]+hl[v47>>8]+hl[v47&255]+hl[v46>>8]+hl[v46&255]+hl[v45>>8]+hl[v45&255]+hl[v44>>8]+hl[v44&255]+hl[v43>>8]+hl[v43&255]+hl[v42>>8]+hl[v42&255]+hl[v41>>8]+hl[v41&255]+hl[v40>>8]+hl[v40&255]+hl[v39>>8]+hl[v39&255]+hl[v38>>8]+hl[v38&255]+hl[v37>>8]+hl[v37&255]+hl[v36>>8]+hl[v36&255]+hl[v35>>8]+hl[v35&255]+hl[v34>>8]+hl[v34&255]+hl[v33>>8]+hl[v33&255]+hl[v32>>8]+hl[v32&255]+hl[v31>>8]+hl[v31&255]+hl[v30>>8]+hl[v30&255]+hl[v29>>8]+hl[v29&255]+hl[v28>>8]+hl[v28&255]+hl[v27>>8]+hl[v27&255]+hl[v26>>8]+hl[v26&255]+hl[v25>>8]+hl[v25&255]+hl[v24>>8]+hl[v24&255]+hl[v23>>8]+hl[v23&255]+hl[v22>>8]+hl[v22&255]+hl[v21>>8]+hl[v21&255]+hl[v20>>8]+hl[v20&255]+hl[v19>>8]+hl[v19&255]+hl[v18>>8]+hl[v18&255]+hl[v17>>8]+hl[v17&255]+hl[v16>>8]+hl[v16&255]+hl[v15>>8]+hl[v15&255]+hl[v14>>8]+hl[v14&255]+hl[v13>>8]+hl[v13&255]+hl[v12>>8]+hl[v12&255]+hl[v11>>8]+hl[v11&255]+hl[v10>>8]+hl[v10&255]+hl[v9>>8]+hl[v9&255]+hl[v8>>8]+hl[v8&255]+hl[v7>>8]+hl[v7&255]+hl[v6>>8]+hl[v6&255]+hl[v5>>8]+hl[v5&255]+hl[v4>>8]+hl[v4&255]+hl[v3>>8]+hl[v3&255]+hl[v2>>8]+hl[v2&255]+hl[v1>>8]+hl[v1&255]+hl[v0>>8]+hl[v0&255],1024);\n\t}\n\n\t_hash1024 = _hash1024_1a;\n\n\t// Init library.\n\tsetVersion('1a');\n\tsetUTF8(false);\n\tseed();\n\n\treturn {\n\t\thash: hash,\n\t\tsetKeyspace: setKeyspace,\n\t\tversion: setVersion,\n\t\tuseUTF8: setUTF8,\n\t\tseed: seed,\n\t\tfast1a32: _hash32_1a_fast,\n\t\tfast1a32hex:_hash32_1a_fast_hex,\n\t\tfast1a52: _hash52_1a_fast,\n\t\tfast1a52hex: _hash52_1a_fast_hex,\n\t\tfast1a64: _hash64_1a_fast,\n\t\tfast1a32utf: _hash32_1a_fast_utf,\n\t\tfast1a32hexutf:_hash32_1a_fast_hex_utf,\n\t\tfast1a52utf: _hash52_1a_fast_utf,\n\t\tfast1a52hexutf: _hash52_1a_fast_hex_utf,\n\t\tfast1a64utf: _hash64_1a_fast_utf\n\t};\n})();\n\nif ( true && typeof module.exports != \"undefined\") module.exports = fnvplus;\n\n\n//# sourceURL=webpack:///./node_modules/fnv-plus/index.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack:///./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack:///./node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/nanoassert/index.js":
/*!******************************************!*\
  !*** ./node_modules/nanoassert/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("assert.notEqual = notEqual\nassert.notOk = notOk\nassert.equal = equal\nassert.ok = assert\n\nmodule.exports = assert\n\nfunction equal (a, b, m) {\n  assert(a == b, m) // eslint-disable-line eqeqeq\n}\n\nfunction notEqual (a, b, m) {\n  assert(a != b, m) // eslint-disable-line eqeqeq\n}\n\nfunction notOk (t, m) {\n  assert(!t, m)\n}\n\nfunction assert (t, m) {\n  if (!t) throw new Error(m || 'AssertionError')\n}\n\n\n//# sourceURL=webpack:///./node_modules/nanoassert/index.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/harmony-module.js?");

/***/ })

}]);